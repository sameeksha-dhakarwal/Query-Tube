id,title,description,publishedAt,tags,categoryId,defaultLanguage,defaultAudioLanguage,thumbnail_default,thumbnail_high,duration,viewCount,likeCount,commentCount,privacyStatus,channel_id,channel_title,channel_description,channel_country,channel_thumbnail,channel_subscriberCount,channel_videoCount,uploads_playlist,transcript
Ky1WodwYUA8,Ex-Google Engineer Reveals How to Pass a Technical Interview ft .@KevinNaughtonJr,"Today, you are going to learn exactly what it takes to pass a technical interview. In order to explain that to you, I brought one of my good friends, Kevin (  @KevinNaughtonJr  ). He is an Ex-Google, Ex-Amazon Software Engineer. He worked over eight years in the tech industry, and throughout his time there he's given hundreds of technical interviews. I brought him on to the channel to explain it to you.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=Ky1WodwYUA8

Hashtags
#technicalinterview #exgoogle #softwareengineer",2025-11-30T11:01:49Z,"tech with tim, google interview, technical interview tips, coding interview prep, software engineering interview, google engineer advice, technical interview questions, coding interview strategies, interview preparation, tech job interview, programming interview tips, interview coding challenges, software developer interview, technical skills for google, tech interview techniques, interview success tips",27,en,en-CA,https://i.ytimg.com/vi/Ky1WodwYUA8/default.jpg,https://i.ytimg.com/vi/Ky1WodwYUA8/hqdefault.jpg,PT22M22S,984,98,2,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Today, you are going to learn exactly what it takes to pass a technical interview.  Now, in order to explain that to you, I brought one of my good friends, Kevin.  Now, Kevin is an X Google X Amazon software engineer. He worked over eight years in the tech  industry and throughout his time there, he's given hundreds of technical interviews.  He's also my partner inside of DevLaunch, where we have trained many engineers to pass these  types of technical interviews, especially at large tech companies. Kevin knows the interview process  in and out much better than I do, so I brought him onto the channel to explain it to you.  We go over common pitfalls, we go over the recipe that you need to follow,  what to do before, after, ensuring the interview, and I promise you in this video,  you are going to learn a ton. Now, if you want to learn directly from Kevin and myself as well  as a bunch of other experienced software engineers, you can apply to DevLaunch by clicking the link  down below. With that said, let's get into it. Kevin, thank you for sitting down with me here.  I like to refer to you as the interviewing expert, even though I know it's tough to be an expert  at interviewing, because you have just done far more than I have, so that's why I brought you on  the channel. I want to ask you in this video, how the heck do you prepare and pass a technical  interview? Sound good? Sounds good, let's do it. I have a general structure, feel free to go off  of it, because again, you're the expert here, that's why you're on the channel, but let's start with  preparation. Let's say I'm a new grad, I don't have any of the experience I've had before, and I  land an interview at Metta, and I get one at a video, or I get one at Google, et cetera, we're talking  big tech companies here. How the heck do I prepare for that? I think the first thing you have to do is  you have to educate yourself on what you're walking into. The most guaranteed way to fail is to walk  into the interview having no idea what you're about to do, so become familiar with the process,  all these different companies might have, different processes or slightly different processes,  although they generally follow sort of the same thing. You'll probably do a recruiter phone screen,  if you do well on that, or don't raise any red flags, you'll probably do a technical phone screen,  and if you do well on that, you'll probably have a full loop that's on-site, either virtual  or at the campus, and you'll probably do four or five interviews that whole day. So first thing  is just know what you're walking into, know what you're getting into. The second thing is that  everything you're going to do is actually about what you do now between now and the actual interview.  So if it's a lead code style thing, do problems, do problems every single day, and make sure that you're  learning all the different maybe 15 topics that are going to be tested during those technical interviews,  and that's really what it comes down to. So in a very simple case, it's like you have to know the  technical skills for how to solve these problems, and you need to know these different data structures  and algorithms to apply to these problems. So if you do enough of them, you'll start learning the  patterns, and really the biggest part about these interviews is these are massive opportunities,  so don't take them lightly, prepare heavily, do problems every single day, and it really could be a  life-changing offer that you land if you're willing to do that work. Okay, perfect. Is there anything else  you think that I should do, like should I, for example, look up like the company mission statement,  should I go like research on Reddit for 10 hours and see the problems that have been asked before,  is there any little tricks like that maybe? Yeah, so luckily it's not really a science, and what I  love about that is it's not like gaming the system per se, but really what you could do is like,  lead code has a frequency disorder, so you could see like, oh, these are the most common questions  asked by Nvidia right now. Obviously all these companies are not supposed to ask any questions that  are leaked, and that's something that you're told it all these different companies, but still some,  you know, people might ask them or they might not know questions leaked, but you should do your due  diligence, right? You shouldn't walk into a meta interview, get the most frequently asked question  on leaked code from meta, and then not know how to solve that problem, right? That would be really  silly. So know what you're getting into and make sure that you do your due diligence there,  but for better or worse, there's not really a secret recipe. It's just making sure that you allocate  enough time to learn these different topics and concepts, and while that sounds really dry and boring,  I think it should actually be exciting to you, because there's no secret sauce really, like what stands  between you and getting an offer or doing well in these interviews is just doing enough work,  and learning all these different topics, not memorizing. For sure. Okay, I think that's probably  a relief to a lot of people to hear that. And I mean, that reminds me of when I was doing my interviews  back in the day, I didn't have some like crazy science that I was doing. I generally was just like,  I want to be really comfortable being able to answer any type of question. And that means I kind of  need to know the court patterns. I need to obviously know how to code and be fluent and have the syntax  down. I need to have practice, you know, communicating my thought process, and we can get into that now.  So, okay, we've done a little bit of prep. We've got the lead code out of the way. Let's say I'm  walking in now to my on-site interviews. And let's imagine we fast forward to the point where  I actually get asked a technical question, you know, reverse the links list, something along those  lines. What do I do now? Is there some kind of formula to follow? Do I just like start coding right  away? What does that look like? Yeah, so the funny thing here is like, the good is it should just be  doing what you already know how to do, right? If you've put in enough work and you've gone to all  these different problems, you probably feel right at home with whatever question you've been asked.  Really, that's hopefully how you feel. But what I recommend to people is that you want interviews  to be very much like a recipe. You can imagine that if you've baked a cake once, you probably need to  look at the recipe, right? The pages aren't creased. You don't really know what you're doing,  get the double check, how much sugar. But when you've done that recipe a hundred different times,  it becomes ingrained in your memory. And you really want interviews to become  a recipe. So you want to have a guaranteed set of steps, concrete steps, clear steps that  metaphorically get you a cake by the end of it, right? You could bake a cake on your own during  that interview. So you want to practice that recipe sort of beforehand. And that bake really boils  down to like seven or so different steps in my experience. And what I really think that comes  down to is just first reading and understanding the problem. You can't solve a problem if you don't  understand it. And it sounds silly, but we'll probably talk about this later. There was a time  where I didn't understand when I was being asked and acted like I did. The second step is to  ask clarifying questions. You're oftentimes not given all the information in a problem on purpose  because building software is ambiguous. If I told you to go make a to-do list app, there might be  things that I'm expecting you to do. And if you don't ask questions, you might not build the right  thing. The third thing is to actually propose different solutions. If you could say, here's three ways  to solve this problem. And option B is the best because A, B, and C, that looks really good. Once  you could actually tell the interviewer how to solve the problem, then you basically want to  write your solution. And that should be really easy. That should be the easiest part of the interview  ironically. If you know what you're doing, it should take you maybe two or three minutes to type  out the solution. And then step five is really to rubber duck. Everybody makes mistakes. You want to  make sure that if you've written a bunch of code, you didn't make any mistakes. And if you did,  it's okay. But it looks better if you find the problems before the interviewer does. Step six is  basically to ask, you know, like talk about any pitfalls or optimizations that you can make.  And seven released to just talk about the runtime and the space complexity because that's  important, right? All the software runs at massive scales and you want to make sure that you're not  slowing down things unnecessarily. So follow a recipe. That's sort of the recipe that I like to follow.  But you need to make sure that you have reproducible steps that are going to help you pass the interview.  Yeah, that's great. What I love about the recipe and this is exactly what I followed. Not like  the exact wording that you had very similar when I was doing my interviews is that it gives you  something to kind of crutch on where if you don't actually know exactly how to solve the problem  or what to do, you can at least make progress because you know you just start at step one and then  you go to step two and then you go to step three. And even if you get stuck at a certain point,  you're not just kind of guessing because a lot of people when I see an interview, especially when  we do mocks inside of dev launch and stuff, is that they just kind of like give up. They get  asked the question and they don't really know what to do next. They haven't learned the recipe,  for example, and they're just kind of in this space where nothing gets done. At least where if  you have the recipe, you can get through the first few steps without needing to know the exact  most optimal solution to the code. And you can make progress where you give yourself a chance,  you can get some hints like you can make some progress in the interview. Or if you don't have  that recipe or kind of just guessing and you know like we've said, it's very difficult to succeed  if you don't know what you're about to do. You know it's hard enough to solve the problem.  It's another level of complexity if you don't know how you're going to go about presenting that  to the interviewer. Now let's get into a few specifics. I mean I'm familiar with tech interviews  as well, but you really know a lot more than me. Is there a certain time allocation that I should  have for some of these steps? So for example, like planning and coming up with the solution versus  coding. I know you said coding like two or three minutes, but what is like the optimal amount of time  I should spend in these areas? Yeah, so it's hard to break it down super succinctly, but generally  speaking, I think a good rule of thumb is that you want to be writing code within the first 10  minutes. And what I think that does is it makes sure that you feel a certain amount of pressure to  like read and understand the problem, to ask those clarifying questions, to figure out what a solution  is to the problem and then to start writing your code. So having that sort of time limit on  yourself, I think it's just a good guide post. And I also think that's really good too because  let's say a company expects you to only solve one problem during that a lot of time. I think  if you could start coding the solution to a problem within 10 minutes and it only takes you a  couple minutes to solve the problem, right, or to write the solution to the problem, I think  you're teaming yourself up to actually solve two questions during that interview. And I think  that looks really good, right? Your goal shouldn't be to meet some company's bar. It should be to  define a new bar. And so if you practice like that, right? If you practice, oh, during this interview,  I'm gonna have 40 minutes to solve it. But if you do your practice like you only have 20 minutes,  it's gonna be way easier. You want your practice to emulate the real thing. And so while it's hard  to put exact time bounds on these different things, I think a good rule of thumb is to try and be  writing your code within the first 10 minutes. Okay. Yeah, I think that's a good benchmark to aim for.  How do companies evaluate your performance in the interview? Sure, we have the rest of  it. We go through. We're gonna do those things. Is there like a rubric that they have? Is there  a certain like check boxes that they're looking for? I know you've given some of these interviews  before. Can you give me some insight there? Yeah, I mean, a lot of it has to do with like making  sure that you are checking certain boxes. Like, for example, one of the things we talked about is  asking clarifying questions. Again, that's on purpose, right? It's expected that you're gonna ask  clarifying questions because that's what you do on the job, right? That's very similar to what you do  when you gather requirements for a product or when you're designing a system, like what it needs  to support, what it shouldn't support, what's in scope, what's out of scope. So that's one of the  things, for example, that we're looking at. But in general, yeah, there is a rubric. You want to  make sure that someone's collaborative. You want to make sure that someone actually understands  very deep technical things, right? Because you want to at the core of it, everything is about  being technically competent. And so if you're not, that's a problem. So a lot of it has to come down  to checking those certain boxes. And I think the other thing that's a little bit more like underlying,  that's not necessarily on a rubric, but like, you can imagine that.  Someone's giving you a question.  They might have given that question  to a hundred other candidates, right?  And so it's not someone's stack ranking you,  but if someone else has solved that problem  really, really efficiently or really, really well,  you might be somehow compared to those people  even subconsciously if that makes sense, right?  If I've asked this question to a hundred different people,  I kind of have a good benchmark for like,  what is a good passing mark  and what's maybe a failing mark  or how far I expect a candidate to get during this problem.  So there's definitely a rubric or criteria  that people look for and that companies  tell interviewers to look for.  And then I think there's a little bit of  like a subconscious thing  because an interviewer might have asked a question  so many times.  Yeah, that's a good point.  And I think people will just do that naturally  even if they're guided not to.  I mean, I'm sure that's like, okay,  don't compare them to the other people,  do an independent evaluation.  But at the end of the day,  you're picking between different candidates.  So of course, I mean, that's gonna come up in your brain.  Now, communication, let's touch on that a little bit  because obviously, you know, this rubric  that we've kind of are not rubric,  I guess formula recipe that we've shared aims  so that you over communicate,  but can you touch on how important  that is in the interviews?  Because I notice a lot of candidates  when I give them the mock interviews,  they really don't kind of hit  on that communication component.  And they think that if they can just whip up,  you know, the fastest coded solution immediately,  they're gonna pass the interview  when that's really only half the battle.  But I just wanna hear it from you.  Like, what has your experience been with candidates  communicating, not communicating?  What is the importance there?  One of the biggest things to understand here  is that people think that interviewers  are this weird, scary thing  where you're being judged 45 minutes  in silence by an interviewer.  But the reality is that this is the exact opposite  of what a good interview should be.  In my opinion, a good interview should be collaborative.  Right?  And the way to do that as an interviewer is to make sure  that when you're communicating,  you're really bringing your interviewer with you  every step of the way.  You're making sure that you're walking in lockstep, right?  They understand everything you're doing,  why you're doing it,  why you made a certain decision,  what the trade-offs are.  And so you really wanna communicate in a way  that is effective, obviously.  I want the interviewer to understand what I'm saying.  And then the other thing too,  I think that people get nervous about,  especially during these high-pressure situations  is that they tend to ramble.  So you wanna make sure that when you are communicating,  you're doing so succinctly  and you're getting all the information that you need.  But just remember, every single step in the interview  should be you walking with your interviewer together.  So one of the things, for example,  that you can just do too is it's kind of a game, right?  Part of the interview should be trying to make sure  that you are getting as much help as possible  without actually asking for help directly.  So one of the best ways that I think to do this  is when I propose a solution  during every single one of my interviews,  I always ask the interviewer, how does it sound to you?  And by doing that, it's sort of riding this line  between me saying, I actually don't think this will work  or I'm not sure if this will work.  It's not saying that at all.  And it's also not saying,  this is 100% guaranteed gonna work.  This is the best possible solution.  I'm just sort of sitting on the fence  and I'm saying, how does it sound to you, Tim?  And that's a social cue that A, the person has to answer.  And B, whether they want to or not,  they're probably gonna somehow guide me  whether it's right or wrong, right?  They're gonna give me a green light,  like that looks good or that sounds good to me, Kevin.  And then I know that's probably a social cue  that that's a good solution.  I can probably go forward.  Or they might say something that's like a yellow light  and it might be something like,  are you sure that that, you know,  is gonna pass for this specific test case?  And then I should think about,  what am I missing here?  Or it might be a red light, right?  They might give me something completely different.  That's like, I'm not sure if that's gonna work.  Or maybe something a little bit less direct.  But the way you communicate is also the way that you get help.  And if you learn how to get help without actually saying,  like, oh, I have no idea if this is gonna work,  you have a better chance of passing the interview.  And I think part of that has a lot to do  with like being socially competent  and understanding people's cues.  Yeah, I think that's a really good point.  They're just like being friendly, not being awkward,  and also realizing that it is a conversation.  And ultimately, anytime I've given an interview  and probably similar with you,  I want the person to succeed.  Like when I bring someone in for an interview,  I hope that they're gonna be the best candidate  that I've ever seen,  because I want the best candidate, I wanna hire them.  I'm not praying for their downfall  or hoping that they fail this question.  And I have no ego attached to them,  you know, blowing it out of the water,  I hope that they do that.  So the more that they allow me to give them  that little bit of assistance,  though giving away the question,  you know, typically what I've done in interviews,  I like to do that because I'm rooting for that candidate.  But you wanna be on that side early on in the interview,  what because you're communicating,  whereas this someone just sits there and completes silence,  you kinda give up on them a little bit,  you have no idea what they're thinking or doing,  and you can't even really help them if you want to  because you have no clue where they're going, right?  And in my interview, I remember a very clear point  where I had explained everything very well,  I'm also used to doing this because I,  you know, do tech tutorials online  where you kind of have to do that.  And I got to a point where there's this kind of,  like, complex part of the code,  and I had explained exactly what I wanted to code.  And the interviewer just told me,  oh, don't worry, but you don't need to code that out,  just do like three dots,  we know what you're gonna do there  because you explained it.  Like, think about how beneficial that can be to you  as a candidate where you can just skip writing  an entire function or code block  because you explained it so well that the interview  or just believes that it's gonna work,  and you just move on.  Like, that's the situations that you wanna be in,  which you can only get into by communicating clearly.  So I think that's, you know, a great description there.  Let's say, you know, we followed Kevin's advice,  everything.  going great, we've finished the interview, the technical side of things at least, what should  we do after the interview? Should we follow up with the person? Should we spam a bunch of times?  Is there questions we should ask them? Let's say we're at the tail end where we did the technical  part and now we're kind of rolling off, maybe moving into the next one. Is there anything there  that we should think about from the technical interview side? So are we saying that we're still in  the interview but we just finished the technical portion? Yes, sorry. It's a hard way for me to explain  that. Yeah, you know what I mean? Yeah, so what I really like to do, and again, a lot of this comes  down to just being technically competent. For better or for worse, if you want to be a software  engineer, you have to know how to write code, a fishing code that's well maintained, that's  documented that people can change and update. So while I don't think there's tons that you could  do the last five minutes of the interview, that's going to really move the needle. A lot of the  performance has already passed. What I do like to do is try and do things that make the interviewer  think of me or think of me as a unique candidate. So for example, you kind of want to stand out in their  brain. And I think one of the best ways to do that is just to ask unique or meaningful questions.  You have to remember this is a two-way street, right? You want to know as much as they want to know,  should you work at this company? You want to know, do I want to work at this company? And I think  you should A, ask questions that are actually of interest to you that will help you make a decision  if you do end up getting an offer from this company for if you want to join. But I think you also  want to ask questions that they probably don't hear all the time, right? So if you said someone asked  you like, oh, what's your typical day like? That's fine to ask, but I don't think it's very unique.  I've probably been asked that a hundred different times from a million different people, right? And  I think it's not very special, you know, whereas if I asked something that was more informative,  like if you go back and start from day one at Google, what's one thing you tell yourself to  become the best engineer possible? I think that's A, interesting. I think that they probably don't  get that question a lot. And I think B, it's actually helpful for your own career, right? That's  something that you can take and know if I join this company or maybe even another 10-genual company.  That's probably a thing that I should listen to. This person might be a staff engineer  interviewing me and they told me that I should make sure that I ask questions every single person  within the first month of joining. And that could be really valuable advice even for your own  career. So just try and ask questions that are unique, things that they don't hear all the time,  and also things that are going to help you make a decision about joining the company or help you  in your own career as well. Because these are valuable people to talk to. Like remember that,  these are good engineers. Yeah, and you can learn a lot with the correct question and people love  to talk, especially about themselves. If you ask them a really insightful question, then they're  going to be engaged and they're going to want to give you a good answer. So that's a great point.  Now, let's get into a few like kind of more rapid-fire questions to some extent here.  Is there one particular trait that you notice across the candidates that are successful  in these interviews? Can you, for example, in like five or ten minutes when someone comes to  the interview? Can you tell if they're going to be a good candidate or not, like right away?  I think you can definitely tell if someone knows what they're doing. And I think really the  trait it comes down to is being a technically competent engineer, right? For better or for  worse, that is what it comes down to. I'm going to give you a problem. Can you solve the problem?  There's no way to really beat around the bush with that, right? The ideal scenario is that you  solve the problem. So to me, it's someone who's just very technically competent. And again,  the good news is that you decide those things well before the interview, right? If you've been doing  all your homework, if you've been doing all the problems, if you've been reading up on stuff that  you should know about computers, that's really what determines this. And so I don't like when people  think, oh my gosh, this is a 45-minute interview that feels like I'm playing in the Super Bowl.  That's just not the way to treat it. You know, everything that you do beforehand is what actually  influences what happens during those 45 minutes. And the best news is that you can decide how those  45 minutes are going to go by all the prep that you can choose to do. So it really comes down to  being technically competent. And I don't think that should be a surprise to anyone.  For sure. And I think that's empowering to the people who are technically competent, who feel  like, you know, it's this whole mysterious game where in reality, like you said, it is that prep  that leads up to it. And even you and me that right now, we're not grinding leakcoat questions.  If we do a little bit of prep, we can walk into a tech interview and comfortably pass one  because you are just technically competent, right? And it takes away a lot of the nerves when  you actually have those skills, which yeah, you shouldn't be surprised you need to land, you know,  a $500,000 job at Google, you know, just exaggerate and you get the idea. Now, any common mistakes,  like quite common things that people do that either instantly eliminates them or really just  looks poorly in the interview. To me, what I tend to see is like, A, people are nervous. And so I  think the best way to get over that is by putting yourself in that position as much as possible. So  the best way to do that is by doing other interviews. So part of it is a numbers game, right? You just  have to get the reps in and eventually, if you've done a hundred interviews, you're not going to feel  as nervous as your first interview. There's just no way. And if you somehow still do, okay,  maybe you need to do 200 interviews. That's just the reality of it. So practice how you play, put  yourself in that position where hopefully you're not going to be nervous. You could also do mock  interviews with people, but it doesn't as, you know, closely emulate the real thing. I think the  other thing that I see people that just gets in their own ways that they don't ask clarifying  questions. You have to remember, right? There's a recipe for a reason because if you skip step two  of putting flour in the cake, you're not going to get a cake. It's the same thing with interviews.  If you don't ask clarifying questions, there's no possible way. If you're missing 30% of the information,  any solution you put forward is not guaranteed to work, right? It may fail at certain edge case or  many of the test cases where you might not know that the list of numbers can contain negative  numbers. And now all of a sudden, you're,  solution doesn't work at all.  So a lot of people sort of, you know,  don't do right by themselves  by failing to ask clarifying questions.  So you really need to make sure that you do that.  So get your nerves under control  and definitely make sure that you get all the information  before you try and solve the problem  or propose a solution.  For sure, being just calm, cool,  talking like a normal human being,  I mean, that's only gonna do you, you know,  good things and manages in the interview.  And it's funny because when I've walked into interviews,  I do just treat them like a conversation  and I noticed that there's just so much more relaxing,  actually fun in some cases,  like, you know, it's a good problem.  And you're working with the right person  and you can build rapport.  And it's not this really, you know,  intimidating, aggressive thing.  But obviously it takes a bit of experience  to get to that point.  But that's what the best engineers do, right?  The, you know, expert principle senior engineers,  they don't walk into interviews nervous.  They just walk in, okay,  is this company one I want to work for?  All right, let me demonstrate my skills  and then get the offer, right?  And that's the best people in the industry.  Not easy to do right now at a junior level,  but you can get there and that's what you need to strive for.  That was super helpful, Kevin.  That was a lot of information.  Hopefully everyone watching this  has consumed some of that  and you don't got some valuable data there.  Any last tips, pointers, advice, motivation  you want to share with people before we end the video?  I think just really truly, like, you can do it.  The only thing that stands between you  and getting an offer is like putting in enough reps,  setting it on enough applications  and like sharpening your skills, you know,  getting to the point where you can walk into an interview  and pass.  So don't think it's impossible.  Don't think that because the market's bad,  you can't get a job.  It really comes down to you doing the things  that you need to do to get to that place.  You shouldn't feel like you can or can't get a job  because of extenuating or outside circumstances.  You can absolutely do it.  If I can do it, you can do it.  Anyone can do it.  Just make sure you put in the work  and put in the reps and you can absolutely get there.  It's just a function of time.  Ultimately, it's in your control, right?  And there's a lot of variables that you can control  and while we like to complain about the ones we can't,  I mean, people that get the jobs,  they take it into their own hands.  Now look, Kevin is my business partner inside of DevLaunch.  We started this up about six, seven months ago.  We've been very successful helping developers  like you watching this video, land jobs.  If you already know how to code  and you're struggling with things like getting job  or like getting interview story,  passing those technical interviews  and you wanna work with someone like Kevin,  who has literally given hundreds of interviews  throughout his career, mock and real,  then consider applying for the program.  You can book a call from the link in the description  and I look forward to seeing you there.  Thanks everyone for watching.  See you the next one."
il0dFcWBev0,Did you know about the range function?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags

UAE Media License Number: 3635141",2025-11-29T16:38:34Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/il0dFcWBev0/default.jpg,https://i.ytimg.com/vi/il0dFcWBev0/hqdefault.jpg,PT1M49S,15663,234,4,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"range. So what range will do is generate a range of numbers starting at some value, stopping at some  value, and stepping by some value. Now by default, when you only pass one value here to the range  function, this acts as the stop. That means it's going to go up to, but not include this number,  and it's going to start at one and step by one, which means go up by one each time. So if I run  the code here, you can see that this gives us the values 0 through 9 again, because we go to the  stopping point, but we do not include it. Now, if I have a second value here, something like two,  and then 10, this will act as the start value, and this will act as the stop value, and now when  I run this, you see that we will simply start at two, we will go up to 10, but not include it.  If I decide to add a third value here, something like two, this will act as the step value,  and this will be the increment that we will go up by each time. So if I run this here, we get two,  four, six, eight. Now, this is quite useful, and we can do this in many different kind of ways to  generate a lot of different sequences of numbers. For example, I can change this to a negative two,  and I can swap these values around and go maybe 10, and maybe we're actually going to go to something  like negative 10, and now this will give us a negative range where we start at 10, and we subtract  two each time until we hit the stopping value of negative 10, which we do not include. Very useful  for four loops, but also if you convert this range into a list, then you can simply use it as a  list of values. One thing to note, if you print out range itself, which we can do here,  you'll see that we actually get a range object. That's because range returns to a something known  as an iterator. The point is, if you want to actually get an entire list of values, you do need  to manually convert this to a list. So to do that, we just write the list function around range,  and then as you saw before, it gives us a list of values rather than this range object, which again  is an iterator."
J2fol8eWo64,Data Structures  - Full Course for Beginners,"This course will teach you about Data Structures and how they will apply in real-world scenarios, like computer science courses, preparing for technical interviews, or diving into LeetCode.

DevLaunch is my mentorship program where I work with you directly one on one to help you land a software engineering job, learn more from here: https://training.devlaunch.us/tim?video=J2fol8eWo64

üéû Video Resources üéû
Time Complexity Analysis: https://www.youtube.com/watch?v=6aDHWSNKlVw

‚è≥ Timestamps ‚è≥
00:01:59 | Arrays
00:21:07 | Single Linked List
00:35:07 | Doubly Linked List
00:45:42 | Queue
00:58:11 | Stack
01:08:36 | Binary Trees
01:35:45 | Binary Trees Continued
01:51:53 | Binary Search Trees
02:20:07 | Heaps
02:46:58 | Graphs
03:02:42 | Hashing


Hashtags
#datastructures #arrays #binarytree #heaps #hashing #singlelinkedlist #doublylinkedlist #datastructuresforbeginners #datastructurescourse",2025-11-28T09:33:02Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/J2fol8eWo64/default.jpg,https://i.ytimg.com/vi/J2fol8eWo64/hqdefault.jpg,PT3H11M8S,15732,1092,36,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"This course will teach you data structures. That means you'll learn about arrays, heaps,  stacks, queues, linked lists, binary trees, all of those topics that fall into the data structures  category are covered in this course. And they're covered in a very practical way. I don't get into  every tiny little nuanced detail. I covered the important topics that you need to understand for  real-world use, whether that be passing your computer science course or getting ready for  technical interviews or preparing to dive into something like leak code. That's how this course  was designed, and you'll notice that this is actually 11 smaller videos that are all combined  together for your convenience that came from a prior course of mine that was premium that you  did have to pay money for. That course has since been discontinued, so I'm slowly going to be  releasing some of that content onto YouTube, and this is the first example of that. Now with that  in mind, I know that a lot of you watching this course are doing so because you're preparing for  technical interviews. Maybe you've never learned this topic before or you're getting back into it  because you want to land a new developer job. Now if that's you and you want assistance with this  in a more premium hands-on one-on-one way, consider applying for my dev launch program. You can see  a link to it in the description. In that program, I work one-on-one with developers as well as with  other experienced software engineers to help you land a job in today's difficult market. We have a  large emphasis on interview preparation, including running through mock interviews, giving you  real evaluation and feedback, as well as working with you one-on-one to create a custom plan in  roadmap for what actually makes sense for the highest leverage activities you can do to land a job.  The price of that program will be increasing as soon as Black Friday is over, so if you do want to  join now is the time to get in. Anyways, that's it for this. I hope that you enjoy the video.  Let's get into it. And just one last thing before I forget, in case you are not familiar with  time complexity analysis, I'll put a video right here and link in the description down below  that you can watch to familiarize yourself before we get into the content. Okay, now let's dive in.  Hello everybody and welcome to a new section in this course where we'll be discussing data structures.  Now before we get into this first video where I'm going to talk to you about the array data  structure, I want to give you a quick primer on what data structures are. So really data structures  are a way for us to store, organize and manipulate data. Now data structures are not specific to one  programming language. They can be implemented in many different ways and can exist in really any  language. These are more theoretical concepts and ways that we can go about manipulating our data  that can provide more efficient operations based on what it is that we're trying to do.  So in one program, we may use data structure A because it's faster for that specific use case.  And another program we use data structure B because we have a different set of uses. Now again,  that's going to be very vague and kind of hard to understand right now. But as I start going through  these different data structures, you'll start to see how they can benefit us depending on the type  of code that we're writing. So let me give you a quick kind of overview of the different data  structures that we have. I'll give you kind of a high level explanation and then we'll get into  arrays and then move into some more complicated ones. So first of all, I just want to say that data  structures are not the same thing as data types. Okay. So our data types are kind of like normal  piece of data, like an integer, a Boolean, a string. These are all the data types and these  data types will be different across different programming languages. Data structures are typically  storing those types that you just saw. So we might have an array and that array is storing,  say, a number or storing a string. Okay. So we have data structures. Now our data structures are split  into two categories. We have linear structures and then nonlinear structures. Now I apologize for  the horrible handwriting. You don't really need to see everything that I'm writing here. I'm just  trying to give you some visuals here. So we have linear and nonlinear and these are all kind of  in the data structures category. Now for our linear data structures, we have an array. We have a  linked list and we have a stack as well as a queue. Okay. So these are kind of the four main  linear data structures that we're going to have a look at. Now for our nonlinear data structures,  we have trees. We have graphs. Let's spell that correctly and we have something known as tries.  Now these are a bit more complicated and we're not going to be looking at tries in this course.  Okay. So again, linear. This means we kind of store in a straight line and nonlinear. As it kind  of defines here, we don't store in a straight line. In some instances, it's going to be a lot  better for us to use a nonlinear data structure. In other instances, we want to use a linear structure.  Again, really depends on what we're trying to do. So let's begin this video now by looking at the  array data structure, which is a linear data structure. So obviously, we've already seen arrays.  So a lot of this you're going to know already, but I'm going to talk to you more about the implementation of  arrays and the time complex, the on different operations related  to them. So let's draw out a basic array. So an array is really an ordered collection  of elements. Okay. In our rays, we have different indices. So index 0, 1, 2, and 3. And then  we have some values that we could store inside of our array. Now what I want to talk to you  about here is first of all the different types of arrays that we have. And then what happens  when we do things like add values to our rays, initialize arrays, remove values, etc.  So when we're talking about arrays, we have two different types. We have a fixed sized  array and we have a dynamic sized array. And this really applies to all of our different  data structures. We can have a fixed size or I dynamic size. You can also refer to this  as a static size. Now a fixed sized array or any fixed sized data structure is something  that cannot change its size. That means that we define the size of it when we initialize  or create that structure. And we can't expand that any further. Whereas a dynamically  sized array or structure can increase or decrease its size based on the number of elements  that we have. Now so far in JavaScript, we've seen dynamic arrays. We can push elements,  we can pop elements and we don't have to worry about the space inside of the array. But  in a lot of programming languages, you have both fixed and dynamic arrays and they have  different performance impacts. So we're going to start by talking about a fixed array. So  let me just clear everything on the screen here. So when we have a fixed sized array, we actually  need to decide the number of slots or the size of the array when we initialize it. So we might  create an array of size, let's not do 10 because that's going to be quite large. Let's do a size  four. So if we create an array of size four, then we're going to create four empty slots in memory  in our computer's RAM where we can have different values. Now these values can be initialized  that really anything that we want. But typically, they'll be initialized at something like zero,  or undefined, or null, or false, depending on the type that we're storing inside of our array.  So we have these four different slots. And we have our indices. And now the first thing to talk  about is how long it takes to initialize this array. So when I create a fixed sized array,  this is a big O of N time operation. That's because if I have four elements, which is size of my  array, I need four operations to initialize or allocate each of these individual memory slots.  Now when I talk about memory slots, I'm talking about my computer's RAM, which is where our program  lives. And we'll talk about that more in just a minute. Okay, so it takes big O of N time to  initialize a fixed sized array. Now what about accessing or changing different elements inside of  our array? And that's really the main thing we do, right? Is kind of access them or change the  values? Well, in order to understand how long that takes, we actually need to quickly look at what  happens in our computer's memory when we create an array. So on the right side of my screen,  this will kind of represent RAM, okay? Random access memory, which is where we store all of our  different kind of components of our programs, all the different pieces of data. So when we initialize  an array, what happens is each one of these slots are actually addressed in memory. Now I won't go  through what the address actually looks like, but we'll just do something like 0x1, 0x2, 0x3, and 0x4.  Now that means that in our computer's memory, we have a slot, okay? The slots have an address,  and that address stores a specific value. Those values again are what we have inside of the array.  So we might have the slot here of 0x1 storing the value 0, 0x2 storing the value 0, 0x3, 0, and 0x4  storing 0 as well. Now what happens when I initialize this array is obviously I create these different  slots. I allocate them in memory, and then I store a reference here to this first slot. Now having  the reference to this slot allows me actually to access each of the elements inside of my array  in constant time. Now the reason I can access elements in my array in constant time is because I can  use the index for those elements. So let's say I have slot 0x1, and I know that this is the slot for  my first array element, and I want to access something like index 3. Well, if I want to access  index 3, all I have to do is add 3 to the slot here, because my slots are going to be going  in order, and that's then going to give me the slot of 0x4, and then I can go directly to that  address in memory and find what's inside of it. Now I can either change what's inside of it or  just view it, whatever I want to do there, but I have access to it in constant time. That means  that I don't actually need to go and loop through each of these individual slots to get to a further  slot in my array. It doesn't matter what index I'm accessing. If I have access to where my array  exists inside of memory, I can simply add...  to where that memory address location is,  and then find the next memory address location  for the index I'm trying to access.  I'm not sure if that makes a ton of sense,  but that's why you were able to access elements  inside of your array in constant time,  because you can do essentially an address lookup  to find that.  Now, in case this is a bit confusing,  whenever we're dealing with variables  or any data structures in our program,  what we're doing is we're interacting with memory.  Now, we don't have to do that ourselves,  the computer's doing that on our behalf,  but you should kind of understand  that what's going on behind the scenes  is you're looking for some specific address  in your computer's RAM,  and then you're either writing to that address  where you're reading from that address.  So if we want to access something we need to know the address  and to find the address within array,  we simply add to whatever the first memory address location is,  might work a little bit differently to that,  but this is the general premise,  and then that will give us the next slot,  or the slot that we want to be using,  to access our index, or to access the value  that exists at that index.  So it doesn't matter how large our array is accessing an element,  always happens in big O of one or constant time.  Okay, so that is the basics on index access.  All right, so now that we've had a look at that,  let's see what happens when we try to insert, delete,  append, and pop elements from our array.  Now, I'm just going to remove my computer's memory space here,  because I don't want to confuse any of us.  We kind of know what is happening now behind the scenes,  so we don't need to look at that anymore.  So let's say I want to insert an element here,  in between index one and index two.  Well, first of all, let's just change some of these values here,  so it's a little bit easier to read this.  Okay, so let's just change this like three, four, five, six.  Okay, so I want to insert an element here.  First thing we need to understand is,  since we're using a fixed-sized array,  if we insert an element, we're going to lose access  to some of the other data that we have.  That's because we only have four slots here in memory,  we can't create any more in the fixed size,  so if we want to insert a new element,  we're going to have to remove a different element,  and I'm also going to have to kind of push  or change the indices of other elements  to get this element to go in-sun.  So what I need to do here,  if I want to insert in this position, is the following.  Well, index zero and index one will stay unchanged.  I'm then going to insert my new element.  Let's say my new element is zero,  and that's the element that I wanted to insert, okay?  Then what I need to do is,  I need to essentially push these other elements  or shift them over to the right inside of my array.  So right now, zero is in the position  where index five would have been.  So actually, before I can even put the zero here,  I need to first take this element five,  and I need to put it in the position  where the next element is in my array.  And I actually need to do this from the back of the array  to ensure I don't lose any data.  So what I do here is I first take six,  and I remove this from the array.  That means that I'm pretty much just deleting its value.  So six kind of comes outside here,  and since there's no slot for six,  it essentially gets deleted.  Then I take five, and I move five over to the right.  So now five exists at index three.  Then what I'm doing is inserting the new element here,  which is element zero, in the position where element five was.  Okay, so that means that our new array now looks like this,  three, four, zero, five.  So even though, yeah, you can imagine,  I'm kind of inserting a new element here,  really what I'm doing is changing the elements  that come after where I'm inserting this element,  and that means that this operation here  is gonna take big O of N time.  Now the reason this takes big O of N time  is because we could be inserting at any position in the array.  If we insert at the last position in the array,  this takes constant time,  because we just need to change one element  to be whatever the inserted element is.  However, if we insert at the beginning of the array,  we need to move every single element over to the next box  before we can insert this element inside.  So doing an insertion inside of an array  takes big O of N time.  Okay?  Now the exact same thing applies if we want to do a deletion,  all right?  So let's say we want to delete the first element here  from our array.  So actually, let's change the color here.  Let's say I want to delete this element right here.  Well, if I just remove this element  or I change this to be null or something like that,  then what happens is I now have kind of an empty index here,  and then I have index one, two, and three.  Typically, that's not what I want.  Typically, what I want to happen is to remove this box  and then have this be index zero, this be index one,  and this be index two.  If that's the case, then this operation  is gonna take big O of N time again  because of what I need to do.  So let's kind of write this in here.  So if I want to delete the element here in this box,  first of all, I can kind of clear the element from here,  and then I need to move element four over here.  So I kind of write element four there  and delete it from this box.  Then I need to write element five here.  Then I need to write element-  meant six here, and then this is going to be no, okay, or just like an empty box.  We still have it because we have a fixed size array, so this still exists in our computer's  memory, but we've kind of removed the value that existed inside of it.  So now our array has changed to be four, five, six at index zero, one and two, and that's  what happens when we deleted the first element, okay?  So if we want to do a deletion, again, this is going to be big O of N time.  Now the only time there's an exception to this, let me just clear all of this on the screen  here is when we're deleting or adding elements at the end of our array.  And then additionally, if I want to delete an element, I can just remove it from the end  and that will happen in constant time because there's no changes that I need to make to  the other elements, okay?  So hopefully that makes a bit of sense, but this is kind of what occurs here when we're  talking about fixed sized arrays.  Now though, let's quickly move on to dynamic sized arrays because we do have the ability  to change the sizes of our arrays.  Now just like a fixed size array, we're going to need to initialize this dynamically size  array.  We can have zero elements, one element, two elements, et cetera, doesn't really matter.  What I want to talk about now is what happens when we want to resize this array.  So this is going to be dependent on the programming language and how this array is implemented,  but I just want to give you a bit of insight into how we actually do this because essentially  we're always using a fixed sized array, but when we're implementing a dynamic sized  array, we just create a new fixed sized array of a different size, okay?  There's all kinds of different approaches to doing this, but let's imagine the scenario  where we have an array of size four.  Now, let's say I actually want to add a new element to the end here.  So I don't want to just like kind of swap out what's here at the end.  I actually want to add a new box or a new slot here and push the element inside just  like we might do inside of JavaScript.  Now again, this depends on the implementation strategy that's being used.  But if this is the case, in the naive approach, what we'd need to do is the following.  We'd actually need to initialize a new array of size five.  So we're creating a brand new fixed sized array of size five.  And then we're essentially copying all of the values from the original array inside  of here and then adding the new value at the end, meaning if we want to add another  element here to a dynamically sized array, this array needs to be resized, which means  this is a big O of N time operation, okay?  However, that's not always the best way that we can resize the dynamically sized array.  For example, we can set the original size to be larger than we needed to be, or when  we need to increase the size of the array, we can increase it by more than one slot.  So let's say that we get rid of kind of all the stuff that we've done here.  And now we use a different approach.  So now, again, we have this kind of fixed sized array of size four.  And we want to add another element to it.  So we want this to act like a dynamic array.  This time, when we resize the array, rather than just adding four slots, we actually double  the size of the array.  Now, this is a pretty common approach.  So I think I got enough boxes there, maybe a missing one, okay, let's add one more.  Anyways, what we'll do now is we'll essentially double the size to be the size of eight.  And now we'll have three, four, five, six, seven, and then we have three empty slots.  So if I do three more insertion operations here, I don't need to resize the array for those  additional three operations.  I also could quadruple the size of it.  I could do it by a fixed size every single time.  It's up to me how I want to resize the array, but I'm just trying to show you that sometimes  when you're using a dynamically sized array, depending on the programming language you're  working in, what will actually happen is in the back end, kind of in the memory, you're  going to be allocating more spaces and copying values into a brand new version of the array.  Again, really depends on the way that this implemented in some programming languages.  This is not how it works, but sometimes this is how it works.  Okay.  So you're actually going to be making a brand new fixed sized array, but you're just  increasing the size of that array, which then means you need to copy all of the values  from the original array into the new array and then add the new value and then dispose  of the old array.  Okay.  So that is kind of dynamic and fixed sized arrays.  All right.  So let's get to start to wrap up this video.  Now what I want to do is just move to one more slide here where I just quickly go through  kind of a summary of some of the main operations that we had.  So we have the initialization operation.  When we're initializing a fixed or dynamic size array, this takes big O of n time.  When we're inserting into a dynamic or fixed size array, if this is at any position other  than the end, then this is going to be a big O of n time operation.  That's because we could be inserting at any single point, the closer to the beginning  of the array that we insert, the longer this is going to take because of the number of  elements that we need to shift when we do this insertion.  Same thing applies with the deletion.  If we were deleting say the first element in the array that we need to shift all of the  other elements, uh...  of in the array to take up that space that was then deleted from the beginning of the array.  Okay, doing index access, we know this happens in constant time,  appending, this means adding to the end of an array. Typically, we can do this in constant time.  Now, again, this depends on how the array is being implemented. In the previous example,  with that dynamically sized array, I showed you that sometimes when you do an append operation,  it will actually take big O of n time. But a lot of programming languages have optimized this  such that you can pretty much guarantee it's going to happen in constant time. We won't talk  about exactly how that implementation is done. But typically, you can assume that when you're  appending to the end of the array, it's constant time. Again, the example I showed you before  was just to illustrate why you need to think about computer science principles and data structures.  Popping, this means removing from the end of the array. Again, same thing here. This is going to be  a constant time operation. That's because you simply need to delete whatever is at the end of the  array. There's no, um, what do you call it, uh, kind of shifting that needs to occur when you are  popping at the end. You can just remove that element. It doesn't require the length of the input  operations to perform them. Hello, everybody. And welcome to the next video in this section. We'll  be talking to you about something known as a singly linked list. Now, a linked list is an  additional linear data structure that works a little bit different than an array. On the surface,  it may seem like the same, but its implementation is a different and allows us to have some  faster time complexity. We have essentially different slots in memory, just like our array,  that are linked together with something known as a pointer, okay? So let's say we're using numbers  here. And these are the elements in our list. Now, we have what's referred to as the head of the list.  The head of the list is what we're actually going to store. We're going to have some var,  call it x, and this is going to have a reference to the head of the linked list. Now, when we have a  reference to the head of the linked list, that allows us to access the different values in the  linked list by moving through the pointers that exist here. Also, I just realized I kind of wrote  this a little bit strange. Let's just get rid of that variable. Okay. So what's happening here?  Well, we have what are referred to as nodes in our list. Now, every single node in our linked list  has the following property. It has a value and it has a next property. Now, the next property is  actually a reference to the next node that exists inside of the list. Now, every single one of these  nodes is going to have a memory address location, right? Might be location 1, location 2, 3, 4,  doesn't really matter what it is. This next property will store the next location to the node that  comes next in the list. Okay. So that's the basics on a linked list. We have nodes. Those nodes  have a value and they have what's known as a next pointer or a next reference. When we actually  create the linked list, we store the head of the linked list and then the head of that linked list  allows us to access all of the different values. So now, let's talk about a few operations  on our linked list. So with this structure, let's say that I want to access the last element inside  of the linked list. Well, to do that, I need to traverse through all of the different nodes  that exist inside of this list. And in fact, we can actually write some pseudo code that would allow  us to do that. So we have access to the head. Remember that all of our nodes have the value  and they have the next node. So let's say that we want to access the fourth element. Okay. Well,  to do that, we can create a variable and we can say current is equal to head. Now, this is not  going to be valid code. This is not going to work if you type it in your JavaScript console.  I'm just writing what's known as pseudo code, which is just something that we can quickly kind of  look at to see how we would go about writing the code. I'm going to say, wow, current dot next  does not equal no. And that's because the next property of our last node is going to be equal to  no, because it doesn't point to any other node. Okay. So we say, well, current dot next does not  equal no. Then what we're going to do is say current is equal to current dot next. And then  when we get to the point that this is equal to no, we know that we're on the last node. So we can do  something like print current dot value. Okay. So if we read through this code, I know it's a little  bit messy. Essentially, what we're doing here is we're creating some variable. This is storing the  head of our linked list. Now, we want to traverse through the entire linked list. So to be able to do  that, we need to constantly access the next property of our notes. So we come here to our while loop  and we say, well, current dot next is not equal. No, we're going to say current is equal to current  dot next. So that means I'm looking now at my head and I grab the next property.  points here to four. So now, current becomes equal to this node, and then I repeat the process.  I say, is current on x equal to no? No, it's not. So we continue. Okay. So now I say current is  equal to current dot next. And I keep moving through this until I get to the point where this points  to no, and then I know that I'm at the very last value. And then I can go ahead and print what  that value is. Okay. So that was meant to just illustrate to you how you would traverse through  a single linked list. Okay. Hopefully that makes sense. But that's kind of the implementation.  Right. So if we're actually going to build this in JavaScript, we'd probably create some kind  of class. In fact, we'd need two classes. We need one class, which is a node class, and another  class, which is the linked list class, the linked list class would be keeping track of the head.  And then we want to traverse or access any of the different indices here. We'd essentially do  this process up to the index that we want to access. So if we wanted to access index three,  we just do this one last time. Right. So we can just keep track of how many times we've accessed  and then move to that next index. All right. So let me just get rid of all that. We'll move on to  the next operations. All right. So now that we've looked at the traversal, let's talk about what  happens if we want to add or remove an element from the linked list. So let's say we actually want to  add another node here at the end of the linked list, pretty common thing that we'd probably want to do.  Well, in order to do that, we would actually need to access the last element inside of our linked  list and then create the link to that new elements. Right. So we'd have to go through that whole  traversal process that I just showed you access the tail of the linked list. And then we'd have to  write something like the following tail dot next is equal to whatever the new node is. Okay. So we'd  pass that new node that node would have its value and its next property would be equal to no. Okay.  And then again, if we wanted to add another node, we'd have to then access this new node that we  added, change its next property to be that new node. And then we'd set the value and the next  property on that new node. Hopefully that makes a little bit of sense, but we have this kind of node  object. The node again has the value in the next property. And for us to link these elements together,  we have to set those next properties. So if I want to add this new element, I need to set  the next here to be equal to that. That's how you do an insertion. So what that means is that  if we're inserting with this type of singly linked list, we're going to have a big O of N time  complexity to be able to do that. Now in just a minute, I'm going to show you how we can reduce that  to big O of one. But for now, with this kind of naively implemented singly linked list, it takes  big O of N time. Now the same thing applies if we want to do a deletion. So let's say I want to delete  this node right here. Well, if I want to delete this node, what I need to do is I need to change  the next property of this node to be equal to this node. So that means I need to do the traversal  that I showed you. I need to locate this node. Then I need to go to this node. I need to get the  node that it points to and then I need to change this next property to point to this next property.  Okay. So I'm going to write again some very basic pseudo code that would do this. I'm going to skip  the traversal and just assume that we have the node that we want to delete. Okay. So let's just  call this N or let's call this node. Okay. So this is the node that we want to delete. So I need to first  do something like next node is equal to node dot next. Okay. So I'm storing the node that this  is pointing to just to make sure that I don't lose it. Then I need to get the previous node. So I  also would need to store the previous nodes. I'm going to say previous like that. So I'd have to  have access to both of those. And then I would say previous dot next is equal to the next node.  Now I also could have just written node dot next. It doesn't really matter how I do that.  Regardless, I have to set the previous nodes next to be equal to the next node after the node that  I want to delete. Now this means that this again is going to be a big of N time complex the operation  because I need to locate both the previous node and the node that I want to delete. And if that's  near the end of my linked list, that could take up to N, which is the size of my linked list operations.  Now if it's the very first node, then it's quite simple, right? If it's the head node, in fact,  there's actually no previous node. So if that's the case, then what I do is I simply set my head node  to be equal to the next node in my single linked list. Hopefully this is making a bit of sense.  I'm just trying to show you all of these different operations on how you would actually go about  implementing this. All right, so let's delete that. We've now talked about insertion and deletion,  which right now are both taking big O of N time. We also know that accessing is taking big O of N time.  So you might be asking yourself, well, what's the point of using a single linked list? Well,  things get a little bit more interesting when we implement a circular linked list.  Okay, so now what I've done is I've simply changed this so  the last node inside of my single linked list is now going to have a pointer or a reference to  the head node of my linked list making this linked list a circle allowing me to go through it  circularly. Now this will change a few of the implementation kind of pieces of code that I've  talked about to you thus far. However, this provides a distinct advantage. Now the reason we have an  advantage here is because now rather than storing the head node, we can store the tail node.  So now if I store the tail node, this gives me access to the last element inside of my linked list  as well as the first element in my linked list in constant time. That means that if I want to remove  the last element from the list, I can do that instantly or if I want to remove the first  element from the list, I can do that instantly as well. So that's where the real advantage of  a single linked list comes in. If I want to remove an element from the beginning of the list  or the end of the list or I want to add an element at the beginning or add an element at the end,  when I create this circular structure, I can do both of those operations in constant time.  Now remember, that's different than an array. When I have an array, if I want to do operations  at the beginning of the array here, this is going to take big O of n time because I need to shift  all of the other elements over. When I create this circularly linked list, I no longer need to do that.  Now in case you're confused on why this happens in constant time, it's because now if I store a  reference to my tail and I want to add an element, I can simply do the following. I can say  tail dot next is equal to some new node. And then I just need to make sure that this new node  has the next property, which is equal to whatever the tail dot next was equal to before.  Right? Equal to tail dot next. Now I'm not really writing this in kind of the correct order.  So essentially what we do is we would create this node. We'd give it its value. We'd first set  this new node to have the next property equal to whatever the current next property of the tail is,  which is the head of the linked list. And then we now set the tails next property to be equal to  this new node. And now we've inserted an element at the end of the linked list in constant time.  Now pretty much the same thing applies if we want to do this at the front of the linked list.  So if I want to do this at the front, it's going to be a very similar type of operation.  I'm going to create a new node here, right? So something like that. I'm going to set this new  node's next property to be equal to whatever the tail dot next property is. Okay? Then I'm going  to take this pointer from my tail. And I'm simply going to change that to be equal to my new node.  Now I've just added an element at the front of my single linked list in constant time. So when we  add this circular property again, we get this constant time insertion and deletion at the beginning  and the end of our linked list. Now if we're doing it in the middle, again, that's going to be a  big old end time operation because we still need to traverse through the list. But still,  this is a huge advantage now because we can insert and delete at the front and the back of the  linked list, which we can't do in constant time in the array. Okay. So I think with that said,  I'm going to start wrapping up the video here. Let's just do a quick summary. Whenever we're using  a linked list, we have some kind of node. Okay? This node has a value and a next pointer.  The next pointer points to the next node. If you're wondering how this would be implemented in  JavaScript, you could literally do it using objects, right? Where the object has the value,  and then you have the next pointer that just is equal to whatever the next node is. Okay?  Anyways, beyond that, we then have the ability with this linked list when we use this circular  structure here to insert and delete elements in constant time at the beginning and the front of  the linked list. However, if we want to access something within the linked list, that's going to take  us big O of n time because we need to traverse through the linked list to find that element. And  if we want to insert or delete something in the middle of the linked list or not at the beginning  or the end, again, that's a big O of n time operation. So the disadvantage compared to an array is  the index access, right? It's going to be harder for us to access an element that's in the middle  of the structure. But if we want to do operations on the front and the back of the structure,  so the head or the tail of the structure, it's going to be much faster for us to do that.  Now, in terms of code implementations, you can most likely problem solve and figure out most of  them just by using what I've showed you in this video. So if you want to challenge yourself,  what you can attempt to do is actually build a version of a linked list in JavaScript.  What you need to do if you're going to build that is implement the different operations,  like insert front, insert back, delete front, delete back, and then traverse or locate a specific  element. You can be as creative as you want here. You can also look up some references online.  I'm not going to ask you to implement linked lists or most data structures in this course.  The idea is just to understand how they work and to get the theory behind them. And again,  Once you understand that, it actually becomes fairly trivial to write the code to implement them.  The important part is the theory, which you now have.  Hello, everybody, and welcome to the next video in this section,  while we'll be talking to you about a doubly linked list or a double linked list.  Now, this is the exact same thing as a single linked list, except you have a reverse pointer.  So we have something like seven, I don't know, go with like three and two.  Now, on this linked list, we have a pointer that goes to the next node,  as well as a pointer that goes to the previous node,  and we can implement a circle here as well, okay?  So we can actually have a double circular linked list like this  because the previous pointer of this node would go to this one,  and then the next pointer of this node would go to this one.  Now, traversing this list is going to happen pretty much,  identically to how we traverse a single linked list,  except we can traverse in both directions.  Since we now have a previous pointer, we can go backwards,  or we can go forwards, which actually provides a lot of advantages and specific scenarios.  So let's just quickly go through this, we have our node, okay?  Our node is now the exact same as the other one, except we have the next,  and we have the previous pointer, typically it's abbreviated by PREV, P-R-E-V, okay?  So every single time we create a node, not only are we initializing  the pointer that goes forward, but we are initializing the pointer  that goes backwards to the previous node.  The main advantage here is that if we access a specific node,  so let's say I traverse and I find node 3,  now what I can do with this node is I can traverse backwards  and find the nodes that exist before it.  That means that now once I find this element,  I can find all of its neighboring elements quite quickly  compared to with a single linked list  where I would have to actually traverse the list again  to be able to find the previous element.  So before we go to crazy, let me just clean up this example a little bit  and let's look at some implementation details related to the doubly linked list.  All right, so with the doubly linked list here, first of all,  it doesn't matter if we store the head or the tail node.  The reason for that is we have access to the head and the tail node  from both the head and the tail, right?  So from my tail, I can access my head and from my head,  I can access my tail in constant time.  So it's up to you what you want to store,  typically you'll store the head,  doesn't really matter which one you store.  Now let's talk about what happens if we wanted to add an element  into a doubly linked list.  Now just like a single linked list,  this is going to happen in constant time if we're doing this at the front  or we're doing this at the back of the linked list.  However, it just becomes a little bit more complicated  because there's more references that we need to change.  So let's say we want to add in this new green element here with value four  and want to put this actually at the beginning of our linked list.  Well, what we need to do is the following.  We need to update both the next node from the tail  and the previous node from the head to be equal to this node.  But the order in which we do that is important  to ensure we don't lose access to either the head or the tail node.  So for this to work, a few things need to happen.  First of all, this node needs to set its pointers correctly.  So it needs to set its next pointer.  So this is next to be equal to the head.  And it needs to set its previous pointer here to be equal to the tail.  Okay, so that's easy.  We can do that.  Now, how do we do that though?  If we have access to the head node,  I'm going to kind of write some code to do this, okay?  So this will be our new node, all right?  And we have access to the head.  So those are kind of the two variables,  ignore that we have the tail here.  All right.  So what we're going to write is the following,  we're going to say node dot next is equal to the head.  And then node dot previous is equal to the head dot previous,  right, which is going to be equal to the tail.  Okay.  So that's what we do.  Then now that we've done that,  we need to update the references on the head and on the tail.  So we do the following.  We say that the head dot previous dot next is equal to the node.  Now, that's because we're getting the head from the head.  We're going to previous, which is getting the tail.  And then we're taking the tail and we're now setting this next pointer  to no longer be equal to the head,  but to be equal to this new node.  I know it's a little bit confusing how I'm drawing it,  but essentially we're deleting this.  Okay.  And now we're setting the next property for the tail node to be equal to this new node.  Okay.  Now that we've done that,  we need to change the previous property for our head to be equal to the new node.  So we go head dot previous.  is equal to the node, apologize for my atrocious handwriting here, let's clear that,  and let's go here and set that. Now that we've done this, this is fine,  although at this point we would have also had these references here, okay? And then we're going to set  head to be equal to node, right? Because we're putting this at the front, so we're going to take our head  and we'll now write this here. So now our new head becomes this node after we've ridden  these five lines of code. So it is substantially more complicated to do this when you're using  a doubly linked list, but hopefully this kind of pseudocode example gave you a good concept  of how you would go about actually doing this. You need to update two different pointers,  so the tail pointer and the previous head pointer, and then you need to set the pointers  on the actual node, and then you need to update the head to be equal to the new head. If you're  doing it on the tail, you're going to do the same thing, except you won't need to set a new head  node because you'll already be updating the references and just adding in the tail. Okay, so that is  the basics on the doubly linked list. Again, let's just go through the time complexity and some of  the operations to make sure we're clear, and then I'll try to illustrate kind of more in depth  why you would actually want to use this. Okay, so just to recap here, if you want to do an insertion  or deletion at the front or the back of the linked list, that happens in big O1 or constant time.  If you want to traverse the list and find any given node, of course, that's going to take big O of  n time. If you want to do an insertion or deletion in the middle of the linked list, so we want  to delete this node, that would be big O of n time. However, this changes if you already have a  reference to the node that you want to be inserting a deleting after. So let's say for some reason,  I have this node, like I have it stored in my program. Okay, if I have that, then I can either  delete any node before it or after it or add any node before it or after it in constant time,  because I have a reference to the previous node as well as the next node. So let's say I want to  insert a node before this node with a singly linked list that would still take me big O of n time  because I would need to traverse the list and find the node that came before this node.  But since I have access to the previous node, I can actually do this insertion in constant time.  So that's one advantage here. So if I'm going to do that insertion, the one I need to do is change  my pointers, right? Now I won't actually go through the process, but essentially one's going to go  here, right? This new node will point here, this previous node needs to point here, and then this  node needs to point back to that node. If I do that, then I've done the insertion and deletion.  So it's going to be about four changes that we need to make there or four kind of operations to  insert or delete, but still we consider that constant time. Now, the main advantage of using this  doubly linked list is exactly what I just showed you there. It's the ability when we have a certain  node to insert a delete after that node in constant time or to access what comes before it's right.  So imagine that this doubly linked list here was actually implementing something like a music player  where each of these different elements we have here were songs that we just played.  Now that allows us to go backwards and forwards in our structure very quickly, right? We can  fast forward and we can reverse because from this given song we have access to previous node  and we know what the next node is. Then let's say we want to add an element into our queue.  Well, if I want to do that and maybe I want to make it the next song, then all I do is insert it  right after the current element. Or if I wanted to maybe add something behind this, I don't know why  for some reason I'd want to do that in a music player, but let's say I wanted to do that,  then I could, right? I could add it behind this previous to this element.  Hopefully this is making a little bit of sense, but that's kind of the advantage of using  the doubly linked list is the flexibility that you get here with having these previous pointers  and also the ability to kind of traverse backwards as many times as you need to.  Again, if we use the singly linked list, then we would have to actually re traverse this entire  list to find the previous element from any given node that we are on. Now the disadvantage of  using this type of linked list is that obviously it's more complicated, right? You can see here,  we want to do any type of update or delete operations. It requires more steps from us in terms of  the references and the changes that we need to make. Also, this is going to end up using more space,  right? The reason that's going to use more space is because now we're adding this additional  previous pointer and that previous pointer is going to make it more challenging, not more challenging,  but just more kind of space consuming for us because we have one more piece of data that we need  to store. Now before I wrap up the video here, I'll just mention that it's a good exercise to kind  of try to write the pseudo code that I was just writing to do the insertion and deletion operations.  If I wrote all of that code we'd be here for years, so I'm not going to bore you to death by doing  all of that, but try to see, okay, if I have access to this node here, how would I add a new node?  What would I need to do? Well, you need to make the new node.  And they need to update the references, but the order in which you update the references  is important to make sure you don't lose access to the other piece of data.  For example, if first I change my reference here and I say, okay, I'm going to point that  to this. Now, all of a sudden, I don't have a reference to this node from this node here,  which means I need to first change the reference from the previous node to be equal to this.  And then, after I've done that, since I still have access to this,  then and only then do I change this reference here, right? And then obviously these ones  are needing to be pointed to the correct areas as well. Hopefully that makes a bit of sense,  but something that you can try out on your own if you want to go through some kind of practice  examples here. Hello, everybody, and welcome to the next video in this section,  where I will be talking to you about a queue. Now, a queue is an additional linear data structure,  which allows us constant time operations to access and remove elements from the front and the back  of the queue. The purpose of our queue is to process elements in the order in which they are  received. The main property you need to remember when we are talking about queues is something known  as FIFO. This is first in first out, okay? So whenever you think of queues, just remember this  acronym FIFO first in first out. That means the first element we add into our queue is the first  element that comes out of the queue. Now, we see queues everywhere. The most basic example of a queue  story is a line. So if you're waiting in a line to do something, get some item, whatever it may be,  you are in a queue. If you were the first person to enter the line, you're the first person to get  the item that you're looking to receive. If you were the last person to enter the line, then  you're going to be the last person to get whatever item it is, okay? So that is the basic property  of a queue. Now, if we draw out a queue here, we always have a front and a back of our queue.  Now, when we're implementing the queue, we need to make sure all the elements get inserted in the  back of the queue and then they come out of the front of the queue, okay? So just like back of the  line, front of the line. Now, you can actually insert elements from the front and remove them from  the back. If you want it to do that, it doesn't really matter. You just have to make sure you do  it in the same order every time you do the operation. So in our case, we're going to always insert  from the back and we're going to always remove from the front. So that means someone new comes into  our line, they go to the back and then they will move throughout the queue to the front as elements  get processed. Now, a basic example of when you might use a queue is to process different requests.  So let's say you have a bunch of people that are trying to access a website. Well, on that website,  there's some different operations that are being performed and your server, you have like kind of  a backend computer that's running this website needs to handle all of those different requests.  So you would put all of those requests inside of a queue, you would pop them off of the queue,  and then you would start actually processing the elements one by one, going through the queue in  the order in which the elements were received. There's other ways you could go about doing that,  but this is kind of a basic example of a queue. You're also going to have a queue for something like  a music player, right? We have different songs that you're going to be processing and playing for  the user. Now, when we have a queue, we have some different operations that we can perform.  So we have the ability to put or to on queue and elements, okay? That means we're going to be adding  an element to the back of the queue and we want this operation to happen in constant time. Now,  the way we implement the queue will determine how fast this operation actually is, and we're going  to talk about that in a second, okay? Then we have a pop or a DQ operation. I know I'm kind of  butchering the spelling here, but you get the point. Again, we want this to happen in constant time.  This means that we are removing the first element and returning it from the front of our queue.  So this is essentially trying to grab this element so that we can process it. Then we want to have  the operation which is seek, sorry, not seek peak, although seek kind of work as well,  or front. Now, what this is aiming to do is tell you what the top element or the front element  of the queue is. So the element that would be popped or de-cued if you call that operation,  okay? Now, again, we want that to happen in constant time, and then typically we have some kind  of method like is empty, which will tell you if the queue is empty. And again, we want that to run  in constant time, okay? So this is the basics of the queue. You insert elements from the back,  you remove elements from the front. These are the four operations that you typically need to  implement when you are writing a queue, the put or the on queue, the pop or the DQ, the peak or  the front. And then this is empty. And sometimes you can have an is full operation as well. We don't  need to talk about that right now. Okay, so now that we've seen this queue, I want to show you how  we would implement this. Now, before I do that, I want to quickly explain to you that all of these  data structures that we're looking at are used to solve different problems, right? So what I just  explained to you, where we have the music player or we had the queue of requests or we have some kind  of line, that's when we would use a queue. Then we have these different operations that we expect  to be implemented on a queue. Someone else could build the queue for us and we could use that  or we can build the queue ourselves. When we're building the queue, we want to make  sure the different operations have these time complexities.  OK, so the property of a queue is that the put operation has time  complexity of constant time, pop operation has time complexity of  constant time, et cetera, that's the value in using this data  structure. However, for all of these data structures, as I've  been describing, we need to actually build them, right?  We need to implement them. We need to write the code that allows  this queue to function. And based on how we write that code, we  could have different time complex these for these operations.  So I'm going to start right now by showing you what would  happen if we tried to implement a queue that uses an array in  the back end, because even though we have these different  operations, some data structures, some other data structures  can be storing all of the elements inside of our queue. So if  we're going to be building the queue ourselves, we have to be  careful what data structure we use to build this data  structure. So you're going to end up seeing that quite a bit  that one data structure kind of lends itself to another data  structure, and we can use multiple data structures to implement  other data structures. Hopefully this is making a bit of sense,  but these are the properties of the queue. Now, let's have a look  at how we implement the queue using an array. So if we use an  array, this is not going to be optimal, but I just want to show  you what would happen. So let's say we have an array here, okay?  And we can make this maybe size five doesn't really matter,  don't concern yourself, but the size right now. Remember that if  we want to add an element to the end of our array, that's going  to be a constant time operation, okay? If we want to remove an  element from the end of the array, again, that's going to be a  constant time operation. That's what we're going to assume as we  kind of go through this. However, if I want to remove an element  from the beginning of my array, sorry, this is not constant  time, this is a big O of N time operation. The reason for that  is I then need to shift all of the other elements in my array  over to fill the empty space that I've now kind of created when I  remove that element, okay? Same thing if I want to insert an  element at the beginning of the array, if I do that, that I would  need to shift all of the other elements in the other direction in  the array. So kind of remember that because that's important when  it comes to this queue. Okay, so we're creating this array, and  this array we're going to use for our queue. And that means we  need to define a front and we need to define a back. Now we can  define these in any order that we want. But for now, I can make  the front of my array, the front of my queue. And the back of  the array, the back of my queue, that means I insert elements at  the back or the end, I remove elements from the front or the  beginning. Okay, so let's go through sample where we insert a  few elements into the queue. So let's say we want to insert  three, four, seven, two, and one, okay, want to insert it in  this order. So we're going to put these elements into the queue  or push these elements into the queue, you can refer to that as  whatever you want. Or on queue these elements, again, there's a  whole bunch of names we can use for the operations. Okay, so if  we're doing that, we're going to be inserting at the back,  inserting at the back happens in constant time. So we'll start  with three, then we'll have four, then we'll have seven, then  we'll have two, and then we'll have one, all of that happened  in constant time. Okay, so we've now placed all these elements  onto the queue. Now what we want to do is de queue them or pop  them off. So if I want to pop an element, I'm going to be  removing from the front of my queue. Now since my queue is an  array, that means that if I grab my element three here, I need  to now shift all of the other elements over one position in my  array, which makes this a big O of N or linear time operation.  Okay, so that means that this queue has a big O of one time  complexity for pushing or on queueing, but it has a linear time  complexity for popping or removing. So this is non ideal  implementation of the queue. Now what happens is if we decide  to switch the front and the back here, we're actually just  going to reverse these time complexities. So if I make the  front of my array, the back of the queue and the back of the  array, the front of my queue, then that means that now we're  just going to switch these. So we're going to have a big O of N  push operation and a big O of one pop operation. Okay, because  now I'm going to be pushing to the front, meaning I have to  shift elements the other direction in my array, and then I'm  going to be popping from the end, which will happen in constant  time. So an array is not ideal. So before I go any further, ask  yourself, what data structure could we use that would allow us to  have a big O of one time operation for both popping and pushing?  Give yourself a second here, pause the video if you need to, I'm  about to reveal the answer to you, which is a linked list.  Okay, now we can use both a singly or doubly linked list. In  this case, it's totally fine to use a singly linked list. So if I  want to implement a queue that has those type of time complex  the operations, I use my linked list. The reason for that is the  following, if I draw out a linked list, let's say we have three  elements inside of here are three nodes. Okay, and we have this  percular structure, remember that we always store our tail, okay?  So now I've created this linked list  and let's decide where the front and back of my queue  are going to be.  So we can say the front of my queue  is going to be at the front of the linked list  or the head of the linked list and the back of the queue  is going to be at the tail or the back of the linked list.  So now what happens if I want to insert a node  or an element on my queue?  Will I need to push that or on queue that at the back?  Now since I have access to this tail pointer here,  all I do is I write that code, right, which is tail.next  is equal to my new node and my new node.  So node.next would have been equal to whatever the tail.next once, okay?  By doing that, I essentially add a new node here.  This kind of gets removed, I'm not going to erase that.  And then this node now points that new front, okay?  I know this is really messy, but you get the idea.  We've already looked at how we do an insertion  at the back of a linked list.  So doing that happens in constant time, right?  So that's the advantage here of using the singly linked list.  Now what happens if we want to remove an element  from the front of our queue?  So we want to de-cue it or pop it.  If I want to do that, then all I need to do  is remove the reference to this front element here  and change the tail's next pointer  to go to the next element in the queue, right?  So what I do is I say that my tail.next is equal to the tail.next.next, right?  Because I say tail.next, which is this,  and then tail.next.next is this.  So if I simply change my reference here to go to this,  then this front node will be deleted.  And of course, we can return that front node  so that it can be processed.  So that again happens in constant time.  So using the singly linked list allows us  to have constant time operations for both removing from the front  and adding from the back, which means this  is the implementation we would go with when we are building the queue.  OK, so with that said, I'm going to start wrapping up the video here.  I just want to do a quick recap for you  and kind of make sure you understand  the most important parts of a queue.  We use a queue when we want to process elements in the order  in which they are received.  We don't care about the elements in the middle of the queue.  We only care about what element is next for us  to have a look at.  If that's the case, then we can use something  like a linked list to implement our queue  because it gives us constant time operations  for adding at the back and removing at the front.  That's really the main important part here  is that we can push and pop in constant time.  When we're thinking of a queue, we always  want to remember the FIFO property, which is first in first out.  Let's just go over here quickly and have  a look at kind of the cheat sheet for the operations.  So I know where to know these, but pushing our on-cueing is O of 1.  Popping or de-cueing is O of 1.  Peaking or looking at the front is O of 1.  And checking if the queue is empty should be O of 1 as well.  We haven't talked about exactly how that works,  but if we used this singly length list example,  then we could just check if the tail node was equal to none.  And if the tail node is none, that means we  have no elements inside of our queue.  Hello, everybody, and welcome to the next video  in this section, while we'll be discussing  the stack data structure.  Now, the stack data structure is another linear structure  that is similar to the queue.  However, we are going to add and remove  elements from the same side.  So with a queue, we had this FIFO property, which is first in first out.  However, with the stack, we have the opposite,  which is first in last out or last in first out.  That means the most recently added element of the stack  will be the first element that we remove.  So that would be like the first person to enter the line  is actually the last person to get the thing.  So the most recent person to enter the line  is the one who gets processed first.  Let me show you a quick example here.  It's easy to visualize this.  So a stack is named appropriately because we have things  like stacks of plates.  So if you have a bunch of stacks of plates  or you have a stack of plate in your kitchen,  the plate that you most recently put on the top of the stack  will be the first one that you take off, right?  After you take that one off the stack,  then you can remove the next one, et cetera.  And the first plate that you put down, sorry,  it will be the last plate that you take off of that stack.  So hopefully that makes a bit of sense,  but that is the basic properties of a stack.  Okay, so let's just draw one out here  and let's go through the different operations  and their time complexity.  So when we have a stack, again, we're gonna have a front  and a back, so we'll call this the back and this the front.  It doesn't matter the direction that we do these operations  on as long as we do them on the same side.  What I mean by that is if we add elements to the front  of the stack, we need to remove elements from the front  and if we add elements to the back of the stack,  we need to remove them from the back, okay?  So you can pick either the front or the back,  it doesn't really matter what sign.  So let's say we want to add a few elements to the stack.  Well, we can add the element like two, three, four.  So I'm kind of adding them here and stacking them upwards.  This was the...  first element that I added onto the stack,  it will be the last one to be removed.  Now, if I want to remove elements from the stack,  then I remove them in the order in which they were added,  okay, so remove the top element first.  All right, so what are the names of these operations?  Well, the first operation is known as put or push, okay.  This is essentially stacking elements  or adding them on top.  We want this to happen in constant time.  We then have pop or get, okay.  Now, this is going to be, again,  another constant time operation.  There's some other names we might use for these,  so don't worry about it too much.  Essentially, it's adding or removing from the stack, okay.  Then we want to have, again,  that peak or front operation,  telling us what's currently on the top of the stack,  and that will be a constant time operation.  And then generally, we want to see if the stack is empty.  And again, we want that to be a constant time operation.  So really, the exact same as the queue,  except we're doing all of the operations  from either the front or the back.  So now let's quickly look at the implementation of a stack  and then we can go through an example or two.  Okay, so for the implementation of a stack,  we can use a bunch of different data structures,  but we actually can use an array here.  Now, the reason why we can use an array  is because we're doing operations  at the same side of the array.  So if we say that the back of our stack is here  and the front of our stack is here,  and we add elements from the front of the stack,  then that means that our pop and push operations  will all happen in constant time.  Because whenever we're operating at the end of the array,  we can do constant time operations.  So if I want to push onto the stack, that's constant time.  And if I want to pop off of the stack,  again, that's gonna be constant time as well,  allowing us to use this array.  Now, of course, we could use a singly linked  or doubly linked list,  but it's unnecessary for the implementation of a stack.  So just having a simple array kind of allows you  to build this stack data structure.  Okay, so now let's see why we would use a stack.  Well, a stack can actually be useful for something  like navigating in a web browser.  So imagine we have a web browser here,  and on the web browser, we have the back arrow, right?  So let's kind of just do an arrow here.  So what happens is I'm gonna be going to different pages  in my web browser.  So let's create a stack here.  All right, so for the stack,  we're gonna add different web pages onto here  as we navigate to them.  So it's possible, maybe we have some button  on our web page that brings us to something like page A.  Well, if I press this button,  then what I'm gonna do is add the current page  onto my stack, okay?  So I'm gonna push this onto the stack.  Let's just call this something like page one.  All right, we'll kind of label our pages here.  And then I navigate now to page,  really we should have called this something like page two, okay?  So now we're on page two.  Maybe page two allows us to go to page three,  and then on each of these pages, we have this back arrow, okay?  So now if I decide to go to page three,  I'm gonna take this page,  and I'm gonna push this onto the stack,  which now means I have page two on the stack.  So now from page three, let's say I want to go back, right?  Well, for me to go back,  all I have to do is actually just grab  whatever the current element is on the top of the stack,  and that's the page that I would navigate to.  So when I click this back arrow here,  all I do is pop this element off of the stack,  and then that will bring me back to page number two.  So hopefully this is making a little bit of sense,  but now I'm on page two.  This element would now be removed from the stack,  because we're currently kind of on this page,  we navigated to it,  just trying to erase some of these lines here,  although it's not really working very well.  So now if we're on this page,  and we press the back arrow,  then all we need to do is kind of delete this page here,  pop whatever's currently on the stack,  and then that will bring us back to that page.  Hopefully that makes a little bit of sense,  but this is a stack of different pages  that we're kind of building, right?  So the idea is we keep stacking our different pages,  and every single time we want to go to the previous page,  all we have to do is pop off of the stack, okay?  So we're just popping it,  that's gonna then remove it,  and give us the page we need to go to,  and just keep popping, popping, popping, popping, popping,  until you get to where the stack was originated from,  which was this first page.  So doing a web browser kind of back and forth,  so forward arrow, back arrow, et cetera,  you can kind of implement that using something like a stack.  Now another interesting example here  is actually using a stack to build a queue,  or in fact using two stacks to build a queue.  So before I go through this example,  think about how we might go about using two separate stacks  to actually implement a queue data structure.  Remember, when we have a queue,  we're gonna be inserting from the back  and removing from the front,  so we do operations at the opposite side.  So how do we do that using a stack?  So hopefully here you've had a second to think about this,  this is a pretty decent exercise  to go through on your own.  Now the first thing to understand here  is that one of the operations,  either push or pop,  is gonna end up happening in linear time, okay?  So big O of,  and time.  Now that's fine, it's still a good exercise to go through  because you're going to see how we can use  these different data structures together.  So we have two different stacks here, okay?  And we want to build a queue.  Now we're going to label these two different stacks.  We're going to have an input stack and an output stack.  Now there's multiple ways to go about doing this,  but the way that I'm going to show you here  is probably the most common, okay?  So we need to define either a special way  to push elements onto the stack  or to pop elements off.  Now it's either going to be that this push operation  is going to take linear time  or this pop operation is going to take linear time.  So we need to decide which one we want to optimize.  In our case, I'm going to say that pushing onto the stack  is what I want to take longer than popping.  So I want to be able to instantly pop off the stack  in constant time pushing, that can take a little bit longer.  Okay, so what are we going to do?  Well, what we're going to do is we're going to push elements  onto our input stack.  So what I will do is if I have an element one here,  I'll put this directly on the input.  Now since there's only one element,  there's nothing special that we need to do.  We can just add this directly here.  However, now let's say I want to add element two.  Now if I just put element two onto this stack  and then I pop off that stack,  then I don't actually have a queue, right?  Because I want to process one before I process two.  And I want to make sure that I can process one instantly.  So what I'm actually going to do  before I take my new element two,  which I want to place onto my queue,  I'm going to take whatever's on the input stack  and I'm going to put it onto the output stack, okay?  So I'm going to pop all the elements in order  from my input stack and push them on to output.  So I'm going to take this here and push that over.  Okay, so we've pushed one over here.  Then we're going to push element two onto our input stack  and then we're going to pop all the elements  from the other stack and push those back onto the input stack.  So let's just kind of erase some of this here.  Essentially what happens is the one gets moved over here.  The two gets placed here so we've now inserted two  and then we go back to our output stack  and we place one back on the input stack.  And now one is ahead of two in the stack,  which means if I pop this off the input stack,  I get the correct queue order, okay?  So when I'm doing a push operation,  I need to first take all the elements on the input stack,  place them on the output stack,  put my new element at the bottom of the input stack  and then push the elements back to the input stack.  I know, seems complicated,  but this is how we do it with two different stacks.  That now means if we pop from the input stack,  we get the correct queue order  because one was inserted before two,  so we want to remove that first.  Okay, let's try this with three now.  So if we have three, we need to do the same process.  So we're going to pop all the elements off.  So we take one and two and put that on the output stack.  When we do it, notice it reverses the order, okay?  Then we put three back on the input stack  and then we pop off the output stack onto the input stack.  And notice we maintain our order here.  So we're essentially reversing the order that we'd have  if we were just using a normal stack.  One last time, if we have four,  again, we're going to pop this off.  So one, two, and then three,  place four onto here,  and then we'd have three, two, one,  because that's the order that we'd pop off of the output stack.  There you go, you've just used two stacks to implement a queue.  Now, as quick recap here,  we have the different operations.  So pushing or putting, popping or getting,  peaking or front or is empty,  all are going to run in constant time.  And again, the main property of our stack here  is that the first element in is the last element out,  or the last element in is the first element out.  Hello, everybody, and welcome to the next video in this section,  where I will be discussing binary trees.  Now, this is going to be the first data structure  that we're looking at, which is non-linear.  I won't lie to you.  It is a bit more complicated  than the other data structures we've seen thus far,  but it is interesting,  and there's quite a few optimizations we can make to code  by using a binary tree.  So let's start by discussing a binary tree.  And I just want to be clear here  in case you're familiar with this topic.  I am not talking about binary search trees.  Now, binary search trees are a specific type of binary tree.  We're going to talk about those in the next video.  Okay, so what is a binary tree?  Well, binary trees are simply trees that satisfy the property  that any given node in our tree can have  at most two children node.  Now, it might only have one child node.  It might have no child node.  Those are fine, but it can have at most two children nodes,  which means, again, for any one of these nodes,  you can have at most two.  You could have one, you could have none.  Now, when we're looking at our binary tree,  we have a few different definitions here.  I know this one's pretty messy,  but this here is what we refer to as the root of our tree.  Okay, having access to the root allows us to access  all of the other nodes inside of the tree.  The nodes that don't have any child nodes  are referred to as our leaf nodes, okay?  The leaf node has no children nodes.  Then these right here, which connect our nodes  are referred to as edges, okay?  These are kind of edges in the tree.  And then we have the height of the binary tree, okay?  Now the height or h for the binary tree  is the largest number of edges that exist  between any set of nodes.  So that means in this binary tree,  the height is equal to two  because if we look at the longest path  in our binary tree,  we see that we have two edges, okay?  I'm just gonna keep going through definitions.  I know there's a lot here,  but once I get through all of these,  then I can actually explain more of the concepts in the tree.  So let's say we had one more node right here,  then the height would change to three  because we can count three edges here in the binary tree, okay?  We also have something known as the depth of a node.  Now the depth of the node is how many edges  we have to go up in the tree to reach the root node.  So from this node here, we have a depth of three.  From this node here, we have a depth of one  because we just need to reach the root node right here, okay?  So for every single node,  if we count the number of edges that are required  to go back to the root node,  that is the depth of that node.  We'd also call that the level of the nodes,  the sum level one, the sum level two,  this is on level three, okay?  Now the advantage of using a binary tree  is that can allow us to access, delete,  and find information in a fairly fast time complexity.  So let me erase all of this,  and let's start from the beginning here,  and go through some more kind of properties  of our binary tree.  All right, so we have a tree here.  Now we're gonna have nodes, okay?  So every one of these things that you see here is a node.  On the node, we have a value, okay?  That value is kind of storing the different data  so our nodes could have numbers inside of them.  They could have strings, they could have arrays,  they could have other nodes, they can store whatever they want,  and then we have a left, and a right child, okay, or pointer.  So here, from this root node,  this here would be the left, and this here would be the right.  And then from these nodes, their left and rights  would both be equal to null,  and then they would have whatever value kind of  is the data that they're storing.  So hopefully that makes a bit of sense, but we have a node,  we have a value, and then we have the left and the right child  for that node, and those left and right properties here  are pointing to another node.  All right, now that we've seen that,  I'm gonna draw out a binary tree,  and I'm gonna show you how we would actually traverse a tree  and also how we insert values inside of it.  All right, so I have a binary tree here,  and unlike a stack or a queue,  it's not necessarily intuitive,  how we would actually go about, for example,  printing all of the different values  that exist inside of this tree.  So for the first exercise here,  I'm gonna write some pseudocode,  they will illustrate to you how we can do something known  as traverse a binary tree.  Once we look at the traversal process,  then I can talk to you about what happens  when we insert or delete elements from the tree,  because we need to know how to traverse  before we can actually do that.  So the whole idea here with this binary tree  is that we're storing nodes in different levels,  and by doing this, we can actually quickly access  different nodes in our tree and insert and delete them as well.  Again, you're gonna see that as we go through  those different operations,  but based on the properties of our binary tree,  we can have some faster time complex,  the operations for insertion, deletion,  and retrieval of different elements.  Okay, so let's see how to start.  We would very simply take this binary tree structure,  where we have access to only the root node  and print out all of the different nodes  that exist inside of the tree.  Well, to do that, we're actually gonna use a queue.  Now, you can try to write this algorithm yourself  if you want to.  It is gonna be a little bit challenging,  but I'll write it out for you on the right-hand side  of the screen in my horrible handwriting.  Okay, so we're gonna start by creating a queue, all right?  Inside of the queue, we're gonna place our root node,  which is node one, okay?  Remember that on our nodes, we have the value,  and we have the left and the right property.  We're now gonna create a while loop,  and we're gonna say while not queue dot is,  empty, okay?  So we're essentially gonna loop through  all of the different elements inside of our queue.  Don't worry too much about the actual code  that I'm writing here.  Again, this is kind of pseudo-code.  It wouldn't actually work if you typed  it into your computer.  I'm just trying to illustrate the process  that we would go through.  So what we're going to do is we're gonna pop  the first element off of the queue,  and then we're gonna print that out, okay?  So what we're doing is we're just trying to print  all of the different elements in the queue.  So we're gonna say something like current,  so curve here is equal to queue dot pop.  Now that's gonna give us whatever the current element is,  and then we can simply say print,  and then curve dot value.  and it's going to print out what the value is.  Then what we need to do is add onto the queue,  the left, and the right child of this element, okay?  So we're going to say, if Kerr dot left,  then q dot push Kerr dot left, okay?  And then we'll do the same thing for right, if Kerr dot right.  Then q dot push Kerr dot right, okay?  Hopefully you can read that.  What we're doing is we're setting up a wall loop.  We're making sure that our queue is not empty.  We are popping the first element from our queue  and then we're going to print out what the value is.  Then we're going to look at this element that we printed out  and we're going to say, okay, does it have a left child?  If it does, we need to process that element.  So let's add that to the queue.  That's what we do here.  If it doesn't, there's nothing we need to do.  Okay, does it have a right child?  If it does have a right child,  then we are going to add that element to the queue  so that we can process it.  So I'll kind of walk you through what would happen here.  If we have a sample queue,  so let me do this in a different color.  So let's say that this is our queue here, okay?  We have the front and we have the back.  We start with element one on the queue.  So what happens is we come into our wall loop.  We say is the queue empty?  No, it's not.  So we pop the first element off the queue.  So that means we take one  and that becomes equal to current, okay?  We're then going to print out what the value is,  which is one.  So I'll do kind of the print stack here on the left-hand side.  Okay, so we've now printed that value.  Now we check if current has a left.  Well, does one have a left?  Yes, it does it has a left of two.  So we're going to add that onto our queue.  Okay, so we add that to the front of the queue.  Then we check if it has a right.  Well, it does have a right.  That's right here.  So we add that onto our queue from the back, okay?  Perfect.  So now we have these two elements on the queue.  Now we return back to the top of the wall loop  and we ask ourselves is the queue empty?  Well, the queue is not empty.  There's two elements inside of it.  So we pop the element off of the queue.  So let's write two here and pop that and remove it.  Okay, now we print out the value.  So we get two and then we check if it has a left.  Does this have a left?  Yes, it does.  It has a left of four.  So we add that onto the queue.  Does it have a right?  Yes, it does.  So we add the right child of this element onto the queue.  Okay, now we continue the process.  So now we come here.  We pop the top element off, which is three.  So remove that here.  We print out the value.  Then we check if the current has a left.  So does our three here have a left?  No, it doesn't, so we don't have to do that.  Does it have a right?  No, it doesn't, so we don't have to do that.  Okay, so we just continue.  We move back into the wall loop here.  The queue is not empty.  So we pop the top element, which is four.  Okay, so now we print out four.  And then we check if it has a left.  Does it have a left?  No, it doesn't, doesn't have a right.  No, it doesn't, so we don't need to do anything here.  And now we can pop the last element five.  Print that out and we see it doesn't have a left or right.  So we're good and we have now processed the binary tree  and gone through all of the different elements, okay?  So what I just showed you here is actually what's referred to  as the breadth first search algorithm.  Now we're going to have an entire video on this  where we actually look at writing this in real code.  But for now, what we've done is we've set up a queue.  We've placed an element inside of the queue  and then we're constantly looking at that element.  So we're processing the element  and then we are checking if it has a left or right child.  If it does, we add the left and the right child  to the queue to be processed next.  So we process this by level of the binary tree, okay?  We do one level at a time.  So we start with one, then we go to two, then we go to three,  then we move on to the next level, then we do four,  then we do five.  There was more elements here.  We would have done those in that order, okay?  So that's how this works.  We're going to process elements in the order  in which they exist inside of our binary tree.  And we'll keep going level by level  until we get every single element.  So that is the first way that you can traverse a binary tree.  Now though, I want to show you what happens  if we want to traverse a binary tree  in a depth first search approach.  Now a depth first search approach  essentially means that rather than going level by level  how we did here, we're actually going to go  as deep as we possibly can on every single node  while we traverse it.  So let me set up another example here  and then I'll be right back.  All right, so I've set up another binary tree here  and I want to show you how we traverse this tree  using the depth first search, okay?  This is a different type of search  that rather than using a queue is going to use a stack.  So in this instance, we are going to print out  all of the different node values  but we're going to do this in a different order.  So the way we're going to set this up  is we're going to say S is equal to a stack  and we're going to place on the stack our root node, okay?  We always are going to start with this root node  whenever we're doing some kind of traversal.  Then we're going to set up our wallet again.  to say, well, not s dot is empty. Okay. So just making sure it has some elements. Now we  need to pop the top element off. So we're going to say, see, I'm just going to do see this  time rather than current is equal to s dot pop that removes the top element. Then we're  going to again print, see like this. And now we are going to push the left and right child  onto the stack. Now the order in which we push this is important. So we need to decide, do  we want to traverse right first or left first? Now in my case, I'm going to traverse right  first, but you can do this in any order that you want. Okay. So I'm going to say if c dot  left, okay, then s dot push, see, let's do it like this dot left. And if c dot right, then  s dot push, see dot right. Okay. Hopefully you guys can read that. I know that it is pretty messy.  All right. So there you go. That is our algorithm. And now let's actually simulate this algorithm  with our stack. So where do I want to put my stack? Let's kind of draw it right here. Let's say  this is the front. And this is the back. And then we can write what's being printed on the left  hand side of our screen. Okay. So we start with element one. So element one is going to start at  the front of our stack or node one. We're going to pop that off. Okay. So we remove that from the  stack and then we're going to print it out. So we have one right there. Then we're going to check  if it has a left or if it has a right. Okay. So if it has a left, we're going to push this onto  the stack. So in this case, we can see that we do have a left. So we push a two. Let me just put  it right here onto the stack. Okay. And then we check if we have a right and then we push that  onto the stack. Now all of the operations we're doing from the front of the stack here. So that  means I'm going to be pushing my right node on to the top of the stack. Okay. So now those elements  have been added. Now we need to pop from the stack. So we're going to pop three off, right?  Because we're using a stack, not a queue. So we're popping from the front. All right. Now we print  out three because we're processing that element. We see if it has a left. If it does, we're going to  push that left on. So it doesn't have a left. So we don't need to do that. We see if it has a right.  It does have a right, which is five. So we push that element onto the stack. Okay. Now we are done  here. Let's erase this and move to the next element. Okay. So now we're going to pop five off  the stack. So pop that off. We're going to print it out. Okay. And then we're going to see if it has  a left and a right. It does. It has a left and a right. So we're going to push those on the stack.  Let me just increase this a little bit. So we have six and we have seven that get added to the stack  in that order because we pushed the left first. Okay. Now we need to pop. So we pop off seven. We say  does seven have a left or a right. No, it doesn't. So we just print it out here. And then we move on  to the next element. Okay. So now we pop off six. So six becomes current. Okay. We print six.  Doesn't have a left or a right. No, it doesn't. So we continue moving. Okay. Now we move on to two.  So we pop two off. We print it and we see does have a left or a right. It does. So we add four here  onto the stack. And then you get the point here. We are going to now make this equal to four.  And then print four out. And then we are done because now we will have no elements inside of our stack.  All right. So let's just draw out the traversal order that we actually went through here.  Let me just kind of erase this stack here. So it's a bit more clear.  All right. So we started out one. Then we went down to three. Then we went to five. Then we went to seven.  So we didn't go in the level order like we did before. We went as deep as we could possibly go  on the far right node. That's kind of the first thing that we did. Okay. We went as deep in the  tree as we could go. So that's what we did here. Then as soon as we reached this depth,  we continued going as deep as we could on the other child. So in this case, we went as deep as we  could on the left side from this node here. Okay. Then we were all the way back up here.  And on to two. And then we went to two. And then we went to four. And we would have continued  going as deep as we possibly could have on any single branch that we had inside of this tree.  Okay. So this is the depth first search. And this is not necessarily the opposite, but a different  way of traversing a tree. The depth first search, depending on how you set up this left and this  right here, is going to traverse as deep as it possibly can on either the right direction or the  left direction first. Now if I had swapped these blocks of codes here and I had pushed the right  and then pushed the left, we would have looked on the left side of the tree first. And then the  right side of the tree because we were pushing that left child to be on the top of the stack,  right? So again, I would have to reverse that if I wanted to then move to the left side,  then go to the right side. Okay. So that is our basic traversal of a binary tree. Now let's look  at what happens if we want to.  to insert or delete elements into the tree.  Let me clear this and we'll get a new example.  All right, so I've kind of butchered another drawing here  of a binary tree to get used to the bad handwriting.  Hopefully it's still visible so you guys can read all of this  regardless.  The question that I kind of want to ask you here  and then we're going to go through  is how we would insert the node six  in the correct position here,  which is the first kind of empty position  that's available, okay?  Now there's about a million questions  I could come up with related to binary trees,  but this will show you a basic insertion order, okay?  So how do we go about inserting six  into this binary tree?  And what is the time complex  the of that operation going to be?  All right, so to insert six,  what we essentially need to do is find the first position  in which we don't have a left or right child.  But we need to do that by traversing  this binary search tree using a level order traversal  or a breadth first search.  What I essentially want to do here  is I want to look at the nodes  so the left and right node of my root node here  and I want to first ask, okay, does this have a left child?  If it doesn't have a left child  then I'll just insert this node right here.  Then I'm going to ask does it have a right child?  If it doesn't have a right child  I'm going to insert the node as the right child.  Now if it does have a left and right child  I need to repeat the process first  starting with the left child then the right child.  Because again, I'm looking for the first empty slot  that I can insert this node into.  I could insert it here, right?  I could insert it here.  That's fine, but I don't want to do that.  I want to insert it in the correct position  in the binary tree.  Okay, so again, we're going to repeat this process now.  And what I would do is I would first process the left node  then process the right node using that breadth first search  which is the first traversal approach I showed you.  So I'd come here to this left node I'd ask,  okay, does it have a left child?  Does it have a right child?  Well, it does not.  So I wouldn't do anything for this node, right?  What I would do is actually just add these two nodes  to a queue so that I can process them next.  Then I would come to this right node  because that's the next node in the queue  and in the level order that I need to look at.  And I would check does this have a left child?  It doesn't have a left child,  so then I would just insert this as the left child  and then I would be done.  So again, we're looking level by level here  and finding the first node that doesn't have  a left or right child as soon as we find  that we insert the node there.  Okay, so that is the insertion process.  Now I won't write out all the code  because we pretty much know how to do that.  We just do the traversal until we find  that we don't have a left node,  then we would insert and then just stop doing the traversal.  Now what is the time complexity of this operation going to be?  Now for this insertion operation  based on how we have the time complexity laid out here,  this is gonna be big O of N time  where N is the number of nodes that exist inside of the tree.  The reason it takes that long is because we don't know  where we're gonna find the first node  that doesn't have a left or right child.  For example, if this was actually what the tree was  and we wanted to insert a node into here,  we'd have to look through this node, this node, this node,  and then this node and then do the insertion.  We also could have a situation where we have nodes like this  and we're adding the node as the far rightmost node  in our tree, right?  So we wanna be adding it here,  imagining these already are existing nodes.  If that's the case, I need to look through  every single node in my binary tree  before I can perform the insertion operation.  Now there is other ways to speed up this type of operation  but not in this specific type of tree  that we're looking at right here, okay?  So that's that insertion operation.  All right, so I've just cleared the screen here  and came up with another example  where now I'm gonna show you how we can delete a node.  So you saw in the previous example there  that we inserted a node and that took a big O of N time.  Now that's because of how the tree was set up.  If we're using something known as a binary search tree  which I'm gonna talk about in the next video,  you'll see that we will actually get  some better big O notation time complexities.  But in this video, when we're just using  standard binary trees, that's not necessarily the case.  So yes, binary trees can improve our time complexity  but they don't always improve it.  It depends on the structure  and some of the properties of the tree.  Regardless, let's say that we wanted to delete node two here.  Well, if I wanted to delete node two from this tree,  it's not quite a trivial operation  because I have two children nodes  that are connected to this node.  So it's not as easy as me just removing the reference  from this node right here, the parent node.  In fact, what I actually need to do  is I need to find a node that I can delete  that doesn't have any children node  and then swap that with this node right here.  So really what's gonna happen is the following.  If I wanted to delete this node  or any node inside of the tree,  I'm gonna locate the furthest rightmost node in my tree.  Now in that case, that node's gonna be seven.  The way I can locate that is using a depth first search approach  which is what I showed you already, right?  Well, we're traversing the tree,  looking on the right side of the tree first.  Now as soon as I find a node  that doesn't have a left or right child,  I know that I found a leaf.  node and it's safe for me to delete a leaf node because if I delete a leaf node,  I'm not deleting any children nodes, right? Because it's not connected to anything.  So what I want to do is I want to take two and I want to create that or move that to a leaf node  so then I can delete that node. Okay. So what I do is I locate this node. Once I locate that node,  I'm going to store kind of the parent of the node. Okay. The reason I need to store the  parent of the node is because for me to delete this node, I need to actually have the edge  from the parent to this node removed. So I go through my tree doing my depth first search  and I essentially look at every single node. I say, are your left or right children a node that  doesn't have any left or right children? If that's the case, then I've located the parent node  that contains a node on the left or right side that I want to delete. Okay. So in this case, I  locate this node here and I know that on the right side, this is the node that I'm going to be  deleting. See if we're going to be on the left or the right side. Okay. So we find this parent  and now that we've located this parent, we want to find the node that we want to delete. So if we want  it to delete too, we now need to do a breadth first search. We can do a depth first search as well.  Doesn't really matter, but we'll probably do a breadth first search to locate that node. So I've  now located this node too. So all I do is I take the data and I swap it on these two notes.  Really, actually, I just take seven and I place that here on this node. Okay. So I turn that into  node seven. Now that I've done that, I can safely delete this node because I've stored its data  in another node. So now all I do is delete the node here and I have actually deleted node two by  swapping the data with that edge node. Okay. And the way I do the deletion is I just say that this  nodes dot next is equal to no. And as soon as I do that, I now lose the reference to what used to  be the node seven. And now seven is on the left hand side of my tree. Okay. So again, the basic  algorithm is find the furthest rightmost node. Then you need to find the parent of that node. So you'll  kind of do that while you're finding the node. Then you are going to find the node that you want to  delete. You're going to take the data from the furthest rightmost node and essentially put that or  copy that inside of the node you want to delete. Then you're going to delete the furthest rightmost  node and you delete that by changing the reference of the parent of that node. Okay. That's how you  perform a delete. I'm not going to run you through all of the code here because it is a little bit  complicated, but I just wanted to conceptually kind of give you that information. All right. So now we  are almost done, but I need to start talking to you about a few different types of binary trees  and some properties that we need to have a look at here. So one of the most important things  of our binary trees is being able to determine the maximum number of nodes and the minimum number  of nodes that we can have. Now I'm going to do this on the whiteboard and then I'm going to go to a  PowerPoint slide where I'll give you some more formal definitions. So we know that when we have a  binary tree like this, that the property of the binary tree is that every single node can have  at most two children nodes. We also have a height of this tree, right, which is the maximum depth  of any given node. So one property of our binary tree is that the maximum number of nodes that  can be contained inside of the tree is two to the exponent of the height of the tree plus one  minus one. Okay. This is just something that you kind of need to know and so the maximum value of  n, which is the number of nodes inside of our tree, is always equal to two of whatever the  height is plus one minus one. So let's punch this in. In this case, the height is two. So it gives us  two to the exponent three, which is eight and then we subtract one and this gives us seven.  And you can see this binary tree is completely full here up to height two and we have seven  nodes inside row four, two, one. That is seven. Let's go one level deeper just to prove this to you  again, right? So now I don't know why I'm writing eight there. It's because I wanted to add eight  nodes. We'll add some more nodes here. Okay. Now our height has increased to three. So now if we  punch in the formula, we get two to the exponent four minus one, which is 15. And if you start  adding this up, we have eight plus the seven, which is going to give us 15 nodes. Okay. So the maximum  number of nodes in any binary tree is always going to be two to the exponent h plus one. All right.  So just remember that very important. Okay. The maximum number of nodes you can have in your tree  is two to the exponent h plus one minus one. And that's just due to the properties of this tree.  The height of the tree is an important factor. Again, that's going to be the maximum possible depth  between any given node in the tree. And there's some other properties we can look at at the tree where  the height is always going to be a maximum of n minus one, where n is the number of nodes in the tree.  The reason for that is we could potentially have a tree that is actually just a linked list,  where we don't have any right children. We just have all left children.  In this case, we've really just implemented a linked list, right?  Now, the height of this is three,  and that is what the maximum height can be when we have four different nodes, okay?  Now, we could have also just had only right children.  So, if we only had right children, then again, you get the same thing.  You get a linked list here, in this case, the height is four going to the right.  All right. So, those are a few of the properties I wanted to show you.  Maximum number of nodes, two to the exponent, H plus one minus one,  and then the maximum height is always going to be N minus one.  Now, let's go to a PowerPoint.  And I'm going to talk to you about a few different types of binary trees that we can have  and some of their properties.  In fact, I think I'm going to throw that in another video,  because this one's getting quite long.  So, just wait for that video, and I will talk to you about the different types.  Hello, everybody, and welcome to the next video in this section,  where I'll be continuing and talking more about binary trees.  Now, before we get into this video, I just want to mention that there is a lot  that we can cover related to binary trees and to data structures and algorithms in general.  The goal of this section is not to be a comprehensive overview of everything  in terms of data structures and algorithms.  It's meant to give you almost a crash course and kind of a high-level overview  of most of these topics.  Yes, we've gone into examples.  Yes, I've shown you some details and some pseudo code,  but I don't want to get into full code examples or we've shown you tons of  implementations, because that's going to take a massive amount of time  and not be the most beneficial thing you can learn at this point in time.  For many junior developers, you're never actually going to have to use  data structures and algorithms, but it will be kind of assumed that you know what they are,  and you have some understanding of them.  So, that's really the objective here of this section.  Give you a high-level overview, give you a few examples,  and make sure that you're not caught off guard if this were to come up in something  like an interview where you were to see these in some kind of production code environment.  Hopefully, that makes sense.  With that said, let's keep going.  Okay, so binary tree recap.  Just to make sure we're all on the same page here,  every node in our binary tree contains a value or some data,  and then a left and a right property.  Each node can have at most two children,  and we store the root of a binary tree, which then gives us access to all of the other nodes.  Now, the depth of a node is the number of edges between that node and the root,  and the height of a binary tree is the maximum depth of a node.  Okay, so that's everything we already learned.  Just wanted to quickly go through that again.  Now, let's talk about some binary tree traversals.  So, I showed you that we can traverse a binary tree in a variety of different ways,  using the breadth-first search or the depth-first search approach.  Now, there's actually a few other ways that we can traverse this structure that I haven't yet  shown you. So, depending on the order we add nodes into our stack or queue,  we can traverse from left side first or the right side first.  We saw that in the previous video, and we saw how we could kind of go through and search for  different nodes.  However, there's three kind of famous ways to go about traversing the tree.  They don't actually need to use a breadth or depth-first search approach.  I'm not going to show you the code for actually performing this traversal,  but you can come up with it fairly easily once I talk to you about what these different  traversals are. So, we have an in-order traversal, a pre-order traversal,  and a post-order traversal, which are used commonly in a lot of Surrey data structures and  algorithms style questions, where we are trying to get different values of nodes.  Okay, so let's look at the in-order traversal.  The in-order traversal traverses the nodes in our tree from left to right.  Specifically, what it does is it processes the left node, visits the current node, and then  processes the right node. Now, I'll walk you through the in-order traversal of this tree,  but you'll see that it's fairly easy to actually look at a tree and very quickly come up with this  when you know the difference between in-order, pre-order, and post-order, which is fairly intuitive.  So, when we look at this tree here, what we're going to do is essentially follow this algorithm.  Process the left node, visit the current node, process the right node, and we just apply this to  every single node. So, we start at node one, and then we process the left node.  We are now at node two, we process the left node, which is four, and then we process the left node,  which is eight. Now, from eight, we try to process the left node, but there is no left node,  so that means we then visit the current node, so we would mark down eight in our in-order traversal,  and then we process the right node. There is no right node, so now we are done with eight.  So, that means now we go back to four, because we finish processing the left node.  So, from four, we visit the current node, so we mark that in our in-order traversal, sorry,  and then we visit the right node, or process the right node, sorry.  So, we come to the right node, we try to process the left, doesn't exist, so we visit the node,  so we mark down nine, then we try to process the right, doesn't exist, so we now we go back to four.  At this point, four has processed the left, visited itself, and processed the right.  So, now we go to two. So, now we're at two, we've just processed the left sub-tree of two here,  so now we say that we're going to visit this node, so we mark down two in the in-order traversal,  then we go to five. From five here, we have to process the left tree, so we go here,  and we process the left tree. When we process the left of ten, we see that we don't have a node,  so we visit ten, and we mark that down, try to process the right, we don't have one,  so we go back to five. Now we've processed the left of five, so now we visit  this. So visit the current node. We mark down five in our in order to  traversal. Then we process 11 here, come back up to five. Five is now done.  Come back up to two. Two is now done because we've processed the left,  visited and then processed the right. Now we come to one. Now that we've  processed the left subtree of one, we mark down one in our in order to  traversal. And then we continue on the right side. So we go here to three from  three. We need to process the left. So we process six. Six has no left  subtree. So we visit it, which we do right here. Then we process the  right. 13 has no left or right. So we visit it, come back up to six,  come back to three. And now at three, we've processed the left. So now we  visit three. Then we go to the right. We see that we have a seven from  seven. We need to process the left subtree. So we do that. We visit 14.  Then we come back up to seven and we visit that. Now I just went through  the whole thing, which might be a little bit confusing. But you can see that  I'm essentially just reading these node values from left to right. Okay.  So eight, four, nine, two, five, 10, 11, one. And then this is six, 13,  three, seven, 14. Okay. So I'm reading it literally from left to right.  That is what the in order traversal does. Okay. Next, let's move to the preorder  traversal. So the preorder traversal visits a node and then traverses both  its subtrees. Okay. So it's going to visit and then go left and right. So the  not in order. Sorry, that's just a preorder. My mistake here.  Traversal of this tree is one, two, four, eight, nine, five. Okay.  So let's go through this. So we start at one. We visit the node.  We then go to the left. We visit the node. So we mark down two. We then go  to the left. We visit the node. We mark down four. Then we go to the left.  We visit the node. We mark down eight. Now that we've done the left,  we need to process the right. So we go to the right. We mark down nine.  We come back up to four. We've already looked at that. We come to two.  And now that we've processed the left and visited, we need to go to the right.  So we mark down five because we visit that. Then we process the left.  So we mark down 10. Come back up, process the next one, which is 11.  Okay. Now we're done with two and we go to one at one.  At this point, we visited the current node and process the left node.  Now we go to the right. Now we're at three. So we mark down three  because we visit that first. Then we process the left. So we go to the left,  mark that down and then we process the left. Doesn't exist.  Process the right. 13 mark that down. Come back up to six.  Six is now done. Come back up to three.  Now we need to process the right. So we mark down seven.  We mark down 14 and we have finished the pre order traversal.  So you're kind of going in the same order that you would in an in order traversal,  but you're visiting the current node first. Okay.  So you can kind of practice on this tree. If you want,  but you can see that this is the answer right here of the not in order again.  Sorry, that's just a pre order traversal. My apologies on the mistake. Okay.  Next slide here. We have post order traversal.  The post order traversal traverses both a node's subtrees, then visits the node.  The post post order traversal of this tree is the following.  So for this, we're processing the left processing the right and then  visiting the current node. So let's start at one. Okay.  So we're going to process the left, then the right, then visit.  So we go to the left from two. We're going to go to the left from four.  We're going to go to the left. Okay. Now we're at eight.  It has no left or right. So we visit this node.  Then we come up, come back up to four. Sorry.  We've now finished the first step. We now need to process the right.  So now we mark down nine because it has no left or right.  Come back up to four. Now that we've processed the left and the right,  we can visit this node. So we visit four. Okay.  Come back up here to two. We've now done the left sub tree.  Now we need to do the right sub tree. So we go to five.  Again, we need to process the left and the right first.  So we process 10, mark that down, process 11, mark that down, come back up to five.  Now we can visit that because we've done the left and the right sub tree.  Okay. Now we come to two. Two has now completed the left and the right sub tree.  So now we mark down two, which is what we do right here.  Coming back up to one, we've now completed the left sub tree.  We now need to do the right sub tree. So we go to three.  Okay. We need to process the left and the right first.  We go to six. Same thing. We need to process both the right and the left.  So we process 13. Okay. Few that here.  Come back up to six. Six now is done on the left and the right.  So we mark down six. Come up to three.  We're now done the left sub tree.  Now we need to do the right sub tree.  So from three, we visit seven. Okay.  Seven needs to do the left and the right first.  So we do 14. Okay. So we mark down 14 here.  Then we come back up to seven. Seven is now done.  We mark down seven. Three is now done.  We mark down three.  And then one, our root node is always going to be last  because we need to do the left and the right sub tree of the root node  before we can mark that down.  That is the post order traversal.  Okay. So those are the three different types of traversals.  In order pre order post order, you should be able to look at a tree  and perform any one of those traversals  by remembering this order. Okay.  So it's process, process, and visit.  And the order of that is what's switched around.  So in the in order traversal, you are processing left,  visiting, processing right.  In the pre order, you are visiting,  then processing left, then processing right.  And in the post order, you're processing left,  right, and then visiting. Okay.  So those are kind of the three combinations that we have.  All right. So moving on here, we have various types of binary trees,  each of which have  different properties. We have a full binary tree, complete binary tree, balance binary tree,  and perfect binary tree. Let's look at the different types. Okay, so full binary tree,  a full binary tree is a binary tree in which all of the nodes have either zero or two children,  meaning only leaf nodes have no children. Okay, so have a look at these three trees here and try  to determine if they are full or not based on this definition. Again, this means that we can only  have zero or two children for every single node. So let's look at this first one right here.  So this node has two children. Okay, that checks. This node has two children. Okay, that's okay.  This node has no children. That's fine. This node has no children. And this node has no children.  Children, sorry, that means this is okay. And this is a full binary tree. All right, let's move  on to the next one. Is this one full or not? Okay, so here we have a node has two children.  Here we have a node only as one child. Okay, that's not fine. This means this is not a full  binary tree. Okay, moving on to this one. Is this a full binary tree? Well, this node has two children.  That's okay. This one has two. That's okay. This one has two. That's okay. The rest of them only  have one, which means yes, this is a full binary tree. Okay, so that is full binary trees. All right,  so now we move on to complete binary tree. A binary tree is said to be a complete binary tree. If  all of its levels accept possibly the last level have the maximum number of possible nodes  and all of the nodes in the last level appears far left as possible. Okay, so there's two  piece of criteria. First of all, all levels except the last have to be full of nodes. Okay,  have the maximum number of nodes. And if we have any nodes in the last level, they have to be as far  left as possible. So have a look at these examples and try to determine if they are complete or not.  Okay, so example one, this is a complete binary tree. The reason it is a complete binary tree is  because we have all levels except the last filled. So this has two nodes. So it's a filled level  and the nodes that exist in the last level are as far left as possible. Okay, moving on to the next  one. This is a complete binary tree. The reason it is complete is the same reason this one is complete.  These levels above the last level are filled. And then we have one node that is as far left as  it could possibly be. If this node was the right child of node two, it would not be a complete  binary tree because the node would not be as far left as possible. Okay, moving on to the last one,  this is not a complete binary tree. That is because even though this level is filled here,  the last level we have node five is the right child of node three, meaning it's not as far left as  it could possibly be. So this is not complete. Now, let's actually just go back to the previous  example. And let's look at these trees and determine if they are complete or not. So tree one,  this is the same as before. So that's complete tree two. Yes, same one is before. So that's complete  as well. But what about this tree is this complete? Well, having a look at this, we can actually see  that no, it is not complete. Even though everything is as far left as it can possibly be, the reason  why it's not complete is because this level here is not filled. Okay, we need to have two more  nodes on node three here for this to be a complete binary tree. All right, let's now move on to the  next one, which is a balanced binary tree. Now a binary tree is said to be balanced binary tree.  If the height of the left and right subtree of any node differ by not more than one. So the  way you actually check for a balanced binary tree is you look at the left and right subtree of  every single node and you see the height of that tree. Then you take those two heights, you subtract  them by each other. And if the absolute value of that height is less than or equal to one,  then it means that it is balanced. If it is greater than one, it is not balanced. So it's better if we  just go through examples, rather than try to look at the definition. So let's look at example one,  is this balanced? Well, the way we do this is we start by looking at node one and we look to the  left and to the right. We check the depth of the left tree and the depth of the right tree are  the height of the left and the right tree. So in this case, the height of the left tree is two,  okay, because we have two elements. And the height of the right tree is one. All right,  or you could say one and zero, like the height of the tree rooted at two is one,  and the height of the tree rooted at three is what he called zero. So you can kind of say it in  any way that you want, as long as you do it the same across both the left and the right side.  So when we take the height of the left and subtract it by the height of the right,  we get negative one or we get one depending on how you do the subtraction.  Anyways, that's within our range here. So that means this is balanced, okay? So this is a balanced  tree. Next, we have this one here. So we look at our root node and we look to the left. To the left,  we can see we have a height of two. Okay, we have two elements here. And to the right, we see we  have a height of zero. So that means if we take two, we subtract by zero, we get two. That means  that we have a difference of two. So this tree is not balanced, okay? Moving on to our last  side right here is this a balanced tree. Well, at first glance, it might look like it is. The reason  for that is that we have three nodes on the left side and two nodes on the right side, three minus two  is one. However, this property needs to apply for every single node, right? So if I now go here to  node two, I see I have a height of two in my left subtree and a height of zero in my right subtree,  meaning that this is not...  not balanced, okay?  Not just because the root node is balanced  makes the whole tree balanced.  You have to balance every single node.  Hopefully that makes sense.  Again, when we look at node two here,  we have a height of two on the left side  and a height of zero on the right side,  making this not balanced.  All right, now let's move on to the last example  or last type sorry, which is the perfect binary tree.  Now a binary tree is said to be a perfect binary tree  if all levels of the tree are full of nodes.  So really, that's exactly what you see right here, okay?  This is a perfect binary tree  because every single level is completely filled.  If we're missing any of the nodes here,  then that would mean that this is not a perfect binary tree.  This is probably the easiest one to determine.  Okay, so those are the different types.  I'm not gonna tell you that you necessarily need  to memorize every single one of them,  but it can be important to know what type of tree  you're working with because if you know that,  you can assume some things about the tree.  For example, if we're dealing with a perfect binary tree,  then we know how many nodes are inside of the tree  given the height of the tree.  Or given the number of nodes,  we can figure out the height of the tree.  You see what I'm saying here?  If we know certain aspects of the tree,  there's certain other aspects we can imply about it  and that we can know to be true.  With a perfect binary tree,  we know that the number of nodes in the tree  is going to be two raised to the exponent  of the height of the tree plus one minus one, okay?  In this case, we know the height is two,  so we take two raised it to the exponent three  because we have two plus one, right?  H plus one, that's going to give us eight,  subtract one, that's seven,  we know there's seven nodes inside of this tree.  Likewise, if we know that there's seven nodes,  then we can actually do the reverse  and we can determine that the height of the tree is two, okay?  There you go, that is all I wanted to share  with you about binary trees.  In the next video,  we're going to talk about a binary search tree,  which will allow us to actually have  some more performant operations  when we are searching for,  deleting or inserting different elements.  Hello, everybody,  and welcome to the next video in this section.  While we'll be discussing binary search trees,  now a binary search tree is a special type of tree  that has an additional property on it.  This property is that anytime we have a node,  all of the values that are in the left subtree of that node  are going to be less than that node itself.  And all of the values that are on the right subtree  or in the right subtree of that node  are going to be greater than that.  Now, we do need to handle the case  in which we have values that are equal to each other.  If that's the case,  you can decide to put those values on the left side  or on the right side,  but you can't decide on both.  So you need to pick,  is it going to go to the left  or is it going to go to the right?  In this situation for this video story,  we're just going to use values that are all unique  to make things a little bit simpler for us,  but you do need to handle the case  in which you have values that are the same, right?  So if I have another three,  then we could maybe put this on the right side,  but that would mean I can't have that on the left side.  Hopefully that makes a bit of sense,  but essentially all of the values  that are less than a value  are in the left subtree  and all of the values that are greater than the value  of a node go in the right subtree.  That is the binary search tree.  So let's draw out a simple binary search tree  and then we'll talk about some different operations  and why we would actually want to use something like this.  So let's say we have our root node of four.  This means anything in the left subtree of this node  has to be less than.  So maybe we have a node like two,  and then we have a node like three.  Now notice what I've done here,  is I've placed the node three  as the right child of the node two.  The reason for that is that node three is less than four,  so it's okay to be in the subtree,  the left subtree of this node here.  However, it needs to be in the right subtree of node two  because it's greater than value two.  Okay, we can come here and we can add one.  Now on this side, maybe we have a value say like eight, okay?  And then maybe we have a value like six, a value like seven.  I'm just drawing out a few different values here,  so we kind of get the idea of how this works, okay?  So this is an example of a valid binary search tree.  The reason this is valid is because every single node  satisfies the properties that I discussed.  We have only values that are less than the node value  in the left subtree and only values  that are greater than or equal to the node value  in the right subtree.  Now having this type of binary search tree structure  allows us to efficiently search for,  add and delete different elements.  The reason for that is that we know this property,  we know that elements are either less than or greater  than depending on their position in the tree  so we can more efficiently search through the tree  when we're looking for a specific element.  So in this case here, let's say that we want to find  if the element 10 exists inside of the tree.  Well, with any other binary tree,  since we don't know this property,  we would have to look through every single element  inside of the tree to attempt to find 10.  However, in the binary search tree,  we don't have to do that.  What we can do is we can start at our root node  and we can compare the value that we're looking for  to the root node.  We know that it's greater than  so that means that we can move to the right.  Now we have the element here on the right, which is eight.  Okay, now we move to eight.  And now we can say, okay, is this equal to 10?  No, it's not.  So what do we need to do?  Well, 10 is greater than eight.  So we're going to look in the right subtree of eight.  So we come here and then we find 10  and we now have found the element.  So rather than having to look through potentially  every single element in the tree,  we only had to look through three different notes.  Now the time complexity of searching for an element  inside of a binary search tree  is big O of H where H is the height of the binary search tree.  Okay.  In this case, the height of the tree is going to be three.  That is because the furthest depth or highest depth  that we have is three.  So whatever the furthest possible depth is,  or I guess the highest depth in our tree,  that's the maximum number of operations  it will take us to find any given element  inside of a binary search tree.  Hopefully that's making sense.  But that is the basics on a binary tree  or binary search tree, I should say.  All right, so now that we've looked at searching a binary tree,  let's look at inserting some elements  and then we'll look at some pseudocode  to do both of those operations.  So let's say we want to insert the element of, I don't know,  let's go with five inside of our binary search tree.  Well, we need to place this in the correct location  such that our binary search tree  satisfies the correct properties.  Now the way we do this is the exact same way  that we actually search for an element  inside of our binary search tree.  We take our node five and we start moving  to where node five would be in the tree  and then we simply place it there.  So we compare it to the root node,  we say it's a greater than or less than.  If it's greater than, we move to the right subtree.  We look at the right subtree  and we say it's a greater than or less than.  Okay, well it's less than, so we move to the left subtree.  We look at this and we say it's a greater than or less than.  It's less than, but in this situation,  there's no left child node of this node right here.  So all we do is we simply add this node in as the left child.  Okay, so as soon as we find a situation  where we're going to move into a subtree,  but that subtree doesn't exist,  i.e., there's no node there,  we simply place the node that we're trying to insert  in that position.  So this is where five goes  and you can do this example with really any type  of numbers you want.  So if you try to do negative one,  then you're going to go to four here,  you're going to go to the left subtree, left subtree,  and then you try to go to the left subtree,  it doesn't exist, so you simply place  negative one here as the left child of that element.  Okay, so that is the binary search tree insertion.  Now let's create a binary search tree  and do multiple insertions  and then we'll look at a few pieces of source code,  or not source code, I guess,  but just kind of pseudo code for doing these operations.  Okay, so let's say we have the elements,  four, seven, three, two, one, and four.  Now what I want to do,  and actually let's not make this forks,  I don't want to have the same element,  let's go with eight here,  let's try to create a binary search tree here  by inserting all of these elements into the tree.  Now when we don't have any elements in the tree,  the first element we insert just becomes the root.  Now if you'd like, pause the video  and attempt this on your own  and see if you can figure out  what the binary search tree would look like  if we insert elements in this order.  I'm going to start drawing it out now.  Okay, so we start with our root node of four.  Then we go to insert node seven.  When we insert seven, we know we need to make that,  the right child of four,  because there is no right child,  and this is greater than node with value four.  Okay, so now these two are done.  Now we're on node three here.  We want to insert node three, so that's going to go  and be the left child of node four.  Okay, now we need to insert node two,  so that's going to be the left child of node four,  and then left child of node three.  So two comes here, now we need to insert one.  Okay, so we go left, left again,  and insert one, that's going to be the left child of two.  I apologize for that messy drawing.  And then we have eight that's going to be the right child  of seven, so we're going to place that there.  Okay, that is that binary search tree.  Let's do another example here.  So let's do maybe something like seven, four, two,  five, nine, six, three, one,  and I don't know, let's go with eight.  Okay, let's see what this binary search tree would look like.  So let me just draw the numbers out here.  We're going to have seven.  We're going to have four.  We're going to have two, so cross those off.  We're now going to have a five.  The five is going to go over here,  because we have to go left and then right.  Okay, now we're going to have a nine,  so nine's going to come over here.  Now we need to have a six,  so six is actually going to be sorry, not on that side,  but over here, because it's less than seven,  but it's greater than four, and it's greater than five,  so it needs to be placed over here.  Okay, so that's those done.  Then we have a three, our three is actually going to go here,  because it's less than seven.  It's less than four, but it's greater than two,  so it needs to go there.  Then we have a one.  One is going to go over here and be the left child of two,  and then we have an eight.  Eight's going to be the left child of nine.  Okay, so that's what this binary search tree would look like.  go through this practice, you can kind of write out a bunch of numbers for yourself  and try to create what the binary search tree would be. Obviously, I can do this quite quickly  because I've done it many times before, but you're just looking and seeing is it less than or  greater than and then placing it in the correct order. Okay, so that is the binary tree insertion.  Now, when we do that insertion, just like when we have the search, this is going to take a big O of  each time. Now, the reason it takes big O of each time is because we simply need to search for the  location where we want to place it, which takes big O of each time and then place it in that  location, right? So it's really the exact same rationale as why the search takes big O of each time  because we are going at most whatever the depth of the tree is. Now, one thing to note here,  let me just erase this is that how efficient the operation is going to be is based on the height  of the tree. Now, that means that the order in which we insert elements in our binary search tree  is going to affect the height and that can affect the time complexity of the different operations  that we're doing. So when we look at a binary tree, right, we could potentially have every single one  of the elements on the left subtree or every single one of the elements on the right subtree.  Just because we're using a binary search tree doesn't necessarily mean that our operations  are going to be faster because if we insert items in kind of an inefficient order,  then that means that we're going to have a bunch of items that are all kind of in a linked list  structure. So imagine we have a binary search tree, but there's no right trees at all. We only  have left subtrees here. If that's the case, then H is actually going to be equal to approximately  N or N minus 1 in this case, where N is the number of nodes. So even though yes, the time complex  is still big O of H, it actually ends up being big O of N because we have to look through every  single node potentially whenever we're doing some kind of operation with the binary search tree.  So that includes searching as well as inserting and we're going to talk about deleting in a minute.  Hopefully that's making a little bit of sense, but I just want to be clear here that it's  big O of H and it's important that we're using H here because that can represent a binary tree  that has a very small height, which is great for us. That means we have very fast operations  or a binary search tree that has a very, very high height, right, that is almost N minus 1.  Okay, so let's erase this and I'm just going to kind of explain this one more time and show you the  advantage of the binary search tree when we have it relatively balanced. Okay, so in the previous  example, I kind of explained to you the worst possible situation for the binary search tree, which is  we have this kind of linked list structure of all of the different elements. However, we can have a  really, really good situation where we have a balanced binary search tree. Now we can't ensure that  we're always going to have a balanced binary search tree. Well, there is a way to do that, but I'm not  going to talk about that in this course. It's a little bit more advanced. There's things called  self-balancing binary trees. They have some fancier names as well.  Anyways, we're not going to get into that, but if we do have a balanced binary search tree,  that means our time complex, the actually gets really, really good for operations. So let's say we  have a tree here. Okay, let's kind of just draw this out a little bit and I'm going to get 15 nodes  inside of this tree. Okay, now this is going to be a perfect binary tree and it's also going to be  a balanced binary tree. So a full binary tree, it's pretty much all of those ones that we talked  about in the last video. Okay, so in this case, if we have a balanced binary search tree,  and we are searching for a specific element, well, the time complex is still big of age.  But in this case, since we know the tree is balanced, we can actually say that the height  of the tree is equal to the logarithm base 2 of n, where n is the number of nodes in the tree.  And the number of nodes, I mean, we can calculate the height as well, but we need to know one of them  either the number of nodes of the height. Regardless, the reason this is important is because  that means as our binary tree gets larger and larger and larger, the height doesn't increase  at the same rate that the binary tree nodes increase. It increases logarithmically. So in this case,  if we take the log base 2 of 15, which is the number of nodes that we have, we get approximately  3.9, right? And if we look at the number of operations we need to do to find a node in the tree,  it's about four, okay? So we look here one, two, I guess this would be two, sorry, three,  and then four, okay? So we have to look through four different nodes at most, going through  three different edges to be able to find the node that we're looking for in our binary tree.  So that's the same for insertion as well as searching. We have the log base 2 of n as that kind  of time complex the operation. Now again, this is only the case when we have a balanced binary tree.  If we don't have a balanced binary tree, then we can't imply this because we could have  very, very large paths here that we have to go through. And in that case, we still want to  represent this with big O of H. But the point of me telling you this is that with binary search  trees, typically H is going to be less than n. I mean, it is going to be less than n, but typically  it will be much less than n. And if that's the case, then you get a  way better time complex the operation for searching, inserting, and deleting, which I guess  we can get into now.  Okay, so at this point, you should understand the main property of a binary search tree.  And you should know how we insert elements into the binary search tree and how we traverse  the tree and look to see if a specific element is inside of it.  Now I want to talk to you about deleting an element in a binary search tree, which is  not trivial.  And then I'll start writing out a little bit of code and showing you how we would kind  of go through the tree.  Again, this is not going to be a comprehensive overview.  This course is not meant to go into everything related to data structures now rhythms, but  I want to give you a solid foundation.  Okay.  So let's create a binary search tree.  Let's have node seven, let's have four, let's have five, three, one, two.  Okay, this is going to be 10, nine, 11, and then eight.  And actually, let me just redraw my eight here because that's a little butcher.  So we have a binary search tree here.  And let's say that we want to remove an element from this tree.  Well, there's three possible cases that we have when we want to remove an element.  The first case is that we want to remove a leaf node.  Now just like we saw with our regular binary trees, if we want to remove a leaf node,  that's quite simple.  We just remove the reference to that node from the parent of that node, okay?  So case one, very straightforward.  And we can do this deletion of the node in again, big O of H time.  Now the reason that's going to take big O of H time is because we first need to locate  the node.  We need to then get the parent of the node and then simply remove that reference, okay?  So to locate the node, we know we can do that in big O of H time because we will go through  the tree in that traversal structure that I already showed you.  Okay.  So that was case one.  We can kind of put a check mark here for case one where we're deleting a leaf node.  That's very straightforward.  Okay.  So now that we've handled case one, let's move on to case two, which is when we're looking  at a node that only has one child.  Okay.  So case one is no child and this is one child, okay?  So when we're looking at a one child node that we want to delete, an example of that would  be node nine.  Now how do we delete node nine?  First of all, we can't just cut this right here.  The reference to node nine like we would with the leaf node.  If we do that, we're going to lose access to any of the people or any of the, not people  sorry, children of this node.  So in this case, only as one child, it could be the left child of the right child.  In a way, we'll lose access to that entire branch coming off of this node.  And we don't know how far down the tree that goes.  So how do we do this?  Well, first thing we need to observe is that anything that's in the left subtree of the  parent of the node that we want to delete is going to be less than that parent, okay?  So important property to understand here.  So we want to delete this node, but we're going to get access to the parent node, which  is 10.  Again, anything in the left or right subtree of this node since it has a parent of 10 is  going to be less than this parent, all right?  Because it's in the left subtree.  And then same thing if it was in the right subtree, we know it would be greater than.  So in this situation, all we actually have to do is we have to take the parent nodes  left pointer and change that to be equal to the left pointer of the node we're going  to delete.  So I simply change the pointer here for 10 and then delete this reference.  And now what happens is since there's no reference to this node nine, node nine ends  up getting deleted.  And now the binary search tree property is still satisfied.  Again, the reason this worked is because anything that's in the left subtree of this node  is going to be less than.  So I can change this to anything that this child points to.  So let's switch this example up a little bit more just to make it a bit more clear.  So let's say this is 11, okay, this will be 12.  And then let's change this to be eight.  And then this here can be nine, okay?  So if this is the case, the exact same thing happens if we want to delete node eight.  So we want to delete this.  So what we do is we find the parent and we simply change the parent's left reference  here to be equal to whatever this was pointing to.  Again, it only has one child.  This is why this is working.  So that gets rid of this.  And then if this had a subtree down here, that would still be maintained, right?  And again, that works because of the reasons that I've stated.  I won't repeat myself, you know, the fifth or sixth time here.  You get the idea, though, okay?  So that's how you deleted if it has one child.  Now this works if it's the left child or the right child.  And let's just have a look here.  If I wanted to delete node 12, this works the same way except this time I'm going to update  the parent's right pointer, not the parent's left pointer.  So essentially what the algorithm is is find the parent of the node that we want to delete.  Figure out if the node is the right child or the left child of this parent.  In this case, we know that it's the right child.  And then point the parent's right pointer to whatever this node's single child is.  So in this case, the only child is 13.  So we just changed the pointer to be here, remove that, and now 12.  gets deleted. Okay, so that's case two, where we have one child. But case three is when  we have two children. All right, so moving in to case three, things get a bit more challenging,  obviously, because we have two children. So either of the approaches that I just showed you  don't work. So for example, if we're looking at node 11, I can't use approach one or approach  two because there's just no way to do that when we have two different children. So the main thing  we need to think about here when we're trying to solve this is how do we maintain the property  of our binary search tree when we do this removal. Well, there's two ways to do this. The first  way is to locate the maximum value in the left subtree or the minimum value in the right subtree.  So we can pick either of these either the maximum on the left or the minimum of the right,  swap the value of whatever this is that we find with the node that we're trying to delete  and then delete that value that we found using case one or case two. Okay, so let's look at this.  The maximum value in the left subtree would be nine. All right, the reason why we're looking for  the maximum values because we need to maintain the binary search tree property. I can't find the  minimum value because if I found the minimum value and then I were to swap this here, we'd now  break the binary search tree property because nine is going to be greater than eight. So to find the  maximum value in the left subtree, we're just looking for the node that's the furthest right. Now the  furthest right node here is going to be nine. Now notice that the furthest right node will never have  a right child. Okay, so if I have another node here like 10, now this is the furthest right and it  doesn't have a right child. If it had a right child, then whatever node was the right child would be  greater than the node that I was just looking at. So that's an important property. The maximum value  in the left subtree, so the furthest right node, never has a right child, which means it has at  most one child and it could have nine. So in this case, we find nine. Now when we find nine,  what we're going to do is take nine's value and we're going to copy that to node 11. Then we're  going to delete node nine. Now since we know that node nine is either a case one or case two,  has no children or has one child, we can delete it using the methods that I just showed you.  So to delete node nine, all we're doing is setting the parent node, which is the node that we're  actually swapping conveniently, to be pointing to the node the node nine was pointing to. So in this  case, we just get eight. So if we were deleting 11, this was one valid way that we could go about  deleting it by searching for the maximum value in the left subtree, then essentially copying that  data to the node we want to delete and then deleting that node because again, we can delete it  because it's in case one or case two. I know this is complicated. This is probably the most  complicated algorithm we've looked at this far, but hopefully this is making a bit of sense.  Okay, so now how do we delete the node using the second approach, which is finding the minimum value  in the right subtree? Well, again, the same thing applies here. We need to find the minimum value.  Now the minimum value in the right subtree is going to be the node that's the furthest left.  Now in this case, the node that's the furthest left, sorry, is 12. Now if this node had any left  children, so it had like a value like 11, then this would be the minimum node. So same thing applies  kind of in the reverse order here on the right side, the node that's the furthest left or the  minimum node will never have any left children. Okay, so we know that we're going to be in case one  or case zero, sorry, case one or case two is what I meant when we grab this node and attempt to  delete it. So in this case, we find node 12. So we swap this here to be 12 and then we delete node 12.  Now since node 12 has one child, the way we delete it is the same way we just deleted the other  node. So we simply set the right pointer of this node to be equal to 13. So now we have deleted node  11. So both of those deletion processes are valid. Again, either using the maximum and the left  or the minimum in the right and now we have a valid binary search tree. And you can see that the  properties are still adhered to with all of the nodes that are less than being in the left and  all of the nodes that are greater than or equal to being in the right. Okay, so that is how you do  an insertion deletion and what he calls here traversal of a binary search tree. Now how long does  this operation take to run? Well, this is also going to take big O of H time. Now there will be some  additional steps that we need to perform here. Essentially, the first thing we need to do is locate  the node and we also need to locate the parent of that node. Now locating that node will take us  big O of H time and then deleting that node is going to involve finding the maximum on the left  or the minimum in the right sub tree. Now to do that will take us another big O of H time because  for example, we could be deleting the root node. If that's the case, then we need to locate  whatever the node is in the left sub tree of the right sub tree, which could take us again up to  big O of H time. So if we're kind of writing this out more formally, we have one H time operation  to locate the node that we wanted to leave. Then we have another H time operation to locate.  either the maximum node in the left or the minimum node in the right.  And then once we do that, the deletion operation will happen in big of one or constant time, okay?  So that means that we have two H, we can reduce the two here,  and that gives us a big of H time complexity for performing the deletion in a binary search tree.  All right.  So with that said, we're going to wrap up the conceptual aspect here.  And I want to look at just a little bit of code for how we would actually search a binary search tree.  Okay. So let's do a simple example.  You're just writing the code to traverse through the tree just so you have that under your belt.  So let's do a simple example here.  We'll have three, two, one, and then something like five, four, and then seven, okay?  Now this is our root node.  And let's say we want to traverse through this tree and find if a node exists inside of the tree.  Well, how would we do that?  Well, the way that we would write this algorithm is that we'd essentially have some value,  which is the target value that we're looking for.  So in this case, we can actually refer to this as the target, okay?  Now in this case, we can say the target is equal to something like seven.  It doesn't really matter.  Now what I'll do is I'll write an algorithm where we'll start and we'll say the current node is equal to the root node.  We're then going to say, well, the current node does not equal no, we're going to loop.  We're going to first check and see if the current node value is equal to the target that we're looking for.  If it is, then what we want to do is simply return the current dot value or not value.  We can just return that node itself.  It doesn't really matter.  We can return the node.  We can return true.  I'm just trying to indicate that in this situation, we did find the node, okay?  Now if that's not the case, then we can have another if statement here.  And we're going to compare the value of the current node that we're on to the value of the target node.  So we're going to say if the target is greater than or equal to the current dot value,  then current is equal to current dot right because we're going to look in the right subtree.  Now we know that this operation will be okay because the current node is not equal to no.  So we can access the right subtree.  And if the right subtree is no, then that means that we don't actually have this node in the binary search tree, okay?  Then we'll have another if and we'll say if the target is less than the current dot value,  then we're going to do the opposite.  We're going to say current is equal to current dot left.  Okay, so that's our entire algorithm.  This will actually be able to locate any node for us in the binary search tree in big O of H time.  So let's run through a quick example here where we're looking for the target seven.  So when we're looking for target, we start and the current node is equal to three  because we're looking at the root node of the tree, okay?  We say is the current equal to no?  Well, no, it's not.  So we're going to continue to loop.  So we check this first if statement and we say is the current value equal to the target value?  No, it's not.  So we move to the next if statement.  We say is the target value greater than the current value?  Well, it is because seven is greater than three.  So that means current is equal to current dot right.  So now the current node becomes equal to five because that's the right node from the current node.  Okay, now we repeat this process again.  We say while current is not equal no, okay?  So it's not no is this equals the target?  No, it's not.  Okay, is the target greater than the current dot value?  Yes, it is.  So we move to the current node dot right, which is going to be seven.  Okay, so now we check is the current value equal to the target?  Yes, it is.  So we return current, okay?  So that is the binary tree pseudo code for searching through a binary search tree.  And sorry, I kind of said that weirdly, but you know what I mean?  That's the code for actually doing the traversal of the binary search tree in big O of age time.  Now I'm not going to ask you or even show you here how we do the insertion or deletion  in a binary search tree.  But if you want to test yourself and write an algorithm that does that, go ahead with what I just showed you.  You know conceptually what needs to be done.  And you need to kind of problem solve and figure out the code that you would need to write.  Obviously you can access a ton of resources online that would just tell you what the implementation is.  But I'll tell you that if you want to do an insertion or kind of like a creation of a binary tree,  then what you need to do is you need to find where you're going to insert that element,  which will be done using something like this.  And as soon as you get to the situation where you're about to set the current equal to the current dot right  or the current equal to the current dot left, you simply check does this current node have a right node.  If it doesn't have a right node, then that means that you're just going to set the right node to be equal to the node that you're inserting.  And if it doesn't have a left node, then you're setting the left node to be equal to the node that you're inserting.  Because you just found the position where this element needs to go.  Hopefully that makes a bit of sense, but you can kind of test that out on your own and try to write the code.  And then if you want to test that code, you can run through.  Just like I was doing here, and see if that actually works to construct a binary search  tree that has that binary search tree property.  Hello, everybody, and welcome to the next video in this section where I'll be discussing  heaps.  Now, a heap is another nonlinear data structure that allows us to access either the minimum  or maximum value out of some collection of elements in an efficient time complexity.  Heaps can be useful when we constantly need this maximum value or minimum value, and  we can actually use heaps to do things like sorting.  I'll talk about that more later in this video, but for now, understand that we have  two variants of a heap.  We have a max heap or a min heap.  Now, there's a bunch of other versions as well, but for our case, we're just going to  concern ourselves with the max heap and the min heap.  Now, the minimum heap is going to allow us to access the minimum value, and the maximum  heap will allow us to access the maximum value, okay?  So when we draw out a heap, it's going to end up looking something like a binary tree.  So let's say I have a value like seven here.  Now, first of all, this is going to be a max heap, okay?  It's important that you know if we're using a max or min heap because that's going to  change the structure of the heap.  So to the right of seven, we can have a value, say like four, to the left, maybe a value  like three.  Here we have one, two, and for now, we'll just leave it at that a very simple max heap.  Now, the property of a max heap is that every child node of one of the nodes that we  have here needs to be less than that node, whereas with a min heap, it's the opposite.  So with a min heap, all of the children need to be greater than that node.  Now what that means is whenever we look at any single node here, we can treat this node  just like a smaller version of the heap itself.  What I mean by that is that this node here is a heap.  The reason it's a heap is because every single node that's a child of this root node,  if we're looking at this one here, is less than this node, okay?  Same thing would apply over here, over here.  You get the idea.  Hopefully this makes a little bit of sense, but essentially every single node that we have  here needs to have a node that is less than it as one of its children.  Now it doesn't matter if that nodes the left child or the right child, but the way that  we create a heap is that we'll always be creating a complete binary tree, okay?  So notice that as I kind of created this heap here, I didn't randomly go off and add  a value on this side, I did it in level order.  So that's exactly what will happen when you are making the heap, and that's actually  important for the implementation of the heap, which we'll talk about later on.  Okay, so that is a max heap.  Just to give you an illustration of a min heap, let's draw another one on the right side  of our screen, so let me just move this over so I have a bit more space.  So for the min heap, we would have value like one as our root, because this is the least  value or the smallest value in our heap, then we would have values that are greater than  one on the right-hand side.  And then again, we'd need values greater than these values to be to the left and to  the right of them.  So we'd have value like four, and like five, and maybe a value like six.  Now I'm just kind of going in numeric order here, but you obviously won't necessarily  have kind of perfect values like I have here.  Okay, so this is a max heap, and this is a min heap, again, in this situation, all the  values that are children of these nodes are greater than the node itself.  Okay.  So that is the basics on a heap.  Now let's actually talk about how we would implement a heap and some of the kind of operations  that we can do on it.  Okay, so let me erase all of this, and let's create a heap.  So when we make a heap, what we're actually going to use is an array.  Now the reason we can use an array to implement our heap is because we know that we're going  to be creating essentially a complete binary tree.  Now since we have a complete binary tree, that allows us to assume some properties  about the structure of our heap or the structure of our tree, and that means that we can actually  utilize an array.  So let me show you what I mean by this.  Let's just make an array kind of at the top of the screen here that has a few different  slots inside of it, and then let's insert some elements into kind of like a tree structure,  and we'll show you how we would represent them using this array.  So let's just write it at the indices here, because we'll need these in one minute.  Okay.  Create a heap.  In this case, we can do a max heap, so I can have a value like 7, 4, 6, 3, 2, and then  1.  Okay.  So valid max heap again, because all of the children are less than the node that they have  as a parent.  Okay.  So how would we use this array that we have right here to represent this heap?  Well, the way we do this is we place our root node into index 0.  Okay.  The node goes here, and then we're just going to place all of the nodes in the level order  traversal here in the positions in our array.  So we're going to have four, because that's the next node that comes, then we'll have six.  So six goes here, then we'll have three, okay.  Then we'll have two.  and then we'll have one.  So visually, it should be very easy for us to actually  kind of see how this works.  In the first section of our array, we have one element,  and that represents the first level of our tree.  For the next two elements in our array,  that's the next two elements in our tree.  And then the next four elements in our array  would be the next four elements in the tree.  Now using this array like structure  allows us to make a lot of inferences  about how we actually reference our find  to the children or parents of different nodes.  So let me just move this over here  so I have a bit more space.  Okay, so let's say we're looking at this node right here.  So index one in our array.  And we wanna find the children node of index one.  So in this case, that's value four.  Now obviously if we're visualizing the tree,  it's easy for us to do that.  We can see that's three and two.  But how do we do this mathematically  if we couldn't actually see the tree?  Because obviously our code is not gonna be able  to visualize some tree here.  It's gonna have to use this array structure  that we're using to implement the heap.  So if I'm looking at four here,  the way that I find the children  is I use the equation of the following.  I say that the left child,  so actually let's do an uppercase L here  and this is gonna be two, I plus one.  And then the right node is gonna be equal to two, I plus two.  Where I is the index of the node that we're looking at.  So anecdotally, let's just have a look at this here.  We have index one.  We can pass that into the equation here.  So we're gonna get two times one, which is two.  And then plus one, which will give us index three.  So L in this situation, if we're plugging in our value I,  gives us three.  And then over here for R, that's gonna give us four.  Now if we look at index three,  in index four here inside of our array,  we see element three and element two,  which are the child elements for index one or element four.  So this is the equation that you can use to determine  the children for any given node.  Now the reason this works is because we know  that we have a complete binary tree,  meaning there's no kind of gaps in our tree.  And we have two children for any given node.  So you can kinda go through this  and you'll see how it works, right?  So if we're looking at the root node  and we're finding its children, well, this is zero.  So two times zero is zero, plus one gives us this.  If we have the right node here,  that's two times zero, which is zero, plus two gives us two.  Now you just continue this process throughout the array  and you will always find the correct child  for any given node.  So kind of an important thing to understand here.  Since again, this is a complete binary tree  and we know we're filling it from left to right,  we can always use this equation here  to determine the left and right child  of any given node in constant time.  Now in addition, we have the next equation,  which is P, standing for parent, is equal to,  and this is I minus one divided by two,  and then this is a math dot floor, okay?  So let's just plug this in and we'll see why this works.  So if we're looking at five here,  well, we plug in five, so five minus one over two,  that is equal to two, and then we don't need to round this,  but if we were rounding it, then we would just floor this.  So when you see these brackets here,  that stands for floor, which just means round down.  Okay, so that's with the left child.  Let's see an example with a right child.  If we're looking at index four here, okay?  So we take four minus one, that gives us three  over two, gives us 1.5, we floor that, right?  And then that gives us element four here or index one,  which is the parent for this node.  So for any given node, we can figure out the left  and right child of that node,  and we can figure out the parent of that node,  specifically the index of those elements or nodes in our array.  So that's why we use an array for this heap data structure.  Now that we understand kind of how we represent  the structure using the heap,  and we have a way to go from any given node to its children node,  as well as from any node to its parent node,  we can start looking at some different operations  that we can perform on the heap.  So the first thing we should look at  is what happens when we're building a heap  or when we're inserting elements inside of it,  then we will talk about how we delete elements  or access the maximum element from it.  So let me erase this,  and we'll start a fresh example here on the screen.  Okay, so I'm gonna do a bit of a smaller array here,  so we have some more room to draw.  And we'll have a few slots here inside of the array.  Okay, now let's say that for this example,  we're doing a max heap.  All right, so we have our array,  this is gonna be a max heap.  Now let's try to insert some different values  into this heap and see what would happen.  So let's start by just inserting one.  Well, when we have no elements inside of our heap,  this is quite easy.  We're just gonna add this as the root node for our heap.  So we can just kind of make that the root right there.  Okay, next, let's say we want to insert four,  and actually let's insert a larger value,  let's insert something like 10.  So when I insert 10, what I'm gonna do  is I'm gonna place that as the last element  inside of my array.  So just the next kind of space to be filled.  That means the 10 right now will be the left child of 1.  However, the max heap property is not satisfied right now because every node has to have values  that are less than it being their children.  So what that means is I actually need to sift up this 10 node so it now becomes the root  node and then one becomes the child node.  So the algorithm here is we simply take the node, we insert it at the end of the array  and then we look for the parent of this node.  We then check the value of the node we're inserting with the value of its parent.  And if the node that we're inserting is greater than the value of its parent, we do a sift  up operation, which essentially means we just swap the values.  So that means that now 10 will become the root node.  So let's draw that in here and one will become the end node or the leaf node.  Let me just put this in the center.  Okay.  Now let's say we're inserting the value for, okay.  So I want to insert for I put that at the end of the array.  Now that means that right now it's going to be kind of represented as the right child  of 10.  What I do is I look at my parent node, which is 10 and I say, okay, am I greater than or  less than this?  Well, I'm less than this, which means there's no operation I need to do because the heap  property will be satisfied.  Perfect.  Now let's say we want to insert three.  So I insert three at the end.  That means three is kind of now here, right?  And then I need to check the parent node of three and see if I'm greater than the parent  node.  So just a recap here, by the way, to find the parent node for this element in the array  we would have done P, which is parent is equal to.  And then this is going to be three minus one over two, which is going to equal one.  So this will be the parent node.  So that's what we're comparing to.  Okay.  So now we need to perform our swap because we see that we are greater than that.  So we have three and one, which now means we do the swap here and we have three and  one.  Okay.  Now we continue the process.  So now let's insert the element 11.  Okay.  When I insert 11 here, now the same process is going to continue.  I need to check the parent node.  Now, in this case, we know the parent's going to be three.  So I have 11 here and I check the parent node.  I obviously am greater than the parent node.  So what I need to do here is sift this value up and swap it with the parent, okay?  So I do that.  So now three comes here and 11 comes here.  However, I'm not done yet.  And the reason I'm not done yet is because at this point, I actually need to now check  the parent of this node and see if I need to continue sifting this value up in my binary  heap or in sorry, this heap is kind of referred to as a binary heap because we have two children  nodes.  We can have three, four, etc.  Children nodes as well.  In this case, we're just doing two.  All right.  So again, we're now here.  We've done this first sift up operation.  But since this node still has a parent node and we haven't yet checked that, we now need  to check that parent node.  So we now check the parent node.  We see it's 10 and that means we do actually need to do a swap.  So now we're going to swap this so this becomes an 11 and this becomes a 10, okay?  So let's rewrite this in our array.  So we have 10 and 11 and now the binary heap property is satisfied where every single  node has values that are less than it in the heap.  Okay.  Let's do one more just to make sure we're clear.  Let's insert 12.  So we insert 12 at the end of the array.  So currently 12 is here.  Now we check the parent.  Well, how do we get the parent?  Well, we take five minus one over two, which is equal to two.  So that means the parent is four.  So we now compare to four.  We say we are greater than four.  So we do our swap here.  Okay.  So this is now 12.  And this is four.  So four and 12.  Okay.  Now we're not done yet because this node has a parent.  So we now need to compare to the parent node.  We see that the parent node is 11.  That means we are greater than the parent node.  So again, we do the swap here.  So now this becomes 12.  This becomes 11.  So we come here 12 and 11 and the binary heap property is still satisfied.  All right.  So that is essentially how you create or insert elements into a heap.  All right.  So we simply add it as the last element.  And then we sift this element up in the heap by continually looking at the parent element  until we get to a situation where there's no parent elements or we are less than the  parent element.  Okay.  There you go.  That's the insertion process.  Now let's talk about the time complexity for this.  Well, the time complexity for this is actually going to be log base two of n.  So the reason why this is the time complexity here is because all we need to do when we're  doing an insertion is sift this node up.  And the number of sift operations that we need to do is always going to be a most log  base two of n where log base two of n is actually equal to the height of the binary tree.  Now the reason why that's the height is because we have a complete binary tree.  So we know we're always inserting elements in this level order, right?  We're never having the log base two of n.  on the linked list structure where we have only elements on the right or the left side,  we know we're always going to have this perfectly balanced tree.  So since we have that, we can assume that log base 2 of n is h will always be correct  in that assumption, which means that we can write either the time complexity as big  o of h or just log base 2 of n.  Now log base 2 of n is more correct, so we're going to write this instead.  And again, that's because every single node has two other nodes.  So as our tree gets larger and larger and larger, the operation actually becomes even  more efficient for us to either insert an element or to do some other operations that  we're going to talk about in a second.  So hopefully you can understand why this is log base 2 of n.  It's because log base 2 of n is equal to the height of the tree.  That means that we have to do a maximum of the height of the tree operations when we're  doing an insertion because we're simply looking up to the parent every single time and  doing that sift operation, which happens in constant time.  Okay, so that is doing and insertion.  Now that we've looked at an insertion, what we need to talk about is how we do a removal.  So when we're viewing a heap, typically the purpose of the heap is to constantly be  removing or looking at what the maximum value in the heap is.  Now, the maximum value in the heap is always going to be the root node or conversely the  minimum value will always be the root node, depending on if you have a maximum or minimum  heap.  So if we want to access what the maximum value is, well, we can do that in constant time  because that's the root node.  However, when we remove this node, which quite frequently we're doing, so we're popping  this off of the heap, then that means that we actually need to essentially rebuild the  heap here, such that maintains this property.  So now if I want to delete and retrieve this node off the heap, what I actually do is  I take whatever the last value is in my heap, which in this case is four.  And I make that the value of the node that I'm deleting, which in this case is the root  node.  We're only ever deleting the root node, right?  So we make that four, then we delete this value here.  So if I'm doing this in my array, I'm deleting that last value and setting that equal to the  root node, which then essentially removes whatever the last root node was, then I perform  pretty much the opposite operation that I was doing when I was sifting up.  Now I'm going to sift down.  So all I do now is I have this node and I look to the left and to the right and I figure  out whatever the maximum value is to the left or to the right.  So I look at both 10 and 11 and first of all, you see, okay, are either of these values  larger than me.  Well in this case, yes, they are.  That means that to satisfy the heap property, one of them is going to have to come up here  and I'm going to have to swap with them.  And then continually, I need to find the largest one of these two values because if this  value now becomes the new root node, then that means that whatever value is the existing  left or right child needs to be smaller than that node.  So in this case, we look at 10 and 11.  We see that 11 is the largest and 11 is larger than us.  So we perform a swap here downwards.  So now 11 comes up here and four comes here.  So now for writing this in our array, then we're going to take the 11 here and erase that  that's going to become four and 11 is the new root node.  Now we can continue this process and remove all of the elements from our heap.  In fact, let's do that.  So now we want to remove 11.  So what we do is again, we take our last node.  In this case, the last node is going to be three.  So we take three.  We put this up here.  And then we delete three.  So we get rid of that from over here.  And now we do this sift down operation.  So I look to the left.  I look to the right.  When I look to the left and the right, I find the maximum value.  I see if that value is greater than I am.  So I see 10.  So I now need to swap with 10.  So 10 comes up here.  And then what was this?  Three comes here.  So we'll do that swap three and 10.  But now that I've moved the three here, I need to continue sifting this downwards  to ensure that the left and right tree are still going to maintain this max heap property.  So I look now to the left and right child of three.  And I say, okay, are either of these children greater than me?  Well, they're not.  So that means, okay, we're good.  The max heap is satisfied.  However, if for some reason we had like a seven here.  So let's just swap this out.  So change one to be a seven.  Now we would need to do the swap again.  Okay.  So then seven would come here and three would come here.  So we'd swap that.  So this is three and this is seven.  Okay, then we can continually keep doing this process and removing all of the elements.  I won't go through all of them.  I hope you get the idea now.  Okay, so now that we've looked at that, I just want to quickly write some pseudo code that  would show us how we actually perform the insertion of elements inside of our heap.  Then we're going to talk about a heap creation and then we'll pretty much be done.  Okay.  So again, we have some array here.  I'll just make it a little bit smaller for this example.  And we want to write some code that allows us to insert elements inside of our heap.  Well, we have the array.  We can call this array something.  like a. Okay. So let's write the code to do the insertion. All right. So for a code,  the first thing we're going to do is we're going to say a dot push, then whatever this value  is, then we're going to get access to whatever the last index is. So we're going to say  I is equal to a dot length minus one. Okay. Now that we've done this operation, what  we actually need to do is we need to write some function called heapify. Now this is  just typically what it's called. You can call this whatever you want. So I'm going to  say function heapify. And heapify is going to take some index. Now what heapify will do  is perform that sift up operation from whatever index we pass. So what we need to do for  the sift up right is we need to look at the parent and we need to check if the parent  is greater than the current value. Now again, this will change if we're doing a max heap  operation or a min heap. So what we'll do here is just assume that we are doing a max  heap. So this function could be like max heapify. Okay. As opposed to min heapify. So  first thing we're going to do is get the current value. So we're going to say val is  equal to a at index i. We're then going to say the parent node or the parent index is  equal to. And then this needs to be i minus one divided by two. And then we're going  to floor that. So I could write math out floor, but we'll just indicate this is being  floored. Okay. Now we need to check the value of the parent. So we'll say p value is  equal to and then this is going to be array at index p. And then we need to check if this  value is greater than the p value. So we're going to say if val is greater than the p value,  then we need to perform this swap and then we need to heapify on the parent index. So  before I swap, we're going to do the following thing. We're going to say that array at index  i array at index p is equal to and then we just do the reverse array index p and then  array at index i. Now I'm just writing some kind of shortcut code here. This won't actually  work. If you use this in JavaScript, I'm kind of writing some variant of like Python  code. Then what we do here is we're going to call the heapify function again, except  this time, we're going to do it at the parent index. Okay. So if the value of our node  that we're inserting is greater than the value of our parent, then we need to move that  upwards. So to move that upwards, we simply swap the values at these two different positions.  Okay. So we're swapping the parent value with the node that we're inserting value. Then  we need to repeat this process. But this time we're going to heapify on the parent node.  So just quickly looking at a tree here. Okay. So imagine we're inserting some node here.  Well, we swap that with the parent. Then once we swap that with the parent, we need  to check now if this new node needs to be swapped with its parent. So that's why we  are recursively calling the heapify function. Now this heapify operation runs in big O  of log base two of n. Okay. So just remember that where n is the number of nodes that we  have inside of our heat. So hopefully that makes a bit of sense, but that is heapify.  Now if you're going to be removing or extracting the maximum value, that pseudocode is a  little bit more complicated. I'm not going to write that for you right now, but I just  wanted to show you some basic code here for performing this operation, which is the insertion  into the heap. Okay. So now that we've looked at that insertion, I'm just going to quickly  mention that we can actually build a heap by just continually inserting different values.  Now this is not the most efficient way to go about creating heap, but let's say I have  n elements. Okay. And maybe this is just an array that contains some randomly ordered  elements. If I want to sort these different elements, then what I can do is I can use  a heap. So what I'll do is for every single element. So for every n, I'll perform an insertion  into my heap. And that's now going to give me a heap that contains all of my elements  in this kind of heap structure. Right. So what happens is I will perform the insertion  for all of these. And that's going to take me big O of n log n time log base to event.  Now the reason that's going to take n log n time is because the heap of fire operation  that we're performing every single time we do an insertion is going to take log base  to event time. We have n elements we want to insert into the heap. So we say n multiplied  by log base to event. So that's how long it takes us to insert every single one of these  elements inside of the heap. But now that we have them in the heap, so we'd have all  of our elements inside of the array heap here, we don't actually have them in a sorted  array. If we want to get them in a sorted array, then what we need to do is just continually  extract every single value out of our heap. So we're constantly getting that maximum value  from our heap and then insert that into an array. So imagine we have some heap.  Right. So seven, this needs to be less than six, four, we're just doing a very basic  heap here. And then we want to get all of the elements from our heap to be in a sorted  array. Well, all I do is I grab the maximum value. So I take the maximum value, I insert  it here in the array. Then once this is removed, we would have sifted up six, right? Okay.  So six comes here. Then we extract the next maximum. So six comes here. Then we extract  the next maximum. So four comes here in a new array. And now we have built a sorted  array using this heap structure. Now this is actually one of the more popular ways to  go about sorting something. This algorithm that I just showed you is called heap sort.  We put everything inside of a heap, then we extract all of the maximum or minimum values  we can do again, a min or a max heap from the heap and then push all of those values  in the order in which we extract them into a new array. Now that gives us a sorted array.  And that operation takes two multiplied by n log base two of n time. The reason this  is two multiplied is because the first thing we need to do is push all of the values in  the heap, which takes n log n time. Then we need to extract all of the values from the  heap, which takes again n log base two of n time. So we multiply it by two, but we know  the constant still matter. So we remove that. And that gives us the big on notation of n  log base two of n to sort an array using a heap. Okay. So let me just kind of recap some  of the operations here to do an insertion into a heap that takes log base two of n time  to do a extraction operation where we get the maximum value that takes log base two of  n time to create a heap that takes n log n time. And if we want to sort using a heap again,  that's n log n time. Okay. So a heap is an efficient data structure when we constantly want  to access or update some kind of maximum or minimum value retrieving any arbitrary element  isn't really useful to us. We don't do that with a heap and we can implement the heap  using the array data structure. Hello everybody and welcome to the next video in this section  where I'll be discussing graphs. Now a graph is another nonlinear data structure that  allows us to represent some more abstract data. Graphs can represent something like road  systems, right, where we have different roads going between different cities, locations,  et cetera. And traversing those roads or traversing this graph in this case can allow us  to figure out something like the shortest path between two different cities. Additionally,  we can use graphs to represent something like the exchange rates between different currencies.  I know that seems like a weird concept, but there is actually a way to use a graph to  do that. Regardless, graphs are very flexible. They're used all over the place in computer  science. And the goal of this video here will be to give you a high level overview that  explains most of the key terminology and types of graphs so that you're familiar with  them. We're not going to get too much into implementation. Later on, we will look at  a few graph algorithms. And when that happens, I'll start showing you how we can actually  do some operations on graphs and talking to you about the time complexity of them.  For now, though, let's talk about some basic graphs. Okay, so definitions here, a graph  is made up of two sets called the vertices and the edges. Now a vertex or vertices is  like a node, and it can be connected to other vertices by edges. So I'm going to use node  and vertex interchangeably, typically in graph theory, you refer to this as a vertex,  or really it's the same thing as a node, just like when we talked about our binary  trees. Okay, we then have an edge. Now an edge is a connection between a pair of vertices  or nodes. So we may have an edge between vertex A and vertex B. Now an adjacent vertex is  a vertex that is connected to another vertex via an edge. So if you have a direct edge  between two vertices, they're said to be adjacent. You can also say these are neighbors,  okay? So those are the main definitions. All right, so let's look at a graph example  here. This is an example of a graph. We have a few different nodes or vertices, and then  we have some edges. So first of all, what are the nodes? Well, let's have a look here.  So we have the vertices or nodes, which are one, two, three, four, five, six, okay? So  all of the elements that actually make up the graph. And then we have our edges, and these  are all the different edges that exist in the graph. So we have an edge from one to three.  Okay, we have an edge from three to five, an edge from one to two, one to four, from two  to four, three to five, four to six, and four to five. Okay, so just kind of reading through  them here. Now notice that the way I represent an edge is a set of parentheses with one node  here on the left side, another node or another vertex on the right side. That means we have an edge  between these two different vertices. Now if we switch the order, so we have like three and then  one, in this case, that's totally fine, because we're looking at an example of something known  as an undirected graph. And we're going to talk more about that in a second. But for now,  I just want to note that I wouldn't necessarily duplicate the edge one three. So I wouldn't write  one three and then three one. I just write one three because it's implied by this type of graph.  If I can go from one to three, I can go from three to one, okay? So basic example of a graph.  All right, types of graph.  We have undirected graphs, directed, unweighted, weighted, cyclic, acyclic, and disconnected  sorry graph.  Now, I'm going to go through all of these different types here, but it's important to  understand the different types of graphs because based on the problem you're faced with,  if you know the property of a graph, it can actually allow you to solve whatever the  problem is in a more efficient time complexity.  So it's one of the main things you'll kind of see here as we go through this section,  whereas we've been going through this section, is that when we know certain properties  of our data structure, we are able to craft more efficient algorithms by using assumptions  that we can make about that data structure.  Okay, so undirected graph, a graph in which the order of the vertices in the edge set does  not matter.  i.e. an edge of 3, 2 can be written 2, 3 without affecting the graph, the edges are  bi-directional.  So same graph we looked at in the previous example, in this case it's undirected because  we can travel both directions across an edge, go and go from 1 to 3, we're 3 to 1, 1  to 4, 4 to 1, et cetera, that's all it means when it says undirected.  All right, moving on, we have a direct to graph.  Now this is a graph in which the order of the vertices in the edge set does matter.  The edges are directional.  So in this case we have an edge from 1 to 3 and that ordering actually matters.  It's not an edge from 3 to 1, it's only from 1 to 3.  So if I was on 3, I cannot go back to 1, I can only go to the directed edges or cross  the directed edges and go to 5 or go to 4, okay?  So important to understand here the difference between directed and undirected, typically  if you're drawing a graph, your directed graphs will just have arrows which indicate the  direction of the edge.  Next we have an unweighted graph.  Now an unweighted graph is a graph in which there is no size or weight associated with  the edges.  It can be directed or undirected.  So both of these examples here are unweighted edges and what that means is that we would  imply that the distance or the size of every single edge in the graph is the exact same,  meaning we don't need to consider that size hence why it's unweighted, okay?  So that's an unweighted graph where we don't have labels or weights slash sizes on the  different edges.  Next we have a weighted graph.  Now a graph that is weighted has, sizes or weights associated with the edges.  So if we're looking at the example of a road system, then these might be the distances  between different cities, right?  So each edge represents a road and the weight or the size on that edge represents the  distance between the two different cities.  Now when we draw a graph, we typically don't draw it to scale.  So in this case, you can see I have an edge weight of seven here, but then I have another  edge that's actually larger or longer than that edge, but has a smaller weight.  That's completely fine.  Typically, again, when we draw the graphs, we just kind of label them here.  We don't try to make them actually to scale with what the weights of the edges are.  Hopefully, that's making sense, but unweighted, no labels on the edges, weighted.  We have these labels or the sizes slash weights on each of our edges.  All right, moving on, we have a cyclic graph.  Now this is a direct graph in which at least one cycle exists and a cycle is a path along  the directed edges from a vertex to itself.  So if we're looking at this graph right here, we can see that we have a cycle because  we can go from one to two, two to four, four to three, and then three back to one.  Since from this vertex, I can follow a set of directed edges and get back to this vertex  that means I have a cycle.  Now this property of a graph can become important in certain algorithms because if you know that  you have a cycle, it may actually disallow you from using a specific solution due to the  fact that you may be infinitely kind of moving in this cycle.  On the contrary, if you know you have a cycle, you may actually want to be looking for the  presence of that cycle, and there's different ways that you can do that.  Anyways, this is a cycle that we can see right here.  Now the reason why we're only looking at directed graphs here is because if you have an  undirected graph, then technically, you always have a cycle.  The reason for that is that if I can follow any edge in both directions, then if I have  an edge between two nodes or vertices, I always have a cycle between that edge and those  vertices.  For example, if this edge between four and three was undirected, I can go from four to three,  from three to four, from four to three, back and forth, back and forth, back and forth,  so that always makes a cycle.  So when we're talking about cyclic graphs, typically we're talking about a directed graph.  Now look over here, we have another cycle.  This one's a little bit harder to spot.  We can go from one to two to four, back to one, okay?  So this is a cycle that contains these three sets of edges.  We also have another cycle from one to three to four, back to one, and we could introduce  many more cycles if we added more directed edges.  Okay, next we have an aciclic graph.  Now this is a graph in which no cycle exists.  A cycle, again, is a path along the directed edges from a vertex to itself.  So in this situation, it might look like we have a cycle, but here if I go from one to  two to four, then I stop.  If I go from one to three to four, then I stop.  There's no cycle here, no way for me to get from one node back to itself.  Okay, next we have a disconnected graph.  Now a disconnected graph is a graph that contains at least one...  and vertex that is not connected by an edge.  So pretty easy to spot this if you're looking at the visualization,  but in this case, the re is disconnected.  And over here, two and six are both disconnected from this graph.  OK, moving on, we have graph representations.  Now, there are multiple ways to represent graphs within a computer program.  Some representations provide more efficient access to the edges, vertices, et cetera.  And the two most popular representations are in adjacency matrix  and in adjacency list.  Now, we just looked at visual representations of the graphs, right?  Well, we're kind of drawing them out.  However, we need a way to actually represent these in our computer program  such that we can traverse the graph and we can look at the different edges and nodes  that we have inside of it.  So that's why we're talking about these two representations.  Now, for now, just understand what these representations are.  Obviously, I'll go through them in one second and be able to look at a graph  and write the corresponding representation or vice versa,  look at a representation and then write the corresponding graph.  You'll see that it's not over the complicated.  Let me show you the two different representations.  OK, so adjacency matrix representing an undirected graph.  Now, first of all, you can see that we actually have an edge  story that is going between the same node.  That's valid, and in a lot of cases, you can have that, OK?  So I just wanted to kind of show that to you in this example.  Regardless, we have an adjacency matrix here.  And this matrix represents the graph that you see on the right hand side of the screen.  The way it works is we have a two-dimensional array,  which we sometimes call a matrix, that is a square size.  So its size is going to be equal to the number of nodes for the width  and the number of nodes for the height.  So if you're going to calculate the total number of elements you have inside of here,  it's going to be n squared or v squared,  where v is the number of vertices, OK?  So in this case, we have four nodes or four vertices.  So that means that we have four columns and four rows.  All right, so if we go through this here,  we can see that we have ones and zeros.  Now, in an undirected graph, a one is going to represent that an edge exists  between the two nodes that are at the column and row position.  So in this case, we have a one for a a.  That means that we have an edge between a and a, right?  Which is what we can see right here.  Continuing to move over, we have a in our row, b in our column.  That means we have an edge from a to b.  So we do have an edge there, a to b, OK?  Now we go to c, we have an edge from a to c  because we have a one there.  So that means there is an edge.  Go to d, we have an edge between a and d,  and we can see that edge, OK?  Going to b now.  So now we're in the next row, we're looking at b and then a.  So from b to a, there is an edge.  Again, this is because it's an undirected graph.  So we're going to essentially be duplicating the edges  as we write them in this adjacency matrix, OK?  Next, we have b.  So there's no edge between b and itself.  No edge between b and c, and no edge between b and d.  So we put zeros there.  Moving on, we have c and a.  So again, we can see we have an edge from c going to a,  and then from a going to c because this is undirected.  You could continue going through this,  but you can see that this represents the graph  on the right-hand side.  That's how we use this for an undirected graph.  OK, next, we have a directed and weighted graph.  Now, you could obviously just have directed or just have  weighted, but in this situation, the matrix looks  a little bit different.  So here, you can see that now rather than just putting ones,  we're actually putting the weight of the edge  between the two different vertices.  And we have a directed graph, meaning  we are not duplicating these edges,  we're only writing the edge one time.  So if I'm looking at a here, you can see there's no edge  between a and itself.  There is an edge between a and b,  and that edge has a weight of 5.  So that's why I indicate 5 here.  Between c, no edge, between d, there is an edge.  So from a going to d, right, that's kind of how we're  reading it here, from a going to d,  we have an edge that has a weight of 3.  Now, you could read it in the opposite order  if you want to, but you have to pick what order you want  to read it in.  So in this case, I'm reading row first, then column.  That indicates I have an edge from the row element  to the column element, okay?  Not the other way around.  That would be incorrect for this specific graph.  Anyways, going to b, you can see we have an edge  from b to d.  So if we look at that, that has a weight of 2.  From c, we have this edge from c to d,  that has a weight of 1.  And then from d, we have an edge going to c,  which has a weight of 4.  So again, as I was saying, you should,  after kind of looking at this PowerPoint slide here,  be able to look at an adjacency matrix  and draw the corresponding graph or vice versa,  look at a graph and write the adjacency matrix for it.  Okay, next, we have an adjacency list.  Now, an adjacency list is different than an adjacency matrix.  It has some different time complex,  these when it comes to accessing the different edges  and accessing the different vertices that are in the graph,  we're not going to get into that right now.  As you can see here, what we have is a set of nodes, okay?  So in this case, I have node A, node B, node C, and node D.  Now, they all have a linked list associated with them  that represents all of the...  the different edges that exist inside of the graph.  So in this case, I have my node A or my vertex A.  It then points to a linked list.  This linked list could be empty  or it could contain a variety of different edges.  In this case, it has all of the nodes  that it has an edge with  because this is an undirected unweighted graph.  So in this case, we have an edge from A to B,  A to C, A to D, and A to A.  And again, this is a linked list  just like we talked about in the previous sections.  Going to B, we have an edge from B to A.  So that's the same as our edge from A to B, right?  We just have to write that twice  because this is an undirected graph.  Now same thing for C.  We have an edge going to A,  just like A has an edge going to C,  and then we have an edge going to D.  And then from D, we have an edge going to A,  and then an edge going to C,  again, undirected unweighted graph.  Okay, next, looking at a weighted and directed graph.  So when we have a weighted and directed graph,  then that means that we have this linked list structure again,  except every single node we contain in the edge list  for any given node, we have a weight associated with it.  So in this case, we have A that has an edge to D.  So we can see that edge right here.  It has a weight of three.  So we indicate three.  We then have an edge going to B,  that edge has a weight of five.  So we indicate five,  and you get the rest, you can see kind of how we represent this here  using the adjacency list.  So with the adjacency list here,  you can see that when we don't have that many edges,  this can actually be a more efficient way  to access data than using the adjacency matrix.  So in this case, only a five edges, right?  If I go back to my adjacency matrix,  you can see that we have so many zeros inside of this matrix.  So we're kind of wasting quite a bit of space here  when we don't need to be doing that.  And then when we come back to the adjacency list,  you can see that this is very space optimal  because we're only storing the necessary edges that we have.  We're not storing all of these kind of zeros  in positions inside of that matrix.  So there's all kinds of advantages and ways  to use these different representations,  but these are very commonly seen.  So I just wanted to introduce them to you  so that you understand kind of how they work  and you're not lost if you see them.  So with that said,  I'm pretty much going to wrap up this video here.  I know this was fast.  There's a lot that I can go through on graphs,  but I want to save that until we actually get into  some of the graph algorithms,  and then I'll show you some basic implementations  of those algorithms,  and you'll see how we can use these different representations  in the relative space and time complexity on both of them.  Now, space complexity is not something  we've really talked about this far,  but just like we have a time complexity  where we're looking at the running time of algorithms,  we can also analyze the relative amount of space  that these algorithms will take,  which is kind of why I was hinting at that  with the adjacency list for the adjacency matrix,  the adjacency list in this situation  is more space efficient than the adjacency matrix.  Hello, everybody,  and welcome to the next video in this section,  where I'll be discussing hashing.  Now, I'm just going to give you a basic introduction  to this topic.  This can get extremely complicated  and extremely math heavy.  It's not the goal here to confuse you.  It's to simply introduce you to what a hash is  and how this is used as the basis  for some different kind of data structures  that we'll have a look at in various programming languages.  Okay, so let's begin by talking about what hashing is.  Well, hashing is actually a very simple concept.  It's taking some data,  passing it to some kind of function,  and then getting some kind of unique output  which we refer to as the digest or the hash.  Now, what this allows us to do at a very high level  is take maybe a very large piece of data  or a small piece of data  doesn't matter what it is,  pass it to some function  and get some kind of uniform output  that represents that data uniquely.  Now, hashing is used quite frequently  in things like cryptography,  cryptocurrency, digital security, password security.  There's a lot of kind of implications  and use cases here of hashing,  but in our instance,  we're talking about hashing in relation to data structures.  So we're not too concerned  about the security component of hashing,  we're more concerned about how we can use this process  to efficiently access different pieces of data.  So let me just give you a more concrete example here.  Let's say that I have some string, okay?  Maybe a string like high.  And then I pass this to what we refer to as the hash function.  Now, this hash function can be a million different things.  There's all kinds of different ways to hash data.  But really, what this is gonna do  is spit out to us some kind of number,  some kind of string, some kind of uniform output  based on some criteria that we want.  So the different hash function we use  will give us kind of a different value.  But maybe in this instance,  it's always going to give us a four digit number, okay?  So something like four, seven, three, two.  And then if I pass in a different value here, like yes, okay?  Then this is gonna give us a different value, okay?  Four, three, nine, seven, whatever it may be, okay?  I'm just using some random examples here.  Now, one of the important properties about this hash function  is that every time I pass in some input,  I always get the exact same output.  And typically hash functions,  going to generate unique outputs,  which means every single input has a unique output.  So, hi, and yes, we'll never map to the same value.  Or, hi, and any other given string,  never map to the same value.  Now, that would be an example of a perfect hash function.  That doesn't necessarily exist.  There's a lot of instances where you can have  something known as a hash collision,  which means you have two different values  that, for some reason, map to the same output.  Now, that's not ideal,  and that causes some problems,  and there's a resolution strategy for that.  However, I just wanted to give you this premise here.  So, the idea is you take some input,  you pass it to a hash function,  and it generates some unique output for you.  And the idea is that every single input  will give you a unique output.  So, again, in an ideal scenario,  you never have two inputs mapping to the same output.  Okay, so with this in mind,  let's see how we could use something like hashing  to improve the efficiency of different operations.  So, let's imagine that we have some array here  on the right-hand side of our screen.  And for some reason, in my array,  I want to store key value pairs.  So, I'm going to something like a property associated  with a value like we have in a JavaScript object.  So, maybe I want to store the key X.  Now, I want that to be stored with the value seven.  Okay, if that's the case, I can pick an arbitrary index  instead of this array and store it in here.  So, maybe I store something like X and then set.  Okay, it doesn't really matter where I'm storing it.  Now, if we're just using a standard array here,  what that means is that if I ever want to retrieve  the value associated with the key X,  I need to iterate throughout most every single element  inside of my array to retrieve the location where X exists  and then get the value associated with X.  Meaning, this lookup operation takes me big O of N time.  Now, same if I want to delete this, right?  I need to find where it exists and then remove it  and that takes me big O of N time.  Now, what if there was a faster way?  What if for some reason I just knew what this index was  without having to look through the entire array?  Well, that's where hashing comes in.  So, I'm going to give you a very, very simplistic example  of this.  Keep in mind, there's a lot more details  that I'm not really showing you here.  But let's imagine that now what we do instead  is we take X and we pass it now to a hash function.  And then this hash function actually spits out to us  an index.  And this is where we should store the key and value  associated with X.  So the index could be something like, actually,  let's not do seven because that doesn't exist in our array,  something like four.  So now we've passed that key X and that's given us an index.  So we're going to store the key X and the value seven  at index four.  Now, let's say I want to retrieve the value associated  with the key X.  I don't know necessarily what that is.  Well, I just repeat this same process  by passing my key X to the same hash function.  And that now tells me the index where X exists.  So now what I'm doing is every time I'm  inserting a value, I'm first passing it  to that hash function, that hash function  is computing a unique index for me to store that value in.  And then I'm taking that value and I'm  storing it in that index.  So now, anytime I want to retrieve something,  all I need to do is use the hash function.  And it essentially tells me where inside of my array,  this element exists.  And if the hash function works perfectly,  then that means that this runs in constant time.  Because the hash function will be very, very fast to compute.  That's one of the main properties of a hash function  is that it's very quick to compute.  So that is the very perfect situation  when we talk about hash, where we have, say,  an unlimited amount of space, an unlimited number  of indices here, or memory address locations, whatever  you want to use.  You take some value, some key in this instance,  you pass it to a hash function, and that now  tells you the location of where this element exists.  And if it doesn't exist, then you insert it into that position.  And that also means that we can check if something exists  in constant time, too, right?  Because if this gives me, say, index 1,  and I have a look at index 1 here, and there's nothing there,  that means, well, I know this doesn't exist.  So when we talk about data structures like sets and hash  maps, or maps in Java, or it's not JavaScript,  these are typically using some form of hashing in the back end  to actually allow us to do things like add, remove,  and check if something exists in constant time.  OK.  Now, the issue, though, is that we don't always  have a perfect hash function.  In fact, it's very likely that, depending  on the number of keys that we're using,  that two keys end up mapping to the same index.  So in the situation in which, say, maybe both x and y  map to the index 4, now we have a bit of a problem, right?  Or if they map to, let's do the index 3.  If they both map to the same index,  then that means that we have to come up with some kind  of resolution strategy.  Where we first look at the index, we say, OK, well,  is it the key that we pass to the hash function?  And if it's not, then we need to.  generate a new hash. Now to generate the new hash, we have to change the input slightly  by adding something to it or removing something from it so that we get kind of this unique  index for it. Okay. Now, I'm not going to talk about exactly how that's done. That's  fairly complicated. But that's just what I wanted to introduce to you here. That doesn't  always happen perfectly. And if you have something known as a hash collision, which means two  inputs map to the same output, then you need to do something that will cost you a little  bit more time. So even though typically you're going to assume that when you use a hash  map or a set, which are the two kind of data structures that implement hashing that you're  going to run in constant time, it is possible that you can take slightly more time depending  on the type of the inputs that you have, what you're outputting, the amount of memory  you have, and if any hash collisions occur. All right. With that said, I'm going to wrap  up the video here. I know this was not a comprehensive overview. I just wanted to get  you thinking a little bit about this topic and give you the basic premise of what hashing  is. Hopefully you understand that. I look forward to seeing you in the next video."
KXjccJm-06I,You need to follow a system...,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-28T09:14:39Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/KXjccJm-06I/default.jpg,https://i.ytimg.com/vi/KXjccJm-06I/hqdefault.jpg,PT57S,15551,484,17,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"not using a system or following a framework.  Now it is already very difficult  to subjectively speaking to answer these types of problems.  There is a reason why senior engineers  fail technical interviews.  It's not because they're not a senior engineer.  It's simply because they didn't study enough.  If you go into this interview  and you don't have a framework or a system  that you're going to use to answer this type of problem,  you very likely just will fail,  even if you are extremely smart.  Now just to quickly give you the gist of it,  you clarify the problem.  You look at the different edge cases that could occur.  You come up with a basic plan.  You start writing the code.  You evaluate the code for its performance.  You compare it to different solutions.  But the point is, this is something that you can memorize  and that you can just follow  when you go into the interview.  You know, okay, no matter what question I get asked,  even if I don't fully understand it,  this is the first thing that I do.  And having that framework allows you to reach your interview,  go through a consistent process  and shows that you know what you're doing.  If you have this, even if you fail the problem,  you will make progress  because you will at least have progressed through  what you should be doing."
sCiD-Wzj9P0,Watch this video if you're a developer!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-27T17:43:21Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/sCiD-Wzj9P0/default.jpg,https://i.ytimg.com/vi/sCiD-Wzj9P0/hqdefault.jpg,PT1M26S,22017,964,13,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"single responsibility principle or SRP is that a class should only have one reason to change,  meaning it should only do one thing. So if a class were to handle multiple responsibilities,  it becomes harder to maintain and harder to modify. So by separating concerns into different classes  or functions, we make our code cleaner, easier to test, and much more scalable. So you can see I have  some problematic code right here. Now you can see that this code is doing multiple things,  and it's not really clear what it's actually supposed to be doing. So here it says that this is  an authentication service. So we would assume that what this is responsible for is simply authentication.  So something like logging in, well that makes sense, but logging an event doesn't really make sense  to be doing inside of the authentication service. We may want to log something, but we shouldn't  have the implementation of our logger directly inside of this class. So how can we fix this?  Well, we can write some code like this. So notice that yes, the code is a little bit longer now,  but what we've done is we've added two classes, an auth service, which we had previously,  and the logger class, which now takes over the implementation of logging events. So if we zoom in  here, you can see that the logger simply takes this method, it defines the log file, and then in our  authentication service, we actually take an instance of this logger, and then we can use it within  the logger method. So this way we've kept things separate. Each class has a single responsibility,  and if I want to change what the logger is doing, it's very clear where to do that. I change it  inside of the log."
KP42CpCCGmo,This is a huge red flag if you're a programmer...,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-26T18:58:13Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/KP42CpCCGmo/default.jpg,https://i.ytimg.com/vi/KP42CpCCGmo/hqdefault.jpg,PT58S,21354,669,20,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"not being fluent at writing code.  Look, if you tell me that you're a senior Java developer  and we get in the code editor or we go on the whiteboard  and you start writing Java code  and you don't know what a for loop is  or you can't remember the syntax to an if statement,  yes, this has happened many times to me actually,  I'm immediately just gonna assume that you're lying to me.  I've written millions of lines of code.  If you ask me to write Python code,  I don't need to look up the syntax,  I don't need auto complete,  I don't need cursor to generate it,  I know how to write it  because I actually write Python code.  So if you get into a coding interview and situation  and you don't know basic syntax,  that's an immediate red flag.  So you need to be fluent with your basics in the language  and that means that when you're practicing,  practicing without AI,  practicing without auto complete,  writing code by hand from scratch on a whiteboard.  That's the best way to get good at this  and personally before I went in for my Microsoft interviews,  I spent two weeks doing a whiteboarding  where I would answer every leak code question on the whiteboard,  then I would type it out, see if it compiled  and kind of fixed any of my errors."
pzcbRNLNkhY,My honest advice to aspiring software engineers,"Get Job Ready with SAL1 and PT1 Certifications at TryHackMe: https://tryhackme.com/yt_techwithtim. Use my code ""TIM25CERT"" for a MASSIVE 25% off on the certification fee and annual subscription

The software engineering field is tough, and for some, you may feel defeated. In this video, I want to give you a little hope, motivation, advice, and tell you some things that you can do that help you feel empowered as you go through this process.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=pzcbRNLNkhY

Hashtags
#helpwithsoftwareengineering #adviceforsoftwareengineers #softwareengineerjobmarket #programmingadvice",2025-11-26T00:11:47Z,"tech with tim, Here are clean, high-signal YouTube tags you can paste directly ‚Äî all comma separated: software engineering advice, becoming a software engineer, aspiring software engineer, software engineer tips, how to become a developer, tech career advice, junior developer tips, coding career guide, learn to code, programming advice, developer roadmap, software engineer roadmap, coding motivation, developer mindset, breaking into tech, how to get a tech job",27,en,en-CA,https://i.ytimg.com/vi/pzcbRNLNkhY/default.jpg,https://i.ytimg.com/vi/pzcbRNLNkhY/hqdefault.jpg,PT14M51S,24389,965,114,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Now the other day, I was just on YouTube, I was scrolling and I saw a video from someone  who said something like, I am a Cooked Computer Science graduate.  I watched the video, this wasn't a YouTuber, it was just someone doing raw, unfiltered  video of them talking for 25 minutes, and they essentially explained that they feel completely  lost, they have no idea how to land a job, they just graduated a degree, they spent tens  of thousands of dollars, four years of their life, and they really don't know what to do.  They mentioned they're broke, they're living with their parents, they need some kind  of job, even if it's not a software development job, and they don't want to give up on this,  but they don't really know what they're supposed to be doing.  So I wanted to make this video, not in a direct response to that, but just as something  to maybe give you a little bit of motivation or something to think about if you are in  this field, because I understand that right now the market is tough, a lot of people  are feeling the way that that guy was in the video, and I do sympathize with you, right?  I get it.  I work with software engineers every single day that are in this exact position, and the  first thing I notice is that they just feel defeated, you know, you've applied to thousands  of positions.  If you're not getting a single callback, nobody wants to hire you, it feels like the  market's getting tougher every single day, we have AI, it feels like everything's out  against you, right?  Anything you do, it's like there's some competing force that's just pushing you down, and you  don't really feel any hope.  And I completely understand why you would feel like that, but I want to give you a little  bit of hope in this video, or at least tell you some things that you can do, because I  think the most empowering thing that you can feel when you're going through this process  is that you weren't actually the one that's in control.  It may feel like there's all these other factors that there's nothing that you can do,  but I promise you, you can take actions to better your situation.  No matter how tough the market is, no matter how crap the economy is, no matter how many  people are applying, no matter how much AI is coming into software development rules,  you can land a job.  And I say that confidently, because I've done it with many, many people, I've worked  with tons of software engineers, or whether it was from my guidance or something else,  they have landed entry-level software engineers rules.  That has happened.  I've seen it over and over and over again, but the only people that do that are the ones  that take control.  They take accountability, and they change their mindset from everything that's negative  and everything that's wrong to what can they actually be doing on a day-to-day basis  to better themselves.  Now, if you're someone who does want to adopt that mindset, and I understand it's difficult  to do that, I'm not saying, you know, the market is going to be a little bit more difficult  and you know, the market's great and it's easy just to go and take all these actions.  But if you're someone who does, keep watching this video because I will give you some  piece of advice that I think will really help you throughout this job search.  And just to tack on to that, if you're someone who's not really in that boat right now,  and you still kind of just feel like a victim in this market, what I want to say is that  you can feel sorry for yourself all you want, but you can only control what you can control.  None of us watching this video can control the market.  We can't control macroeconomics.  We can't control, you know, if there's going to be a bunch of layoffs or if something's  going to happen or if AI's going to take over.  There's only a few things that we can really do individually, and if you do all of those  things and it doesn't work, okay, you gave it a fair shot.  But I guarantee most of you are not doing those things, and while again, we can complain  all we want, that doesn't help us, right?  It doesn't help to feel sorry for ourselves, and while I get you would feel like that,  and I totally relate to that feeling, the only thing you can do is control the variables  that are in your control.  When you adopt that mindset, I find that you have this very kind of freeing, you know,  feeling where you just get rid of the stress, you get rid of the anxiety, because you realize  I'm in control.  It's up to me.  I can make the changes.  I don't have to make the changes, but I'm not going to worry about all of these things  that I don't have any control of.  Anyways, I just want to touch on that point, and we'll continue with the rest of the  video after a quick word from today's sponsor.  One of the things you're going to hear a lot of people talking about when they talk about  landing a job is to stop watching tutorials and doing real work.  Now, if you want some skills that employers are actually hiring for, you need to practice  hands-on, right?  And I've done this many times, and it makes a massive difference.  Now, try hack me is the world's largest hands-on cybersecurity training platform with  over 6 million users that are learning by doing.  You launch your labs right in your browser with no installation or no setup, and you follow  guided challenges with real commands and solve tasks that mirror real-world situations.  Knowing the theory is fine, but if you want to stand out, you need proof that you can  actually do the job.  And that's why try hack me created two job-focused certifications that are designed to prove  real skills.  The first is the Security Analyst Level 1, SAL1, and then the Junior Penetration Tester  where PT1.  Now, SAL1 proves that you can work as a Security Analyst in SOC.  You investigate alerts, analyze activity, and respond to incidents inside of the live  SOC simulator.  The exam mixes practical simulations with knowledge questions, and shows that you can handle  real workflows, not just facts.  PT1 proves that you can perform a professional penetration test, you find and exploit  for abilities and web applications, networks, and active directory.  And then you write a short report explaining what you found and how you can fix it.  It mirrors the tasks that real penetration testers do every single day and demonstrates  that you can think like an ethical hacker.  Both certifications are built by TriHackMe and industry experts to match the roles companies  are hiring for.  They focus on action, not just theory, and give you credentials that actually prove  ability.  If you get 25% off these certifications using the code Tim25Sert, you can also use the  code to get 25% off an annual subscription.  Click the link in the description, choose the certification that fits your path, register,  and start today.  Okay.  So as I was saying, if you are someone who wants to take life into your own hands, the  first thing that I definitely recommend doing if you're trying to get a software engineering  job is really tailoring your resume to one particular type of role and picking a specialization  or a niche that you want to get into.  Now I say this and I've repeated it many times on this channel because it's so important.  In this market, you can't be a general software engineer, especially as a junior.  You need to present yourself as someone good in one particular area.  So back end with Java, for example, in Spring Boot.  You know, front end with React or view or something like that.  You know, PHP, whatever.  It doesn't matter what the specialty is, but you need something.  Don't go after just the shiny jumps or put your resume in a format that matches, you  know, thousands of different descriptions.  That's a sure far way to not get looked at, especially when thousands of people are  applying to the exact same positions.  Companies will hire someone who matches the role exactly.  You would rather match 10 roles exactly than be kind of a decent match for 200 rules.  I've seen this over and over and over again.  You need a niche, you need a specialty, and you need to prove that you're good in one  particular area.  Now, the way that you can prove that is by tailoring your resume, writing a description  a lot of people don't have descriptions on their resume.  You want like a professional summary at the top that states what your expertise is.  You want to refine your skill list and you want to have ideally, especially at a junior  level, to really solid portfolio projects that speak to the specialty that you're talking  about.  The biggest mistake people make is that their resume is all over the place.  They have skills in so many different areas.  Again, it's very difficult to break through with that approach.  If you're going to say that you're a Python backend developer, for example, both the projects  that you have on your resume need to be Python focused projects.  Sure, you could have other skills, but they need to talk to what you were trying to  present.  Now, the next piece of advice I'm going to give you is to not skip networking and LinkedIn.  I get it, okay?  No one wants to network.  No one wants to be a LinkedIn expert, but so many jobs nowadays are coming from your  online presence, which really, in your case, is just going to be LinkedIn.  You need a professional photo.  You cannot skip that.  You will get judged based on how you look.  You need to have a pro photo on LinkedIn.  You need a professional banner.  You need a clear headline that states the role you want to get, not the role you currently  have.  If you work as a business analyst right now, but you're trying to get a software engineering  job, don't put that as the headline on your LinkedIn.  Put software engineer.  It's fine.  It doesn't need to be 100% accurate.  You're going to show up and search if you have that.  You need to have a professional description.  You need to have everything written out clearly.  You need to have 500 plus connections.  Doing that is very easy.  It's low friction and it drastically increases your chances.  From there, if you can start building a network on LinkedIn, reaching out to people and applying  actively where you're actually finding the hiring manager on LinkedIn, sending them a direct  message and doing a really small ask, something that's super easy for them to do, you will  see your response rate go up.  I know that it's annoying.  No one wants to do that.  I don't even like to suggest that because I get that most of you are not going to follow  that advice.  I've seen it over and over and over again.  The people that are active in the job search that actually put effort in are the ones  that see results.  You don't need to know five Google employees.  You simply need to go out and just reach out to people and try to get something.  If you send 1000 LinkedIn messages, I guarantee you people will get back to you.  You will get opportunities and you will have a chance.  Just because you did it 10 times and it doesn't work doesn't mean that strategy doesn't  work.  It means that you haven't done enough that's inevitable that it will happen, right?  Give you an example.  On my YouTube channel, I posted over 200 videos before I hit 10,000 subscribers, okay?  Now, that was a lot of videos and I knew if I just posted enough, eventually I would  see success.  I did something with so much volume that it was unreasonable, I wouldn't get the result.  It's the same thing with job hunting.  You will get an opportunity.  I guarantee it to you.  I've seen it from literally everyone that I've worked with if they do this long enough,  they do get chances.  But you need to not give up.  It is possible.  It's not a matter of if it's a matter of when.  If you believe that and you know that it's just the volume that you need to put in, you  will get a response.  Now, of course, there's smart ways to go about doing this.  I teach this inside of my program.  I've launched and I'm even trying to sell it to you.  Just the point is that you can be more active in the job search.  You can again, pick a niche, target roles that you are.  actually fit for and really stand out by reaching out to people.  Just give you another quick example.  I had someone in my program who actually was sending video messages to all of the YC startups.  By doing that, he sent a personalized video message.  It was like 45 seconds long of him talking about why he wanted to work for their company,  saying their company by name like it was a legit video message he recorded.  He got a 50% response rate from the companies he was doing that with.  You can do that.  It doesn't take that long.  The question is, will you?  Now, let's assume you take that advice and you start generating some opportunities.  You need to be prepared for interviews before they come up.  Again, it's a matter of when, not if.  Now, the way to prepare for interviews is just to over-prepare, right?  That's literally just the way to do it.  You prepare so much that it's impossible that you wouldn't be ready for the type of question  that you're going to get asked.  It's grueling.  It's tough.  It's annoying.  Nobody likes doing it.  But once you do this one time, you just set yourself up for life.  Now, the way that I suggest doing this is having a combination of practical practice  where you're actually writing code day by day, working on projects,  as well as doing your DSA prep, right?  By following through a structured guidelines, you know exactly what problems you should be doing.  Doing mock interviews with people that's extremely important.  You need to make sure you practice like you're going to play  and you emulate a real environment.  And then if needed for the type of role you're applying to, of course,  doing system design prep as well.  The important thing is that you want to walk into an interview feeling like  you've done as much prep as you possibly could have  so that you completely relieve any nerves or stress.  When you know that you've prepared,  when you know that you're ready,  that you've done enormous amount of problems,  you've actually put in the hours,  it's a very relaxing feeling going into an interview  because it's not like you're at the Super Bowl.  It's not this event that you need to perform for.  You've just done the prep.  You're just going to do the same thing you've been doing for the past three weeks,  but now you're going to do in front of someone else.  It's way easier to perform well in an interview when you're over prepared.  And when you feel like that,  interviews just become another day,  they don't become this massive event,  and you can really be relaxed and perform at your best.  Now, look, there's a lot of other stuff that I can get into here,  right in terms of how to actually succeed in the market.  But generally speaking,  it all comes from the mindset.  You need to genuinely believe that you can do this,  that this is possible.  You need to convince yourself that you're the type of person  who will figure this out,  even if it takes you a year to do so.  You need to be willing to put in so much volume  that it's unreasonable that you wouldn't get the response.  I don't want it to be like that.  I don't want you to apply to a thousand jobs.  But if this is something that you truly care about,  it's a job you actually want.  If you want to take advantage of the school that you went to,  all of the work that you've done,  you can,  but you have to be willing to put in the work, right?  A lot of other people are going to do that.  It's annoying.  It's not great.  It's not a market that I love.  Again, it just is what it is.  You control what you can control.  If I told you that I would pay you five million dollars  if you landed a software engineering job in the next four months,  you would figure out how to do it.  Almost all of you watching this video  are capable of landing these roles.  And I say almost because some people just aren't a fit  for software development.  But generally, if you've gone through something I could degree,  if you've built projects,  if you know you have some legitimate skill,  you can do this.  It's just a matter of again,  doing it so much that it's unreasonable  that you wouldn't get the job.  If you have that mindset,  you will be successful.  And I'll remind you that this is worth doing  because software engineering jobs are objectively  some of the best jobs in the world.  In terms of competition, benefits, prestige,  and how they can set you up for the rest of your life.  Imagine if you worked in a video 20 years ago  and you got stock, where would you be right now?  Look, that's obviously an extreme example.  The point is, these are good jobs.  That's why there's a lot of competition,  but you can get them if you're willing to do the work  that all of the other people  that are landing jobs are already doing.  Now, that's really all I had to say here.  I think the overall message,  and again, I don't want to be condescending.  I'm genuinely trying to kind of motivate you  and give you some momentum and help you  is that you are the one that's in control.  You decide your fate.  That shouldn't be a negative thing.  That should be a very empowering thing to realize.  Control the things you can control,  put in the effort in the work,  the small effort compounds over time,  and be so prepared when you walk into something  like an interview that it's not a question  of if you prepared well enough.  It's just a matter of, you know,  if you're gonna get unlucky or not, right,  with a really ridiculously hard question  or an interviewer in a bad mood.  And if you do, so well, it is what it is,  you'll get the next one.  You've done the work already,  and you did everything that was reasonable  for you to have done.  Anyways, guys, it's all that I have for you.  I wish you all the best in this job hunt.  If you do want assistance with this one-on-one  and you like this message,  it resonates with you,  or someone who is willing to put in the work,  then consider applying for my dev launch program,  which I'll leave a link to below,  where you can work directly alongside me  and other expert software engineers.  Anyways, guys, I'll see you in the next one.  [‚ô™ OUTRO MUSIC PLAYS"
vB1HPzvpMVA,This is the #1 mistake people make in interviews.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-26T00:01:07Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/vB1HPzvpMVA/default.jpg,https://i.ytimg.com/vi/vB1HPzvpMVA/hqdefault.jpg,PT1M28S,24387,1293,12,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"mistake, which is extremely common, is to jump immediately into the solution.  Now, I'm sure that you're probably familiar with technical interviews.  You may have been given them before, but typically the interviewer is going to ask you a fairly  vague question.  Reverse a length list.  Find the largest value in an array and people just immediately think, okay, I'm really  smart.  I got to jump in and you know, solve the problem right away and they immediately start  writing code.  That is the biggest mistake you can possibly make and if you do that, you will almost  immediately fail the interview before it's even started.  The reason for that is these technical interviews are designed to test not only your coding  ability, but actually more so your problem solving ability.  The interviewer wants to see how you communicate, how you break down the problem and they actually  want to ensure that you stop and think about it before you jump in and start solving a  prop, right?  Think about a big tech company.  If you just started writing code immediately, that is not a good sign.  They want you to actually design the solution and debate the different alternatives.  So do not jump right into the code editor.  Start by breaking down the problem, understanding what the problem is.  Asking clarifying questions, for example, can I expect really large inputs?  Is there going to be negative values here?  Could I get an empty list?  Is this what you meant?  I just want to make sure I understand the problem before I go forward.  This is what you have to do.  You have to clarify the problem, make sure that you have all of the requirements and everything  is narrowed down.  Then you want to start coming up with a plan and designing your solution before you jump  into the code.  You should actually spend almost half your time in the interview in this planning phase where  you're coming up with your solution, verifying that it works, and then you go and solve."
9yuSAKLriAU,Did you know about this Python feature?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-24T19:36:19Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/9yuSAKLriAU/default.jpg,https://i.ytimg.com/vi/9yuSAKLriAU/hqdefault.jpg,PT1M9S,7833,187,5,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"So the first function we'll look at here is the print function.  Now this is probably the first thing you learn when you learn Python and it seems super  basic.  We can print out a few different things.  We can separate them by commas and you can see that we can print a mix of strings and  variables.  And when we do that, they'll get printed out separated by a space.  But what you probably didn't know is that we can pass additional arguments to the print  function to modify how it works.  For example, I can pass this set argument here.  So set is equal to and I'll go with something like a pipe.  And now what will happen is rather than using a space as the delimiter or what goes in between  the different arguments we pass to the print function, we'll use this pipe.  So when I run the code now, you see we get my name is and then pipe, Tim, pipe.  And I am pipe 23 pipe years old.  So we can override that default behavior, which is to use a space to separate all the different  things we're printing.  And in this case, we use a pipe.  Now maybe instead we want to use a comma.  So let's go back here and change that to a comma and print this out.  And now you can see that we're printing things with a comma.  This is quite useful especially when you want to print out things and have a certain formatting  and you don't want to do the manual formatting yourself."
eSbeub2ZeNk,Build & Deploy a Python AI Agent in 20 Minutes,"Click this link https://www.boot.dev?promo=TECHWITHTIM and use my code TECHWITHTIM to get 25% off your first payment for boot.dev.

In this video, I'll show you how to build and deploy an AI agent in Python in a matter of minutes. We'll not write every single line of code completely from scratch, but I will cover all of the important concepts and all the code and demos that you need.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=eSbeub2ZeNk

üéû Video Resources üéû
Vercel: https://vercel.com/docs/cli?package-manager=npm
NodeJS: https://nodejs.org/en
OpenAI Platform (API Keys): https://platform.openai.com/api-keys
Code In This Video: https://github.com/techwithtim/BuildAndDeployAIAgent

‚è≥ Timestamps ‚è≥
00:00 | Overview
00:33 | Tools & Architecture
02:14 | Setup & Install
06:30 | Writing the Agent 
12:09 | Writing the API
15:00 | HTML Template 
16:48 | Testing the Code
18:00 | Deploying to Vercel

Hashtags
#Python #AIAgents #SoftwareEngineer",2025-11-23T22:52:49Z,"tech with tim, python ai tutorial, build deploy ai agent, machine learning python, ai project in 20 minutes, python automation, openai api integration, python coding for ai, quick ai development, ai chatbot development, ai agent build guide, python scripting for ai, ai programming tutorial, rapid ai deployment, step-by-step ai build, ai application development, Boot.Dev",27,en,en-CA,https://i.ytimg.com/vi/eSbeub2ZeNk/default.jpg,https://i.ytimg.com/vi/eSbeub2ZeNk/hqdefault.jpg,PT23M16S,24733,887,19,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"In this video, I'll show you how to build and deploy an AI agent in Python in a matter of minutes.  Now, we'll not write every single line of code completely from scratch,  but I will cover all of the important concepts and all the code and demos that you need for this  video if you want to follow along exactly will be available from the link in the description.  What I'll be doing here is showing you the simplest possible way that you can actually deploy  your Python application out, so if you build an AI agent, someone else is actually able to use it.  With that said, let's hop over to the computer and go ahead and get started.  Okay, so the first thing that I quickly want to go over is just the architecture and the  different tools that we'll use here. Once we understand that, we'll get into the setup  and I'll walk you through the exact tutorial. Now, if we want to deploy something,  typically we need to know what we want to deploy. Now, you can build a simple Python AI agent,  but one of the easiest ways to access that, if you're not on your own local computer,  is through something like a website. So what we'll do for this video is we'll  build a simple web interface for interacting with our AI agent, just like you would have for  something like chat GPT. We'll just have a simple chat box and we'll have the ability to type  in a prompt, essentially send a message to the agent and then get a response back.  Now, in order to do that, we're going to use a variety of tools. The first tool that we'll use  is Fast API. This will allow us to create a really simple API so we can communicate with our agent  from this web interface or even from a different interface if we wanted to build that in the future.  We also need to have the agent. So for the agent, we will use OpenAI, that'll be our LLM,  so we'll have an OpenAI API key, which I'll explain later on. We'll use Langchain and we use  that in combination with LangGraph, which allows us to make a really simple tool calling agent that  can actually go into the world and perform actions. Then within Fast API, we're going to use a  really simple HTML template and a little bit of JavaScript code, which you can just copy from  the link in the description, which will allow us to interact with our backend API, so the thing  that actually kind of serves our AI agent and we'll deploy all of this using Versel, which is  completely free, can be automated and is very easy to set up. Okay, so that's the tooling.  Now what I'm going to do is go into the code editor slash IDE. We'll start setting it up and we'll  go from there. So in order to get started here, open up any editor or code editor that you would  like and just create an open a new folder. In my case, I've just opened one here called  deploy AI agent. Now, before we can do all this setup, we do need to make sure that we have no  JS installed on our computer. You'll see why in just one second. So you can download it from this  link right here. And then what we're going to do is install the Versel CLI tool. Now, what this  tool will allow us to do is just deploy our application directly from the command line so you  won't need to create something like a new GitHub repository if you don't want to do that. Now,  what I suggest is creating a new account on Versel. I'll leave a link to it in the description.  Again, it is free. It is very straightforward to do so. And then once you've done that,  what we're going to do is go to this right here. It says installing the Versel CLI change this to  NPM, which will now have installed if we installed no JS. We'll just copy that command and then we'll  go back to our terminal here. So I'll just open that up inside of cursor and just paste that. So NPM  I dash G, which stands for global and then Versel. And that will install the CLI tool for us.  Okay, so that was just installed. Now that we've done that, we'll simply just type the Versel command  to ensure that's working. What it will do if it's your first time using this is it's going to ask  you to sign in and to go to the browser. So sign into your Versel account and then you can just  exit out of this command. So I'm just going to hit control C, which will just quit out of that  command because I'm already signed in and I've installed this tool in the past. Okay, so now we're  kind of all set up with Versel. What we're going to do is from within the directory where we want to  create our project. So in this case, I'm in this deploy AI agent. I'm going to run the command,  which is VC standing for Versel and then a knit and then fast API. Now when I do that,  what it's going to do is just create a boilerplate fast API application for me in this fast API  project. What I'm going to do is I'm just going to copy the contents of this and just pull this  into the root of this directory. So I'm just going to delete this fast API folder. So essentially,  I have them all in this deploy AI agent folder. You don't need to do that, but I just want to have  it in one directory. I don't want all these nested directories. So I've just pulled out all of these  files into my main deploy AI agent directory. Okay, so from here, you'll see that we have this  main.py file. We can actually just go in here and we can delete everything for right now,  because we'll write that from scratch. Same thing with the read me. We don't need this. We can  just delete it. Perfect. Now let's continue with the rest of the setup just after a quick word  from today's video sponsor boot.dev. It's an online learning platform designed specifically  for backend development and it approaches learning in a way that's far more interactive  than the usual video based courses. Rather than having you sit through hours of lectures,  boot.dev puts you straight into hands on coding. You'll work directly in your browser  building real projects while learning backend fundamentals like APIs, database.  and server-side logic using Python and Go.  Now what makes it stand out is the way that it borrows from game design.  You'll progress through levels, unlock new content,  and keep your momentum up as you go.  The platform is filled with exercises and practical challenges,  so you'll end up writing a lot of code,  which is exactly what helps you improve.  Now all of the core content is free to access,  and if you decide to commit to the annual plan,  you can use the code tech with Tim to get 25% off your first year.  I've been going through it myself lately,  and honestly, it's surprisingly addictive.  Thanks to Boot.dev.  Now let's get back into it.  All right, so what we're going to do now is go into our requirements.txt,  and we're just going to add the different Python packages  that we'll need here for the rest of the video.  So we're going to say that we need Jinga 2.  This is a templating engine, sorry, 4-fast API,  that will allow us to actually render some HTML code to the screen.  We're going to have Langchain,  because we're going to use that for AI agent.  We're also going to have Langchain OpenAI,  which will allow us to use the OpenAI package.  We're going to have LangGraph,  and then we're going to have Python-.env,  which will allow us to load in environment variables.  Now that all of these are installed, we're  good to go, or in the requirements.txt, at least,  and we can close them.  Okay, what we're going to do is we're just going to make a new file here  called agent.py.  And what we'll do is we'll write the AI agent first,  then we'll write kind of the back end or the API  that will serve the AI agent so we can deploy it.  So I'm just going to copy in a few code snippets here.  I will explain them, but I don't think it's too valuable  for me to write it line by line.  And if you want this exact code,  I will have a GitHub repository linked below,  that you can check out where you can just copy all of the code.  Okay, so what I'm going to do is bring in my imports here,  because we're going to make an agent in Python,  we're going to bring in chat OpenAI,  which is going to use the OpenAI LLM.  We're going to bring in tool,  because we're going to make this a tool calling agent  that has the ability to take some actions.  And then we're going to use Langgraph,  which is just the easiest kind of pre-built agent  that we can bring in that will automatically be able to call tools.  Now, because I'm talking about tools,  I do want to start with those.  Now, a tool in our context is just going to be some function  that the agent will be able to call.  It's very straightforward,  but what I can do is just copy in two tools that look like these.  And these are simple functions that have a doc string,  as well as annotated parameters,  that explain what they do.  So we have a tool called ReadNote.  What this does is very simply open a file  and try to read a note.  OK, then we have WriteNote.  What this does is open a file  and try to add some content to the file.  So I'm just showing you two really basic tools,  where we have an agent that will be able to now read a note  and write a note,  so we can kind of store some information persistently.  This is like the most basic tool you could possibly create.  You can change them and make your own  by following this exact same format.  You decorate the function with this at tool decorator,  which we imported right here.  Name it something that's reasonable,  because the LLM is going to look at that name  to know if it should call it or not.  Write a description on what the tool does  inside of a doc string like this,  and then put the types of the parameters,  like what the tool is going to accept  and what the tool is going to return,  as well as just parameter names that make sense.  So the agent knows which one to call and how to call it.  OK, so now that we've done that,  what we're able to do is just create a simple list of tools.  So we're going to say tools is equal to  and then in a list here, we have read note and write note.  We're then going to create a system message.  So my system message is going to be this.  You can change it to be anything that you want.  This just explains to the agent  what it's actually going to be doing.  And then we're going to initialize the agent and the LLM.  So to do that, we're going to write these lines  where we're going to say LLM is equal to chat open AI.  We're going to put the model that we want to use  in this case, I'm just using GPT-4.  We put the temperature, the lower the temperature,  the less random it will be.  And then we're able to create an agent that combines  the LLM, the tools, and the prompt, or the system message.  Don't mix this up with the prompt, the user will send.  This is just the first prompt that the agent will look at.  So it understands how it should be performing.  Now, with all of this, we have the ability to run the agent.  And the way that we can do that is with a function like this.  Again, you can copy all of this from the link in the description  where we can simply run this function with some user input.  What it will do is attempt to invoke the agent.  When we invoke the agent, we pass a list of messages  we wanted to respond to.  In this case, we just have one message.  So we say, OK, the message is this right here,  where the role is the user.  And the content is whatever we had is the parameter right here.  And then we're just going to return whatever  the response to that particular message  is, which we can get using this format.  If there's an error, then we'll return that.  That's it, OK?  That's our AI agent.  And we can quickly test that if we want by just calling  the run underscore agent function and passing something  in like, you know, hello, how are you?  OK?  Now, in order for this to work, though,  we are going to need an open AI API key.  And we're going to have to store that inside of a .env file.  So we're going to create a file called .env.  And we're going to put inside of here open AI.  underscore API underscore key, and we're going to place an open AI API key here, which  I will show you how to get.  So in order to get an open AI API key, you'll need to go to this link right here, which  is platform.openai.com slash API keys.  You can then press on the button create new secret key.  This will require the debit credit card on file.  It will cost a few cents.  It's very inexpensive.  If you want to use this, you also could use a local LLM.  You can replace this with whatever you want, but this is just the absolute easiest way  to do it.  I'm going to go create a new secret key.  I'll just go with test or something or test two, because I already have one called test,  and I'll delete this key afterwards that you guys cannot use it.  OK, so I'm going to copy that.  I'm going to paste that inside of my environment variable file.  And now what I'm going to do is just add one line of code to the beginning of this file,  where I'm going to say from .env import load.env.  And I'm going to call the function load.env by simply adding these two lines.  I'm now going to load in the environment variable that I defined inside of this file.  And what we're able to do now is run this code.  Now we will need to install all of the requirements.  So what we could do is say pip install dash R and then requirements dot txt.  If you want to use a dependency manager, go ahead and do that.  If you're on Mac or Linux, you can try the pip three command.  This should install all of the dependencies into your global Python kind of interpreter,  which is not always the best practice.  But for this video, just really quickly, that's what we'll do.  And then we can simply run this agent.py file and see if it works.  So I'm going to save Python and then agent.py.  Again, if you're on Mac or Linux, you would change this to Python three.  So I'm going to go ahead and run that.  And we're hoping that we're just going to get some kind of response.  And actually just gave us a morning here on kind of a deprecation thing.  We don't need to worry about that.  But what I do need to do is print out whatever this was.  Because if we don't print it, then I'm not going to see what the response was.  So I'm just going to print the response here.  Let's wait and see if we get it.  And it should tell us something that says, hello, I'm an assistant.  And you can see that it is indeed working.  Okay, so we're going to remove this print and this function call.  And what we're going to do now is move on to write the API.  So we can actually serve this content on some kind of front end.  And then we'll be able to deploy it.  All right.  So now we're moving into our main.py file.  From here, we're going to have a few imports.  Again, I'm just going to copy in the code just to keep it a little bit faster.  So what I'm going to say is from fast API, import these things, which we need for setting  up the API.  I also don't want that open.  I'm going to bring in this jinga templates, which is going to allow me to render some  HTML.  I'm going to bring in a base model from pedantic.  You'll see what we need then the second.  And then from my agent file that I've written right here, I'm going to bring in this run  agent function, which will allow me to well run the agent.  Okay.  Now what I'm going to do is initialize the application as well as the templates.  So what I'm going to do is say app is equal to fast API.  And I'm going to say that I have these HTML templates that are inside of this directory  called templates.  That means that I should make a new directory called templates, which is where I will store  the HTML that we'll kind of put for the front end that will display on the screen.  Now what we're really going to quickly do is also just to find two request and response  models.  Now this is going to allow us to kind of define the type that our API is going to accept  when we invoke the agent.  If you're unfamiliar with an API, essentially, this is a service that we're able to provide  to something like a web application where it can call some root.  In this case, it can ask, for example, for the front end, what does it look like?  Give me that HTML code or it can ask to invoke the agent.  So we're just writing essentially the request type and the response type that will happen  from our API for one of the particular roots.  This is not a full API tutorial.  I know it's a little bit of a vague explanation, but the API allows us to kind of serve and  deliver content in a protected way where a user calls some path like, you know, slash  API slash agent or something, and then they get some response, which is whatever the agent  set.  Okay.  So what we're going to do now is we're going to define our home root.  So this home root is what's going to serve the HTML template.  So what we're going to do is just say, okay, app.get.  We're going to put a slash.  We're going to say async define home, and then this is going to take in some request.  And what we're going to do is say return templates, template response.  And then we're going to have the index and then the request.  Now what this is going to do is it's just going to render an HTML template for us called  index.html.  So we'll show that on the screen.  We'll be able to see that in one second, but first we'll need to actually write the index.html  file, which we'll do in one minute.  Okay.  So this is like the home root for actually seeing the website.  Then we're going to have another route.  This is going to be at app.post, which is the HTTP method that we're going to use.  We're going to call this slash agent.  And what this is going to do is invoke the agent with prompt.  Because if someone calls this, it's going to give us a response that tells us what the  AI agent said.  So essentially all we're doing is calling this run agent function with whatever the prompt  was that the user passed into this function.  And then we're going to get the result.  You can make this as complicated as you want, but these are the only two routes that we  need for our API.  And that pretty much completes the code.  Okay, now the one thing that we're missing is this index.html file.  So what we'll do is we'll go in this template's directory and we'll just call this index.html.  The way that it works inside of languages or sort of frameworks like fast API is that you can have something called a template.  Now the template is essentially just an HTML file that's written in a certain format looks very similar to normal HTML that allows you to render things like variables onto the screen.  In our case, we're not going to use any fancy templating syntax, but what I'm going to do is I'm just going to copy in a very slim 85 line HTML file, which again, you can find exactly from the link in the description.  In case you want to copy it precisely, it has a little bit of CSS styling.  We just define the title of the web page and then we have a really simple form.  The form just has a text area and a button and then we have some div where we'll render the response as simple as you can possibly get.  And then I have a little bit of JavaScript code.  I'll zoom out so you can read it all where essentially what I'm doing is I'm getting the form.  I'm looking for the user's prompt input.  I also I'm just getting the div for the response so I can render the code there.  When the form is submitted, what I'm going to do is I'm just going to put a little bit of loading indicator so we can see what's going on.  I'm going to send a request to my backend.  So to this, right, that we just wrote, I'm going to call this slash agent endpoint with the post type.  I'm going to pass in the prompt, the user provided, and then I'm going to get the response.  Now, if the response is valid, what I'm going to do is I'm just going to put that response inside of the response div so the user can see it.  That's it.  Just allowing me to have some dynamic kind of content on my site.  So when you press a button, we send a request, this endpoint gets called, which then goes here and calls this function, gets the response from open AI, gives it to us and puts it on the screen.  That's literally all that we're doing.  Now, the only thing we need to do if we actually want to test and run this application is we need to import you've  a corn from the top of this file.  And then we need to just paste this line right here, which is you've a corn.run and then app, host and port and just put these exact same values.  When you do that, it will now be set up to run and what we're able to do is go here and just run the code.  So we can say Python and then made up UI again, Python, three, if you're on macro linux, go ahead and hit enter.  And then it should run the server for us.  If we open this now by just copying it into our browser, so let me do this here and just open it up.  We should see that we get something.  If for some reason it gives you an issue with this zero dot zero dot zero, just put local host port 8,000 and it should pop open the UI now.  And we can say something like color world.  Can you save a notes saying high and then just go ahead and press on send and let's see if we get a response back.  Okay, give the second says I've successfully saved your notes saying high.  And if we go here, we'll see we have this note file now that says high.  So the agent is working.  We're able to use it from the browser very straightforward.  Again, we just need to run that application.  Now what we're going to do is deploy this, which you're going to see is extremely fast to do.  So what I'm going to do is I am just going to get out of this by hitting control C.  It's going to shut down the server for us.  And I'm just going to remove this unicorn line by just commenting it out and just commenting the import because we're not going to need this.  So let me do the deployment.  Now I can close everything else, so just close it all.  And what we're going to do is go into our terminal.  Now, and we're going to run a command that essentially just deploys this application to for sale.  So to do that, we can simply type VC and then deploy.  Now, when we do that, it's going to ask us if we want to set this up and deploy.  We're going to type yes, then we are going to go through here and pick what team.  So Microsoft some teams are just going to go to my projects.  Again, it's free to do this.  We are not going to link this to an existing project.  So we'll type no for the name, whatever you want.  So it's called deploy a agent or something.  Okay.  In which directory is the code located?  You don't need to type anything because it's in the root directory.  So we hit enter says, do you want to modify these settings?  We're going to type no.  Okay.  Do you want to change additional settings?  We're going to type no or just end.  And then it's going to deploy the project for us and create a new file or create a few new files.  Sorry that we're going to have in this directory.  Now, what it's going to do is give us a few links here.  So we can actually check out the deployment.  So what we'll do is we'll just go to this inspect link that it's provided and we'll just open this up in our browser.  So I'm just going to open it and we should be able to see the deployment.  And you can see that it looks like it was deployed successfully.  So let's open this up and when we just press on that preview, we now can type something.  So maybe we type something like hello world.  And let's actually see if this works and you can see that it's working completely fine.  Now, one thing that you might want to be a little bit careful of is that we actually,  when we did this, deployed this dot ENV file, which contains our environment variables.  Now, while you can do that, it is possible that you could leak this environment variable file when you do this deployment,  due to how Vercel does the employment.  So one thing that we might want to do for future deployments,  just to make sure that we're not leaking these values, it just create a new file called dot.  And this is going to be Vercel ignore.  Okay.  So let's  this. Inside of this file, we're just going to type something which is .env. That just  tells us first cell to ignore this environment variable file. And now when we deploy, it  will not deploy the environment variable in this file. Now, the reason we're going to  do that is because we will just manually add the environment variable to the deployment  in an encrypted and in a safe way. So in order to add the variable properly without deploying  this environment variable file, what we're going to do is just type VC. And then we're  going to type ENV and then add. I believe that's the command. We're going to see if  that's the correct one in one second. And then we're going to put the name of the variable  we want, which is OpenAI underscore API underscore key. So if we do that, okay, it looks like  that is the correct command and we type enter. We can now copy our OpenAI API key. Maybe  we want to use a different one for deployment, production, whatever. So I'm going to paste  that in right here. And then what I'm able to do is choose where I want to use this key.  So do I want to use it in the production preview deployment? I just want to use it in  all of them. So I'm just going to select all of these by going over them, pressing space  and then pressing enter. And now it's added these variables. Now what I can do is redeploy  the project. So I can say VC deploy when I do that. Again, it's just automatically going  to deploy this for me. And then I'm able to view this in my account as well as just  by looking at the preview links right here. Okay, there's also a few other commands.  If you want to look at like the logs or something. So what we'll do is again, go back to the  inspect link, just open this up. And then we should see that we have the preview. So let's  open it here. And we can say, you know, save a note for me or something, save a note that  has a random fact. Okay, let's go ahead and send that and see if this works for us.  Okay, give this a second because sometimes it is a little bit slow. And it says there's  an issue with the note. You know, I can't find the file system. It's read only. Okay,  there might be a problem with using those particular tools with for sale. To be honest  with you, I didn't try the note component because I think the file system for versel,  especially on the free tier is not set up properly. However, we could just change the tools  to be literally anything that we wanted to, right? So if we go back to the agent, you  can just make any tools and just change them in this list. And then the agent will just  be able to use them. So, you know, this was just a simple example. You don't have to use  these. I assume none of you are wanting these in production anyways. So you can just  change the tool to something else that maybe you like grabs the weather calls another API  or does anything pretty much other than dealing with the file system. I then that should work.  But I can also just say, Hey, how are you and just use it like a normal, you know, kind  of chap on agent like I would use GPT. And you can see, you know, it gives me the response.  And anyways, you get the idea. I'm just trying to give you kind of a setup and a base here  for how you can actually deploy an AI project and Python as fast as possible. This is not  the most secure. It is not the most scalable. But if you're just trying to look to get a hobby  project up and running as fast as possible, you want to demo it to other people. I think  this is a pretty useful guide slash tutorial that hopefully got you there. So with that  side guys, I'm going to wrap up the video. If you enjoyed, make sure you leave a like, subscribe,  and I will see you in the next one."
2fGyi4ZSHLM,Have you used this Python feature?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-23T17:29:11Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/2fGyi4ZSHLM/default.jpg,https://i.ytimg.com/vi/2fGyi4ZSHLM/hqdefault.jpg,PT1M13S,18370,422,8,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,help function. Now the help function allows us to print out the documentation of a Python  function so we don't need to go to the internet to look it up and we can really quickly get  access to how a function works. Now what this will do is read the doc strings of a function  and simply give it to us. So what I can do is something like help and then I can pass  to this maybe the print function and notice I'm not calling the print function. I'm just writing  the name of it. And now when I run the code you'll see that it actually prints out all  the documentation for the print function. This is what's contained in the doc string for it.  So you can see it says print kind of shows you an example of how it works and then it gives you a  description of the different arguments or the parameters for this function. Now this also  works for your own functions. So let me show you that. So you can see here I've written  a custom function called test funk and I've just written a doc string for it just as an example  so we can see how this works. Now when I run my code here notice it will actually give me  the documentation of this function. So it says a b and then the return type. Again it's  really just printing out what the doc string is that's written here. So this is useful for built-in  functions but also when you're working with a library or code written by other people.  So you don't need to search through and find the actual function definition. You can just  use this help function and it will print it out for you.
UAjzFTGlaXw,The true power of Wispr!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-21T20:45:01Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/UAjzFTGlaXw/default.jpg,https://i.ytimg.com/vi/UAjzFTGlaXw/hqdefault.jpg,PT1M7S,17167,613,11,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Okay, so I'm in ShatchyBT.  I've got flow running.  You can see that by this little kind of icon  in the bottom, which is transparent.  Hey, ChatchyBT, I'm just giving a quick example  of how I talk into the computer  and why this is so much faster than typing  and how this is a better dictation tool  than built in dictation.  And here we go.  You see that I get everything here.  Now, the interesting thing is that this automatically fixes  my grammar.  It will actually list things out in point form.  It works directly inside of tools like cursor,  windsurf, AI editors.  It can tag files.  It works in WhatsApp.  It works in Discord, just anywhere you need to type.  This thing works and it works better.  But I want to explain why this makes me code three times faster.  So let's say I'm here inside of cursor, right?  Now, I could do something like,  hey, can you change the name of my application  to be, you know, dev launch vault?  But I can speak pretty fast, right?  So watch if I go to flow.  Hey, can you change the name of my application  to be dev launch vault?  And it'll pick it up and boom, it puts it in there.  I think probably about two to three times faster  than if I was actually typing it.  Again, even with the correct grammar  and it's able to determine kind of what I'm meeting."
jE7Xa7BYe14,This AI Startup Hit $1 Billion in 6 Month (GenSpark),"Register and get started with @genspark_ai  for free: https://www.genspark.ai/?utm_source=yt&utm_campaign=TechWithTim

What if I told you that just a team of 30 people built a tool that in six months is worth $1 billion, and it might just make ChatGPT, Canva and even your coding tools completely obsolete? GenSpark is Silicon Valley's hardest AI startup right now, and after using it, I understand why everyone is freaking out about it.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=NpGcL0rP0_8

‚è≥ Timestamps ‚è≥
00:00 | Overview
00:30 | What is GenSpark
01:27 | Hub & AI Drive
03:58 | AI Docs
05:35 | Research Me
06:40 | Developer Integrations
10:01 | Productivity Integrations 
12:26 | AI Inbox/Emails
13:23 | AI Teams
14:01 | AI Calling 

Hashtags
#Genspark #WorkwithGenspark #GensparkLive",2025-11-21T13:01:38Z,"tech with tim, GenSpark, Work With GenSpark, GenSpark Live, ai startup, billion dollar startup, tech startup success, artificial intelligence, startup success story, tech entrepreneurship, innovative startups, startup valuation, digital innovation, fast-growing startups, ai industry, startup milestones, Developer Integrations, Productivity Integrations, AI Teams, AI Calling, ai workspace, ai models, ai ide, ide",27,en,en-CA,https://i.ytimg.com/vi/jE7Xa7BYe14/default.jpg,https://i.ytimg.com/vi/jE7Xa7BYe14/hqdefault.jpg,PT15M16S,6740,196,17,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"What if I told you that just a team of 30 people built a tool that in six months is worth  a billion dollars?  And it might just make Chatchy PT, Canva, and even your coding tools completely obsolete.  Now you'd probably think I'm exaggerating, and I thought the same thing until I actually  tested Genspark.  Now this is Silicon Valley hottest AI startup right now, and after using it, I understand  why everyone is freaking out about it, and why it's worth a billion dollars in just six  months, which is absolutely crazy.  Okay, so let me give you a quick description of what this actually is.  Well Genspark is an all-in-one AI workspace that orchestrates multiple top AI models,  like GPT, Claude, Gemini, V3.1, etc, to deliver finished work.  So it doesn't just give you text responses, which is something like Chatchy PT, where in  that tool, it kind of helps you think and write, whereas Genspark actually gets the work done  for you.  So it can do presentations, websites, branding assets, data analysis.  You can collaborate with your team, and you can even get it to make a phone call for  you, which is kind of cool I haven't seen that before.  And anyways, in this video, I will show you a detailed demo of how this tool works, but  the main standout feature for me is that this actually acts like an entire AI workspace.  So it can store files, download files, sort them for you, and it kind of has its own drive,  which makes it really interesting, and it makes it feel like a workspace, more than kind  of like an assistant that you just come to randomly when you need something done.  Anyways, let's get on the computer, and let me show you what it looks like.  So I'm on the computer, and I've got the GenSpark website open.  Now you can just simply go to this URL right here, genspark.ai, or click the link in the  description to check it out.  Now this is free, and full disclosure I did team up with them for this video.  They gave me a briefing, kind of covered some of the main features of the product, but  genuinely I do believe this is super, super cool, and you can use it for free.  In fact, I haven't even upgraded the plan because I haven't needed to so far with the credits  that I have.  Okay.  So let's start going through it.  So the first thing that is really interesting about this is that like I said, it works like  an entire workspace, so it can actually store, download, automatically find files for  you, which I find makes this a lot easier to use.  So you have these different hubs.  Within these hubs, you can store different files.  You can kind of organize things just like you would have a folder or kind of like a separate  Google drive or something, and you can see I just created a few inside of my GenSpark  here where I have like code and development, you know, my tech with Tim stuff, sponsorships,  legal and accounting, and then they also have this AI drive.  So from the drive, you can see that I've worked with a bunch of different files here because  I've been testing around with it.  It's automatically downloaded these files, created the folders and sorted them for me, and  I can kind of click into here and see all of the different files that it's been using,  and I'll also use some of the tools that I've obviously I can organize it myself, you know,  create new folders, etc.  But generally it's pretty cool.  Let me show you what I mean.  What I'm going to do is just go to the main page here.  I'm going to go to kind of their super agent.  This is just like the general agent that you can use, and I'm going to type in a few prompts  and show you how it utilizes the hub and the drive.  Because again, I think that's one of the more stand out features of this platform.  Okay, so I've just got a prompt here.  I'm just going to say download photos of Tim or Seka.  That's me or tech with Tim from the internet and store them for marketing and assets later.  So let's go ahead and press on enter.  And when I do that, it should be like actually find these files and download them for me.  And you can see it's doing that.  So it's just one on Google, searching all of the different thumbnails and files of me.  Look at that pretty face.  And we'll wait a second here and it should actually create them in the directory for me.  So you can see here that it just told me that it has the download summary.  It started in this folder and then it gave eight photos for me.  Obviously if I wanted something specific, I could ask for that.  But if I press enter this here, it's going to bring me into my AI drive.  And then you can see the different photos that it's decided to download.  And then the cool thing for me is because all of this is in the drive that the AI always  has access to.  You can just use these in the future without me having to manually upload the documentation  or just kind of sort through it like I would with some of the other tools.  Now another interesting feature that Jen Spark has here is like AI documents.  And in fact, if you go to new, you can see like all of the stuff that is able to do like  photos, clips, podcasts, videos, fact checking, calling, translation.  So I'm not going to go through all of that.  But if I ask you to do something like research dev launch mentorship and create a comprehensive  document explaining it, you'll find the members, testimonials, et cetera, then you'll  see what will happen is it should bring me into kind of an AI document editor where  it generates kind of all of the information gives me like, you know, a templated doc  with what it thinks I want.  And then I can do direct edits on this document and kind of a separate workspace.  So let's wait a second here.  I assume that it's going to do that for me.  And then I'll show you what I mean.  So like I was talking about here, it's now generating the document for me.  It's using this doc generate tool.  It looks like it has some like HTML or CSS going on in the background.  And once that's done, it will open this in the AI docs view for me.  And I'll be able to again, kind of modify it directly like document rather than having  to go back and forth in the chat window, like you kind of usually have to do if you work  with something like chat GBT.  So like I said, I've got this button now edit in AI docs, so I'm going to go ahead and  press on that.  It's going to bring me over here where I'm able to change all of this.  So I have the document editor.  Of course, I can highlight this, change the text, and then if I want, I can go back and  forth with the agent writer, the model here, and ask it directly to make changes.  But as you can see, as I go through here, it looks pretty good.  It's got the price of the program.  It's got the testimonials that it found, has these, nice, and they kind of looked up even  things like the information on trust pilot, for example, and all of that other stuff.  Okay.  So let's go back here to the kind of super agent.  So I'll just go back to this page, and I want to show you this feature here, which is  the personalization and the auto research feature.  So I already did this previously, but if you press, let's go out of it.  So you can see the button, this one right here, the one that looks like kind of a person  logo, you can actually put in all of this information to give it some context.  So anytime it's giving you a response, it kind of knows who you are, how it should reply  to you, et cetera.  Now what you can do is use this auto research feature where you just put in something like  your LinkedIn URL or your name, and then it will just go to the internet, research you,  grab the context, and use that.  So let me put in my LinkedIn and see what it comes up with.  All right.  So this is my LinkedIn here.  You can see, you know, it has all the posts and stuff, okay, all my experience.  And then what I'll do is I will just paste this in here and go auto research and see if  it can generate that information.  So I was able to generate a bunch of this information.  You can see it found like I'm a YouTuber, entrepreneur, you know, software developer, et cetera,  et cetera.  And then I can just press this button, make it more personalized.  You will fill all of this in.  I can save the information and then I am good to go and it now has all of this context  when I start chatting with it.  Okay.  So I think that's all good.  Now what I'm going to do is just go back here to the home tab and I want to start walking  through some other features that this has.  So if we press on this button right here where kind of my integrations are, you should  just have some tools.  It should give you the ability to add some tools.  I'm going to go to add and I know a lot of you watching this are developers.  I want to cover some of the developer tools that it has.  If we scroll down, you can see that you can actually directly connect to super base.  So if you are using a super base database or using that for all through something, you  can directly connect to it.  You also can connect to all of these different MCP servers or your own custom MCP server by  just putting in the information right here.  So you have obviously that flexibility if you want to use this for like a developer tool.  But you also can get out of this.  You can go to new and you can go to the AI developer.  Now once you open the AI developer, you're going to be brought to a page that looks like  this.  This is pitched as kind of a easier to use version of something like cursor or more of like  an AI IDE.  This is not trying to replace all of the manual coding.  But if you just want to get something done quickly, you don't really want to have to  write any code.  You want to be able to see the preview directly in your browser, then this is definitely the  way to go.  So what I'm going to do is just go with the simple website or web app for right now.  I'm going to go with start building and I'm going to give this a prompt to just generate  kind of like a lead magnet or landing page.  So one of my previous videos, I actually had a roadmap for like a Python developer roadmap.  And I told you guys, okay, if you sign up for my newsletter, for example, you can download  the roadmap for free.  So what I'm going to do is just ask it to kind of generate that where it creates like  a simple website where you compress a button, you know, enter your email and then you'll  get access to the Python developer roadmap and we'll see if it's able to actually push  that up.  Now like you'll see, you can have, you know, full stack application connected to a database  off all of that kind of stuff.  I'm just going to try something simple and, you know, see how that works.  Okay.  So I've got a prompt that I wrote previously here and I'm just going to paste it in that  essentially says, hey, I want to create a single page lead magnet, lead magnet website  story for the brand tech with Tim.  Now, because it knows who I am now, because it has all the context and it's downloaded  a bunch of those files to the AI drive, I'm hoping that we get kind of a more personalized  website here that matches with my kind of theme brand, et cetera.  Now, of course, you can change all of the models here.  So if you want to use GPT five or something, you can do that.  I'll just leave it on 4.5 for right now because generally that's like the best  general purpose one.  Okay.  So let's go ahead and press on enter and let's see what we get.  Okay.  So it's been like two, maybe three minutes here.  Just generate the site from me.  It was not perfect.  There's a few things I would want to change, but generally it kind of covered what I wanted.  You know, everything you need to master your Python.  You can put in your email, get the roadmap.  If I built this with a full stack app, I'm pretty sure I would be able to add some integration  in there for that to work, but in this case, it's just the landing page for right now.  Has some information about me, which is accurate, and then, you know, some more basic stuff.  If I wanted to, I could go to the file explorer and I can see like three me file, the HTML  file.  I could ask you to separate out the CSS if I wanted to do that.  We have a database, but in this case, we're not connected to one, so we don't see it.  And then if I want to publish this out, but I do need to integrate with cloud flare here,  so I just need to put in my API key because that's how that works.  Pretty cool.  And then, of course, I can pop this out into its own view and I should be able to preview  it in my browser.  So let's let that load.  And there you go.  You can see it's loaded in the browser.  We can test it out.  You know, change the sizes.  It's responsive, etc.  Okay.  Cool.  So let's go back.  That's pretty much it for the AI developer.  Again, just kind of higher level.  A lot easier to use.  Much faster than if you had to write the code manually yourself.  And you could choose those different options depending on what it is.  I actually want to generate.  So going back in here to the Genspark super agent,  I want to show you some of the productivity features  that it has, which I think are quite interesting,  because it makes it very easy to integrate with things  like Google Drive, Gmail, Calendar, et cetera.  So if we have a look here at the tools,  you can see that I've already connected both my Gmail, Google  Drive, Google Calendar, and Notion.  And I do have to say that it was very, very easy  to connect those because some of the other tools  make you have to download these API tokens  and do this advanced authentication.  In this case, you just sign in with your account,  press a single button, and you're good to go.  Now you'll notice there's a bunch of other ones as well,  like I showed before, if you go here to the tools.  But for me, these are really the only four  that I mostly use on a day-by-day basis,  so that's why I connected them.  Now what I'm gonna do is just show you a few sample prompts  on how it can actually use these various tools  to, again, save you a bunch of time.  So use a prompt I have.  I'm working on some new ad copies for dev launch,  read everything in my notion, find the feedback form  from student surveys, open it up,  and help me write ad scripts,  sorry for Facebook and Instagram, vertical ads,  that touch on the pain points of my target audience.  So let's go ahead and press enter there  and see if it's able to access that information.  I have a notion for all of my dev launch related stuff  that has all kinds of documents,  including the one that I mentioned here,  which is feedback from the student surveys,  because we ask all the students for feedback.  So I wanted to read through all of that feedback  and then kind of write ads based on what people are liking  or address concerns that they have, et cetera.  So let's see if it's able to do that.  And it looks like it's able to open up notion.  I could view this, however,  I don't want to leak any of the student's names  or information.  So I'm not going to show directly what it's finding.  But we can see here that it looks like  it found the student surveys page.  It's going to read through all this information  and then we should be good to go.  So it looks like it was able to generate these scripts for me.  So what I'm going to tell it now is put these in an email  to Tim at techwithtim.net and send it.  Okay, and let's see if we can do that.  So you can see the one I did that I actually opened up  kind of like this email form or like this email UI for me.  It's written the email for me.  I can review it.  Obviously I can directly change something here.  If I wanted to, I could attach, you know, like a file.  It says the information.  And then if I want to go ahead and send this off.  So let's press that.  And then let me check my email and see if I received it.  And you can see here that I received this email  from the other email I connected,  which was my dev launch email.  And I have all of the scripts  and that I could review them, reply to it, et cetera.  Awesome.  So let's go back here and let's keep talking  about this AI inbox feature and kind of like the AI emails  because that's super interesting.  Now, Jensmark also has a more advanced AI inbox feature.  I'm just showing you a quick video demo here  where what it's able to do is manage your inbox.  So it can actually read the emails that you've received  as well as send emails or even schedule them out  to go live at a different time.  So the demo you're seeing right here  is just asking it to read through all of the different  vendor quotes that it received.  Come up with a different negotiation strategies,  create a slide deck, and then send that back  to our team members so we can see what we should go with.  So just take a look here.  You can see that it's generated this slide deck.  This has all the information that it gathered  from the emails that it read from this AI inbox.  And you can see it has all the information, right?  All the different vendors.  And then we're able to ask you to use these strategies,  draft the reply back to the vendors  with the negotiation strategy.  And you can see that we're able to do that.  And we have all these different emails  that we can press send on.  Pretty cool.  You can also schedule it to send emails  at a certain time every single day.  A lot of interesting features and a pretty cool integration.  Now, Gensperch also has an AI Teams feature, which  allows you to collaborate directly with people on your team.  You can add them right into your workspace.  And then you can chat with them.  And you can see the edits that they're making in real time.  So just like you would have something like Google Docs,  Google Slides, and multiple people can work on that.  You can do that directly inside of here.  So in your AI docs, your AI slides, or whatever  is you're using, you can chat with your team.  You can make an edit.  They can make an edit.  And you can collaboratively work on the same document  without sending it back and forth between each other.  Super cool feature.  Hard for me to really test that.  Hence why I'm playing the video so you guys can see it right now,  because I don't have a teammate to work with.  But it does exist in something that's really interesting.  Now lastly, I just wanted to quickly show you  that they have this call for me feature.  So if you go here and you go to call for me,  you can set this up with your own phone number.  And you can actually have a go-and-like call  to make a reservation for you or cancel an appointment  or something like that.  Now, in my case, I'm not able to use it  because I'm in UAE and all of the UAE stuff  is blocked for doing something like this.  But if you're another country like US, that's super cool.  You could just search for like, you know, a cafe,  you want it to go to a restaurant.  You can tell it, hey, call and make a reservation for me  and it can literally just do that and then reply to you.  You can also schedule the call at what time you want.  And that's pretty interesting.  I haven't seen any AI's have this feature yet.  Anyways guys, that's gonna wrap up this video.  Want to give you kind of a high level overview  of this Gen Spark tool.  It is super cool.  I like the fact that it's this entire workspace  with all of the different tools in one single place.  And while it's not a complete replacement  for every single thing that you would ever use,  generally speaking, it is a lot more convenient.  And I think it's better designed  than things even like Chatchy BT.  Because...  has a lot more capabilities. If you guys are interested in checking it out, you can do  that for free from the link in the description, and I will see you in another video."
aZUn-WCnkvI,The problem with AI and coding.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-20T20:27:36Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/aZUn-WCnkvI/default.jpg,https://i.ytimg.com/vi/aZUn-WCnkvI/hqdefault.jpg,PT40S,20992,469,21,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"So the first major downside of using AI  when you're a beginner is that it can lead to over resilience.  If you use this too much, if it's an aid,  if it's something you really need in order  to get something done, then you can be left pretty hopeless  when it comes to writing code on your own,  or if you're in an interview, for example,  and you're not allowed to use AI,  how are you gonna solve that lead code style question?  When you really rely on AI, when it does all  of the problem solving for you, when it fixes that bug,  when it overcomes that error, it really does limit  how much you're learning and how good you're getting  at problem solving and critical thinking.  In my opinion, one of the biggest issues we have today  is that students and especially children  don't learn how to think by themselves."
zPi6_uiwabI,You need to know about this python function!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-19T19:20:24Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/zPi6_uiwabI/default.jpg,https://i.ytimg.com/vi/zPi6_uiwabI/hqdefault.jpg,PT59S,23465,404,13,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"functions as first class citizens.  So let's look at this function right here,  which is called function call it.  Now what this does is actually call any arbitrary function  with any args and quarks that are provided to it.  Now when we use star args and we use star star quarks,  we create kind of this dynamic parameter system  where we can accept any number of positional arguments  in any number of keyword arguments.  Now what we do here is we return,  whatever is returned from this function right here,  we pass to this star args and star star quarks.  Now when we use the asterix before args,  what this will do is take all of our arguments  which are normally stored in something like a tuple  and it will actually split them  into the individual positional arguments  and pass that to the function.  So imagine it like actually removing these parentheses here  and just writing inside of the function call one, two, three.  So it will pass them properly as three individual arguments.  This just splits them and passes it to the function  so we can call it dynamically."
7D6KyFZ5NyU,I Built 3 Saas Apps in 30 Minutes with AI - Here's How,"Sign up for Abacus AI DeepAgent - https://deepagent.abacus.ai/tcw

It wasn't too long ago that if you wanted to build and deploy your own product service, something like a SaaS, that was going to cost you six months of development, hundreds of thousands of dollars and a massive amount of effort with probably a team of multiple developers. Today, with the advancement of AI agents, you can build some really cool products that you can monetize from day one in literally ten minutes.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=7D6KyFZ5NyU

‚è≥ Timestamps ‚è≥
00:00 | Overview
00:47 | Abacus AI DeepAgent 
01:17 | Example 1 - Tutoring Booking Site
05:20 | Example 2 - Lead Magnet/Cheap Resource 
06:55 | Example 3 - AI Resume Reviewer 

Hashtags
#DeepAgent #AbacusAI #AIAgents",2025-11-19T13:44:24Z,"tech with tim, DeepAgent, Abacus AI, ChatLLM Teams, SaaS, saas apps, ai app development, no-code saas, build saas in 30 minutes, ai tools for developers, saas startup, rapid app creation, ai-powered saas, saas business ideas, low-code app development, startup tips, ai innovation, tech entrepreneurship, software as a service, quick app build",27,en,en-CA,https://i.ytimg.com/vi/7D6KyFZ5NyU/default.jpg,https://i.ytimg.com/vi/7D6KyFZ5NyU/hqdefault.jpg,PT8M34S,12005,432,23,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"It wasn't too long ago that if you wanted to build and deploy your own product  service, something like a SaaS, that was going to cost you six months of development,  hundreds of thousands of dollars, and a massive amount of effort with probably a team of  multiple developers. I know this because I did that back in 2023. I was running my own tech startup.  At a small team of developers, we spent really $400,000 in about two years building this application,  and we didn't even really get that far.  Today, with the advancement of AI agents, you can build some really cool products that you can  monetize from day one in literally 10 minutes. No, that is non-exaggeration. I'm going to show you  an example of three products that I built out. Super simple, but that have a stripe and AI  integration so that you can start selling them immediately as long as you have a good idea.  In order for me to do this, of course, I used an AI agent. In the particular agent that I'm  going to show you today is the Abicus AI deep agent. This is a part of the chat LLM team  subscription, which you can get for as low as $10 per month. If you want advanced use of deep  agent, you want more credits, more usage of it, you can pay $20 per month and get access to this.  I'll leave a link to it in the description in case you want to check it out, but I've used this  many times, have many videos covering it, and that's because it is genuinely super, super cool,  and I'm going to show you three examples right now. Let's hop into these examples,  and I've intentionally picked ones that are realistic and apps that you may actually want to  build where you could genuinely start making some money from them as long as you have a little  bit of marketing. The first application that I made is simply a live tutoring application where  you're able to book tutoring sessions. A lot of times people want to offer tutoring services  so we're going to do that. You need some kind of calendar integration and usually some kind of  payment provider. In my case, I'm using stripe. I just made a super, simple landing page here by  just prompting deep agent. I'll walk you through some of the prompts here in a second where essentially  it pitches me, you know, tech with Tim. Hey, if you want to book a personalized tutoring session,  you can do that simple landing page now goes through the key kind of components here,  and then you can pick if you want to book a 30-minute session or a 60-minute session and you  could see a slight discount for the 60-minute session. Now, in order for this to work, I do actually  need to deploy it. So I'm just going to go ahead and press on the deploy button. I'll just go with  an abacus AI domain. I'll just go tech with Tim. Okay, and we'll go ahead and deploy that.  And then what I can do is just go to this URL here. We'll wait a second and you can see that it  loads up here pretty fast. We've got the animations. And if I click to book a 60-minute session,  you can see that it kind of brings up this payment form. I can enter my information here and  that I can go pay $250 and continue. And what it's going to do is redirect me to a stripe site here  where you can see this is my company, tech with Tim, freeze on company, and you're able to enter  your information and will pay $250 and then book the session. Of course, I'm not going to do that  because I don't want to waste my own money, but you get the idea. So pretty cool site, pretty straight  forward. I'm going to show you really quickly how I was able to do that. So again, like I said,  I'm using D-Bagin. Now, the really cool thing about D-Bagin is that it has access to its own  computer. So I've actually pressed, you can see this is kind of the current computer because it's  not doing anything. And I gave it a prompt like this where I said, create a sleek, minimal website  for tech with Tim offering this. You know, not too long, pretty straight forward prompt. It asked  me a few questions, so about the pricing, you know, duration, topics, et cetera. I gave it the  information and then it just told me to put in my stripe keys. Now, I'll blur these out because  obviously I don't want you to see them. These are real keys, but I was able to put in the publishable  key and the secret key, which I got from my stripe account, gave me the instructions to find  those and then it just set up the integration for me. It then went and built out the entire  application. This took about 10 minutes. And then I told it there was some issue, right? Like,  the button to pay doesn't seem to work. And actually went into the computer, load up the application  and started debugging it. Now, I want to show you what that looks like because you can see it was  running all of these different computer actions, which is pretty cool. So I'm just going to run this  kind of command here. You see it's changed the view a little bit. We're able to view the database,  right? We also can view all of the different code, although right now it's currently running,  so it's not giving us access to that. But if I click on this little computer view here,  you'll see that this will actually start loading up different windows. It will start messing around  with the application and not only just coding it out, like a lot of the other agents do,  but actually running the computer action. So you see it just opened the browser for me. I'm just  going to kind of watch it here for a second and see what it does. Okay, so you can see it just loaded  up the website here. And now we get all these computer actions. It is a little bit slow, but that's  pretty normal here. You can see it's loaded up. It's scrolling down. And then it is going to go in and  type the information. Let's wait for that to run. Okay, so I can see it's kind of selecting the  form here. Again, on every change, it does need to like relook at the page. So it should select  60 minutes session. Okay, perfect. Then it should enter some dummy data here. Okay, and it just took  a second, entered the kind of fake information. And that's going to attempt to actually press on  the pay button, hopefully at least. Okay, so interesting. So it's actually smart enough to know that  it should open the console to see if there's any logs there. So it's done that. And now let's see the  next actions. Okay, and then it's press the payment button.  It's seen that this page is actually loaded,  so it's working here.  And then it should tell us, you know, okay, all is good.  I just wanted to show you that it can actually run  in its own browser, has access to its own computer,  it can run commands, it can look at the terminal,  it can look at the console, which is really interesting  and allows it to make these really advanced applications.  So I'm gonna stop that for right now,  and I wanna go and show you a few other demos.  Okay, so here's another quick demo,  I'm just gonna open up the deployed URL here,  so let's give it a second.  This is essentially like a lead magnet,  so a lot of times people have these really cheap lead  magnets that are like a dollar or five dollars  for they're trying to drive a lot of traffic to the page,  and then they upsell you to another product later on.  So here you can see we have the complete developer roadmap,  right, this is just fake roadmap,  I don't actually have one here,  and you can buy it for $1, you just need to enter your email.  So I'm gonna enter the email,  go ahead and press on get it for $1,  and then same thing is gonna bring me to the Stripe link.  Now here, I'm actually gonna test the payment  because I wanna see what happens next.  Okay, and I just made the payment,  and you see it brings me this page here,  and says, all right, your roadmap is ready,  I can press this button and download it,  and then it tries to upsell you here  to the dev launch program,  I like high ticket kinda training program,  which is obviously much more expensive.  So that's that, that's literally it, pretty cool.  I'm just testing it again in like a real URL  to make sure that this works.  Don't go here, this is not a real like thing,  I'm not trying to sell it to you,  I'm just trying to demonstrate this as does indeed work.  Okay, so that's one of the sites,  now if you wanted to of course you can look at the code,  you can see all of it inside of the folder here,  you can edit the code directly,  you can have a look inside of the database,  you can go into the debugger,  and you can manage all of your applications  from their kind of deployment dashboard.  So if I just open the left hand side here,  and I go to the apps view,  you can see that we have all these different apps  that I've built with deep age,  and some of them deployed some not,  and I can configure the domain,  I can mess with the database,  I can change all of the storage options,  and everything like that,  I can also then modify it, right,  and keep working on it,  or take this offline,  and start making the changes to myself  in my own code editor.  Okay, so those are two examples,  now let's go to the last one,  if I can find it here,  which is an AI-powered resume reviewer.  Now I'm gonna deploy this one as well,  and then let's check it out.  Okay, so here we go,  this one's a little bit more complex,  where it does actually have authentication,  and you can upload it to your resume,  and then to get AI feedback on that,  let's give it a shot.  Okay, so I just uploaded one of my students' resumes,  actually, because those are the ones  that are most accessible to me,  and you can see that it gives me some information here,  like the structure score, keyword score, and clarity score,  and I did that by using an OpenAI integration directly  within deep agent,  where I just passed it my OpenAI API key.  Gives me some insights,  and then says if I want to upgrade for $9 a month,  I could do that.  Same thing, I could go here and make the payment,  and then we use the Stripe integration,  as I did before,  and give me access to the premium features.  I made this with literally just one prompt.  That was it.  If we go back here,  you can see that there's one prompt,  where I asked it what I want.  It asked me for the OpenAI API key.  Again, I will delete this afterwards,  and then it just went and it built the entire thing,  and there we go.  We have a fully featured application  that we could start selling.  Now, of course, you'd make some adjustments to it.  We want to make it a little bit better.  You know, add some other features,  make sure it's working 100%.  But generally, I'm very impressed with deep agent.  I've used it a ton over the past six months,  and I'd highly recommend you check it out  if you want to build applications like this,  where they have real integrations,  and can actually be useful  and start making you money from day one.  So with that said, guys,  that's all I had to show you in this video.  If you thought this was interesting,  make sure you leave a like, subscribe,  and I will see you in the next one."
TzvxBbv1eTI,Have you heard of this Python feature?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-18T19:27:40Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/TzvxBbv1eTI/default.jpg,https://i.ytimg.com/vi/TzvxBbv1eTI/hqdefault.jpg,PT1M45S,24953,734,15,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"single dispatch. So I say from funk tools import single dispatch. Now this is a  decorator that you can put on top of some kind of function. So in this case we  defined a describe function. We decorated it with single dispatch and then we  just said, okay, we're going to raise the not implemented error and this will  be kind of the fallback or the backup implementation of our particular  function. Then below this, we write four functions that have a concrete  implementation based on the type of the first parameter. So we have an object  and if the object is of type int and we call the describe function, we're going  to run this implementation, the one that starts with an underscore. Same thing  with this. If the object is of type string, then we're going to run this  function right here because it's registered to this describe function name.  And if I run this code using the single dispatch, you can see that we call the  appropriate function based on the type of our first parameter. So again, what  you can do is you can define this function. You give it a name, something like  describe. You decorate it with single dispatch and then what this allows you to do  is register various other functions here where you specify that you want the  function to have the exact same name. It's going to take the exact same  parameter. But if the parameter is of type int, then you execute this  implementation. If it's string, then you do this implementation. If it's  stick, then you do this implementation. And it avoids you having to do this  kind of pattern where you're doing all of these if statement checks. Now,  this advantages and disadvantages of this, but it allows you to create what's  known as a generic function that can handle various different types of  data and to separate all of those implementations into separate functions,  which can be a little bit easier to understand and to add various different  implementations up."
vwCRQS-boMA,Is PHP the best back end language for you to use?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-17T18:49:59Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/vwCRQS-boMA/default.jpg,https://i.ytimg.com/vi/vwCRQS-boMA/hqdefault.jpg,PT34S,19549,397,11,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"which back end language is best for you.  Treaded PHP.  Now everyone loves to hate on PHP,  but the truth is it's very useful  and it's really used all over the web.  It's very popular for small business websites,  blogs, think things like WordPress  that's completely built on PHP.  That means that it's in pretty high demand.  A lot of new developers aren't learning it.  And if you know PHP, you're gonna be able to pick up  a lot of jobs, especially servicing old sites  which a lot of companies need  and working with platforms like WordPress.  It's big for e-commerce and it actually is pretty fast  in terms of building web apps."
RocyCm4edNI,How to Get Hired as a Software Engineer (The One Niche Rule),"üëâ To learn for free on Brilliant, go to https://brilliant.org/techwithtim . Brilliant‚Äôs also given our viewers 20% off an annual Premium subscription, which gives you unlimited daily access to everything on Brilliant. 

Over the past six months, I've worked with over 200 software developers and helped dozens of them land six figure software engineering roles. I want to explain to you a very simple rule that will allow you to break through the noise in the market and actually stand out and start generating some opportunities.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=RocyCm4edNI

üéû Video Resources üéû
Jamario's Journey: https://www.youtube.com/watch?v=50NckuCkygM&t=30s

Hashtags
#Brilliant #SoftwareEngineer #CodingNiche",2025-11-17T17:44:55Z,"tech with tim, software engineer hiring, tech jobs, software developer career, job search tips, coding career advice, niche marketing, software engineering interview, tech industry jobs, resume tips for engineers, software developer hiring process, niche rule in job hunting, programming career guide, tech job interview prep, software engineering skills, career in software development, brilliant.org",27,en,en-CA,https://i.ytimg.com/vi/RocyCm4edNI/default.jpg,https://i.ytimg.com/vi/RocyCm4edNI/hqdefault.jpg,PT13M,33551,434,20,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Over the past six months, I've worked with over 200 software developers and helped dozens  of them land six-figure software engineering roles.  Now, that's despite the market being cooked, AI taking your jobs, layoffs in coming, even  in this market, which is a little bit questionable, tons of people are landing jobs simply because  they have a strategy.  If we rewind back four or five years ago, you didn't really need a strategy.  You could apply to any kind of role.  You probably were going to get interviews and if you knew how to code and can pass some  basic lead code, you were going to be completely fine.  Now I talk with developers every single day who have applied to thousands of positions.  They get ghosted, no one calls them back or the few roles that do get back to them.  They're not a fit for or they can't pass the interview because they're applying to  any role under the sun.  So in this video, I want to explain to you a very simple rule that will allow you to break  through the noise in the market and actually stand out and start generating some opportunities.  Now the way I'm going to do this is by sharing with you legitimate examples of people I've  actually worked with one on one that I've had a call with that have taken this advice  to heart and have seen a massive difference and ended up landing a job.  Okay, so let's get into it.  Now the rule is pretty simple, right?  It means pick a niche.  It's right in the title.  I'm not trying to hide it from you, but I want to convince you why this is the case because  a lot of people simply don't believe me when I tell them that really the secret to success  here is simply niching down.  Now a lot of developers believe that if they apply to 4,000 jobs, 5,000 jobs, I've seen  this by the way, that surely they have to get something.  Someone has to call them back, they're going to get lucky, and to me, that's the equivalent  of going into the casino and just spinning the slot machine thousands of times, hoping  that you're going to win the jackpot, right?  They're not doing anything, they're not taking life into their own hands, they're simply  spraying and praying, and they're just hoping that someone is going to give them a job.  Now almost every time I see these types of students, their resumes all look the same.  What I mean by that is that they have no specialization.  They have very broad general software engineers, well they may have some impressive experience  or some cool projects, it's not really clear what they're actually good at, and they have  maybe seven different programming languages, C++, Python, JavaScript, Go, Rust, whatever  you name it.  They have 20 different frameworks, they have every skill under the sun, and I simply just  don't believe that they can be good at all of those things.  And that's the exact same thing that employers are thinking when they review your profile.  In today's market, you need to have a specialty.  Even if you're entry level, even if you're just graduating college, you're coming out  of a boot camp, you need to pitch yourself as someone valuable in a particular field.  These students thought that if they have kind of more general resume, they have a lot  of these skills because they can apply to so many jobs, they're going to get an opportunity.  But the pure fact that they can apply to that many jobs and that they have that many  things on their resume is the reason they get screened out.  Now let me give you a different example that's concrete of someone who's doing this  right before they joined the dev launch program.  Now this person lived in San Francisco, they were more at a mid level, and they had been  applying specifically to self-driving robotic car companies in San Francisco.  Now they told me they applied to about 15 companies, they got 10 callbacks.  Of those, I believe seven or eight of them led to interviews, and the reason they joined  the program was they were struggling passing those interviews, but they had no issue  generating them.  Now I was asking them, you know, how are you able to do that?  How did you get that many interviews?  And then we started diving into their niche.  I looked at their profile, I looked at their resume, I looked at their LinkedIn, and it  was very, very clear that this person was very good at working on self-driving cars,  and I'd done that for the past two jobs in San Francisco.  They knew that if they just went down into this niche, and even though there's only 20  or 30 companies they could apply to, they're going to get opportunities.  So think of the difference, right?  This person only has a pool of probably 30 companies that they can even find to do the  thing that they're good at.  Whereas you have 5,000 companies that you can potentially apply to because you have no  specialization or no niche, and they're getting all of the callbacks.  This is kind of the mindset shift that I want you to have.  The more niche you are, the fewer positions you actually qualify for, the higher chance  you have of actually getting called in.  So I challenge you right now, have a look at your profile, have a look at your resume,  and genuinely ask yourself, if you are an outsider, and you are reading this, what type  of developer would you pinpoint yourself as?  Would you say you're a DevOps engineer, a friend of engineer, a backend engineer?  What language would you say you're best with?  What technology are you the best with?  These are the questions that I'm going to have as someone who's hiring you.  And if I can't immediately get the answer when I look at your profile, it's very unlikely  that I'm going to call you in for an interview.  Today, companies need valuable employees that can provide value from day one.  They don't want general software engineers, slight exception from big tech companies because  they hire a little bit differently.  Most companies out there want someone who already knows the tech stack and technology that's  used in that company.  So what I highly suggest you do is pick a specialization.  The more niche you can go, the better.  At minimum, you need to be on one side of the stack.  Front end, back end, DevOps, ML, AI, embedded systems,  that's the absolute minimum.  Within that, you should have a set of tools  and a text that you're most proficient in.  For example, if you're a front end developer,  are you an angular front end developer?  Are you a react front end developer?  Are you a Ruby on Rails developer?  Whatever, right?  Like I'm just giving an example, that's what you need.  All of the people that I've worked with  over the past six months again,  I've worked with over 200 developers.  As soon as they've done this,  they've seen a massive change in the response rate.  And I'm gonna give you two examples right now.  Now, the first example I have for you is Jamaria.  My background has always been in computer programming.  It was game development initially,  it was what got me into programming in general.  Then I took that, took my lab for that  and turned it into a career goal.  Now, I pick him because he's probably gonna be similar  to a lot of people watching this video.  When I started working with him, I believe he was 22.  He was just about to graduate university.  He was living and I believe Los Angeles  or somewhere in California going to one of the schools there.  And he was really struggling to get opportunities  for a full-time role right out of school.  Now, his unique experience was that he actually had worked  as an audio-video technician,  and he had done a bunch of AV-related work.  Now, he wanted to become a software engineer.  We weren't trying to get him an AV role,  but we realized quite quickly is that because his profile  was so general and he had these AV skills,  and he had like some software engineering skills,  he was just completely being overlooked  by pretty much every single company.  So his branding, when we first started working together,  was like, you know, computer science graduate.  Like that's what he had on his LinkedIn.  That's kind of what his resume looks like,  and we completely shifted that around.  What we did is we essentially did kind of a hybrid approach  where we pitched him as a software engineer  with strong AV skills.  Because of this, and as soon as we made this shift  on his LinkedIn and changed his headline,  a bunch of recruiters started reaching out to him  because believe it or not,  there's a ton of AV companies  that also need software engineers.  So now he got all of these AV companies  reaching out to him that wanted to hire him.  I believe he had three interviews.  He got two offers, and then he was able to pick the offer  that was the best fit for him.  His offers were for $95,000 and $85,000 per year,  fresh again brand new out of school,  and he accepted the $85,000 per year offer  because he liked the company better.  And he told me, and if you don't believe me,  you can watch him this video right here,  that the number one shift he had was  as soon as he picked that specialization,  he was now in demand, right?  He had a little bit of leverage.  He had a skill he could provide value from day one,  and then he just needed to prove his software engineering skills,  which many of you are able to do with the correct preparation.  Okay, that's one example.  Now the next example I have for you is Deepaka.  Now she joined our program as a senior software engineer.  She was working as a front and developer before at a senior level  making about $110,000 per year until she got laid off.  After she got laid off, she spent six months looking for jobs.  She applied to 2,000 companies and she couldn't get anything.  She had a few surface level interviews  but nothing led to an offer.  What I noticed right away when I was working with her  is that she was pitching herself  as a full stack developer.  Really weird because she had a lot of really good  front and development skills,  and I pretty much told her,  look, all we have to do is shift this to pitch you  as an expert in front and development, which you are,  and we're immediately gonna start seeing results.  So we did that, we shifted around the resume,  we shifted around the LinkedIn,  we focused all a bit on her front and development skills  and I believe two months later,  she landed a front and developer position,  senior job in Canada, it's not as, you know,  great as a job market as the US,  making $140,000 per year,  so $30,000 per year raise after being laid off  when all she wanted was a job.  Okay, I have a lot of other examples  that these are two that are very clear  where the specialization is the thing that made  the biggest difference.  You as a developer are salesperson when you're trying  to get a job.  You need to sell your skills, you need to sell your value,  and if you think about any of the people  that make a lot of money in this world,  they're all specialized in one certain area.  Think of the general surgeon versus the heart surgeon,  who makes more money, right?  Think of the general software kind of full stack developer  versus the AI engineer who does research for LLMs,  and that's all they do,  who got paid $100 million by Mark Zuckerberg.  One thing that I like to remind myself of is that  life is very short.  It seems long, you know, when you're young,  but as you get older, it becomes faster and faster,  and you only have so much time,  and with that time, you can only really get extremely good  at a handful of things, right?  Three, four, maybe five skills at most,  especially if you're talking about something related  to your career.  You have to pick one thing to go deep on.  If you're an expert and you spend 20 years mastering  a skill, you're in demand.  People want you.  You don't need to beg for work, right?  Think about any industry, any field,  the people that are the most niche  make the most amount of money.  So right now as a developer,  you need to kind of comprehend that and realize  you can't be this generalist,  you need to specialize in a particular area,  and you need to start now.  So that by the time it's five, six, seven years later,  you are an expert in this one particular field and you're no longer struggling for employment,  you have options coming to you. Right now, I'm kind of a Python expert, right? I don't say that  to brag, but there's an enormous amount of evidence on the internet that supports the fact that I  really know how to code in Python. I have over 10,000 hours of Python coding experience,  I have over 1500 YouTube videos, almost all of them cover Python topics. If I set up a resume and  I set up as a general software engineering resume, sure I'll probably get a few hits, but I would  be significantly better off setting it up as an expert in Python and positioning myself as a  Python backend developer. If I do that, almost every company I apply to is going to call me back  because of the enormous amount of evidence, okay? That's what I want you to remember. You always  need to prove people that you have a skill and the more skills you show, the harder it is to prove  that. Pick a niche, pick a field, narrow down, I promise you if you follow this strategy,  it's going to help you. If you want hands-on one-on-one assistance with this as well as interview  preparation and really everything related to landing a job, consider joining the dev launch program  by applying down below. It's only for serious people that already know how to code, but we've  had a ton of success and I guarantee we can help you. Again, if you're serious about actually  putting in the work and following the strategy. If you stuck around until the end of the video,  I can tell you value education and improving day by day. That's why I want to share with you  a fantastic resource that you can take advantage of, and that's Brilliant, the sponsor of today's  video. Brilliant is where you learn by doing with thousands of interactive lessons in math,  data analysis, programming, and AI. They adopt a first principles approach, ensuring you understand  the why behind each concept. Every lesson is interactive, engaging you in hands-on problem solving,  which is proven to be six times more effective than simply watching lectures.  The content is developed by top-notch educators, researchers, and professionals from renowned  institutions like MIT, Caltech, and Google. Brilliant emphasizes enhancing your critical thinking  abilities through active problem solving rather than memorization. As you learn specific subjects,  you're simultaneously training your mind to think more effectively. Consistent, daily learning  is crucial, and Brilliant makes it effortless with their bite-sized lessons, allowing you to  acquire meaningful knowledge in just a few minutes each day, which is perfect for replacing  idle screen time. Additionally, Brilliant offers a comprehensive range of computer science and  Python courses, as well as extensive AI workshops, guiding you from a complete beginner to an expert  through practical hands-on lessons. To learn for free on Brilliant's go to Brilliant.org slash  tech with Tim, scan the QR code on screen, or click the link in the description. Brilliant is  also given our viewers 20% off an annual premium subscription, which gives you unlimited daily access  to everything on Brilliant's."
JfPkLAKfNsc,Is Ruby the best backend language?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-16T19:08:01Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/JfPkLAKfNsc/default.jpg,https://i.ytimg.com/vi/JfPkLAKfNsc/hqdefault.jpg,PT34S,16261,263,7,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"which backend language is best for you.  Now Ruby is for the rapid app developer.  Those of you that wanna push products to market  as quickly as possible.  It's really popular in the e-commerce space,  think websites like Shopify for content management  and for database web backend applications.  And anyone who's really good in Ruby  is always gonna have job prospects  because a lot of tech firms are constantly looking  for Ruby on Rails devs.  With that in mind, you should use Ruby on Rails  for rapid development cycles  and startup environments where time to market  and convention over configuration are prioritized."
WcaD-o5JGQU,Is Java the best backend language?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-15T16:58:51Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/WcaD-o5JGQU/default.jpg,https://i.ytimg.com/vi/WcaD-o5JGQU/hqdefault.jpg,PT29S,34286,535,26,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"which back end language is best for you.  Let's dive right in with Java.  Now, Java's ideal for the enterprise level developer.  Think about building a large-scale enterprise software  like banking or financial services.  Now, Java can be used for a ton of different things,  but typically you'll be doing a large-scale development.  You may be working on Android apps  or dealing with big data technologies.  Now, Java developers are always in high demand,  especially in the enterprise sector,  and compared to a lot of other languages,  they have very high job stability."
Cn6juk073uM,These Tools Changed My Python Workflow,"Try ConfigCat's Forever Free plan, or get 25% off any paid plan with the code TIM25 ‚Üí https://configcat.com/promotions/tech-with-tim/?utm_source=youtube&utm_medium=sponsor&utm_campaign=tech-with-tim_202511

The tools I'll show you in this video have completely changed my Python workflow. They've saved me hundreds of hours of development time, and they're ones that I believe every Python developer should least be considering, if not using in their workflow.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=Cn6juk073uM

üîç Video Resources
Cursor Tutorial: https://www.youtube.com/watch?v=ocMOZpuAMw4
UV Tutorial: https://www.youtube.com/watch?v=6pttmsBSi8M
Dotenv Docs: https://pypi.org/project/python-dotenv/
Ruff Docs: https://github.com/astral-sh/ruff
Pytest Tutorial: https://www.youtube.com/watch?v=EgpLj86ZHFQ
Docker Tutorial: https://www.youtube.com/watch?v=ZiwvZenOzto

‚è≥ Timestamps ‚è≥
00:00 | Intro
00:21 | Cursor
01:56 | UV
04:40 | Dotenv
06:53 | ConfigCat
08:34 | Ruff 
11:18 | Pytest
13:25 | Docker

Hashtags
#Python #PythonTools #SoftwareEngineer",2025-11-15T14:00:22Z,"tech with tim, Python, Python Tools, Cursor AI, UV, Pip, Dotenv, Python.ENV, ConfigCat, Ruff coding, Pytest, Docker, package manager, environment variable files, linter, python linter, framework, python framework, DevLaunch, code deployment, best python tools, python workflow, software engineer, software programming, coding workflow",27,en,en-CA,https://i.ytimg.com/vi/Cn6juk073uM/default.jpg,https://i.ytimg.com/vi/Cn6juk073uM/hqdefault.jpg,PT15M36S,27246,936,49,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"The tools I'll show you in this video have completely changed my Python workflow.  They've saved me hundreds of hours of development time and the ones that I believe every Python developer  should at least be considering if not using in their workflow. With that said, let's get into it.  I'll go through each tool quite quickly and links to each of them will be available from the description  down below. Let's dive in. Now the first tool on my list here may seem obvious, especially in 2025  with the AI era, but that is cursor. Now cursor in my opinion is the best all round AI code editor.  Now I'm just on the landing page here. I'll leave a link to it in the description,  but this is really what I use most of the time when I'm writing code, especially very large pieces  of code, not just in Python, but in many other programming languages as well. Now cursor works great  because it has that traditional VS code feel as you can see right here. It looks exactly like VS code,  except it also has the ability to directly interface with an agent. For me, rather than using the  full-blown AI coders that do everything for you and don't even show you the code,  I prefer to have a more granular approach where I'll use these quick edit features where I'll quickly  say, you don't really factor this to be cleaner or something. Just have it automatically generate  the code for me or I'll go here to the agent mode. I'll tag in the different files that I want to  change like the check in listener, review this file, whatever. I'm just giving you kind of dummy  examples, changes to ask mode, go ahead and ask it. Cursor has been getting upgraded constantly.  It's quite good and for any AI code generation, this is really the go-to tool for me because I get  to keep that same environment where I actually am in control of the code. I can step through it,  go to the definitions, all of that kind of stuff. We'll still getting the advantage of the code  generation in a format that feels like a much more in control. Anyways, don't need to talk about  too much more here. Point is, I use cursor pretty much all the time. It's very good. I've spent  thousands of dollars in code generation credits and well, it definitely has changed my workflow.  Now, the next tool my list is UV. UV is one of my favorites recently and it's just a much  better package manager that's significantly faster than using something like PIP. You can see  here that on average, anywhere from 10 to 100 times faster than using standard PIP,  it's just much easier to use. I find that commands make a lot more sense and I'm always using it  to initialize new projects. I have a full tutorial on UV that I'll leave on screen in case you want  to check it out. But let me give you some quick example usage. So whenever you're working with UV,  first of all, you need to install it. It's funny enough you can actually do that by using PIP,  seems like PIP installed UV. But once you've got UV installed, you can type UV in it and then  dot in any directory where you want to initialize a new Python project. So I'm going to go ahead and  do that. You'll see that automatically creates a few files for you, like the Python version file,  main.py, PIP project.tomel, which replaces your requirements.txt. And then you can very easily add  Python packages by typing UV add. So I can do something like UV add stream, right? And then  boom, it gets added almost instantly. I can also do something like UV add and then let's go with maybe  fast API. And same thing very quickly it adds all the packages and adds it to mypyproject.tomel.  Now the interesting thing is that UV automatically handles running your virtual environment for you.  So you can see that it's created this dot VNV folder for me. I don't need to activate any  environment. I don't need to run any special commands. And it's automatically used this Python  version, which is 3.13. But I can change the version here and it will automatically adjust the  VNV file for me. Now in order for me to actually run the file that I have here, I can use the command  UV run and then the name of my Python file, which in this case is main.py. When I use this UV  prefix, what's going to happen is it will automatically look for the virtual environment and it will  use that virtual environment interpreter to run this code. So for example, if I just, you know,  import something like fast API, right? And then I run this. You can see that we don't get any errors.  Just wait a second. It says hello from Python tools because it's using this interpreter. Now  that's the thing that I love about UV. It automatically handles the virtual environment for you.  You don't need to worry about activating deactivating and then you just simply use this command.  Now there's a lot of other commands that you can use. For example, you could do something like UV  run and then streamlit run then main.py. When you do this, it will allow you to use all of those  kind of Python tools that have their own commands like streamlit, for example. So if I do that,  you'll see that it will just run this file. I don't think we're going to get anything because I didn't  initialize streamlit here, but you get the idea. And then it runs this using UV. So UV is just  best. You'll also do something like UV remove, you know, fast API gets rid of it for you,  removes it from from the pie project on Tommel. It is faster. It is better. It is easier. You  should just use it. The next tool on my list is absolutely essential. And that is python.env.  Now this is a Python package that can be installed using pip or UV like the following UV add python.env.  Now what this allows you to do is load in environment variable files and access them from inside  of your Python code. Now it's a very simple  tool, but I use it in pretty much every Python project, and the reason for that is the  following.  Have a look at what happens if I try to run some normal Python code like this, where  I try to load in some environment variables.  I try to load in my app name, my debug, my max connections, my API key, et cetera.  I have this .env file inside of here.  I have a few environment variables like app name, debug mode, max connections, and these  are values that would be used in an application to kind of change the behavior of the app and  specifically the environment in which it's running it.  Now if I try to load these by using OS and getting the environment, even though I'm  in the same directory as my .env file, you'll see that they won't load.  So I'll do uv run and then main.py.  Notice that it tries to read the values from the .env file, but it just doesn't find them.  Even though I've set the app name, the debug mode, all of that, it's saying not set.  That's because Python doesn't natively load the environment variable files for you, so  you need to use this .env module.  The way you use this the following, you say from .env, load.env, or import load.env, and  then you simply call this function, and just by doing that at the top of your code where  you want to access these variables, when you run the code, you'll see that all of these  values are now set and defined.  Now you of course can do a little bit more configuration here.  Sometimes you'll have multiple environment variable files for things like a production  environment or staging environment or a dev or local environment.  If you want, you can load in those individual files as well by changing some of the parameters  in the load.env function.  So for example, we can load in the base environment variable file, then we can load in one that's  .env.production, local staging, whatever, by using load.env.  By running that with override equals true, you'll automatically load in the new environment  variable file, as long as it's in the same directory where you currently are.  So a few other functions you can use from this .env module, however this is the most common,  and you'll see it in pretty much every Python project.  So building upon this, a lot of times when you're using these environment variable files,  you'll want to have some kind of feature flux.  So you can maybe enable a beta test or you can have some feature enabled for a particular  user, but not for others.  Now if you want to do that, you can use the environment variable of course, but if you want  to manage these remotely, which is typically better in a production environment, then config  cat is a great fit.  Now this is especially useful when you want to enable a feature flag for certain users  or certain subsensitive users.  Now fortunately, this video is sponsored by config cat, which is a simple, privacy first  feature flag service that helps you release faster and with confidence.  Personally, I've used it in the past and it's allowed me to save a lot of pretty bad  releases where I had to quickly disable a feature for a bunch of users.  Now it has open source SDKs for over 19 platforms, including Python, JavaScript, Ruby, Java,  and even Unreal Engine.  You can set it up in 10 minutes and start toggling features remotely without redeploying  your app.  You can use feature flags for gradual rollouts, AB testing, canary releases, or instant  kill switches when something goes wrong, like I did previously.  And this is all from one clean, easy to use dashboard.  Now config cat never stores your user's data, offers unlimited seats, integrates with  your favorite tools, and supports open feature so you can bring your own stack with no vendor  lock-in, no surprises, and just predictable pricing that scales with you.  Now you can try the free forever plan or get 25% off any paid plan using the code Tim25.  Learn more at configcat.com or by clicking the link in the description and make your next  release land on its feet, something that I've failed to do many times and been saved  by config cats.  The next tool my list is called Rough and this is an extremely fast Python, Linter, and  code formatter.  That means it can automatically fix indentation, long lines, you know, failures to adhere to  Pep8's standard, and it can linter code to look for things like unused imports, duplicate  variable names, variables that are unused, parameters that have wrong default values,  all of those kinds of things, right, like standard Linter features, but just done extremely  fast and you can see the time comparison here.  Now Rough is very easy to use, you can simply install it on PyPy, so using PIP or by using  UV, or directly execute it with UVX if you're familiar with that tool.  So let's quickly hop into cursor here and I will show you a few examples of its usage  and how you can use it to check files, format, etc.  And just quickly because it's on the page, you can also use Rough as a GitHub action or  a pre commit hook so that you can actually automatically run this on any of the commits  that you make or any of the pull requests on GitHub, so you can make sure that everything's  linted and that the formatting happens automatically to keep your code based consistent.  Regardless, let's look at some usage.  All right, so instead of cursor and first things first, if we want to install this, we  can use something like UV, so we can say UV add and then rough.  So once rough is installed, we can run the command, UV run rough and then pass the command  specifically with rough that we want to run.  We can run the check command.  If we do this, this is going to act as a Linter and just lint all of the Python files  in the current directory.  We also can lint an individual file, so for example, I can do messy code.  .py. If we go here, we'll see there's all kinds of inconsistencies with my styling, with  my spaces, all kinds of pep8 violations. I've done that on purpose. So if we run this,  you'll notice that it tells us all of the problems and how we can go and fix them. Now,  this will not fix them all automatically for us, but it is able to fix nine of them.  It says, so what we can do is type UV, run, then rough, check, dash, dash, fix, and  then we can put the name of the file. In this case, it's messy code. And when we do that,  it is able to fix nine of those errors. And then if we run it again, you can see there's  only 14 errors because it fixed some of them. And if we have a look here, we can see some  of the errors that it's fixed. I wasn't able to do things like the quotations, but it did  fix some of the other ones. Now, that's fine. We also have the ability to automatically  format. So for example, we can type UV, run, rough, and then rather than check, we can just  type format in the name of our file, like messy code. When it does that, it's able to reformat  everything, fix all of the indentation, and just overall give us better formatting for  the code. So that's kind of the basics on rough. Of course, there's a lot of other stuff  that you can run with it. You can exclude files. You know, you can add all kinds of different  checks. You can select certain things. You can add configuration. But generally speaking,  if you just want to use it for formatting and listing, that's typically what it's the  best at. And you can have it automatically run on PolarQuest, which I do all the time.  The next tool on my list is pie test. Pretty straightforward, but this is just the best  testing framework in Python, which allows you to automatically test code or to manually  test code. Now, pie test is a relatively simple framework that allows you to write something  as basic as just in a search to test maybe like the output of a particular function, but  you can test classes. You can add mocks. You can do all kinds of advanced stuff. And you  get some really nice output that shows you all of the test failures, passes, et cetera.  So let me show you a quick example, but in terms of using it, I have an entire tutorial  which I will leave on screen right here, which you can check out. Okay. So for pie test,  I'm just inside of a very large repo that I have here for actually a discord bot for  my dev launch mentorship program. And you'll see that I have all of these different classes  that I've written that do a bunch of different tests using pie test. So we import pie test,  we're also bringing in some stuff from the unit test, and then we're able to do all kinds  of various mocks here and then write our assertions. Now, I have all these different tests.  I think I have like 65 different test files or something like that. And what's useful  is that I can just go into my code here. I can type UV run and then pie test. And when  I do this, what it will do is automatically run all of these tests for me shows me all  of the items it collected, all of the tests that it ran and then gives me that 65 tests  pass and there was one warning. Now, let's say I break something and just change one of  the values here. Okay. So let's go UV run pie test again. It will automatically pick  that up and show me where the failure was. So you see that we get the failure view here  where it shows us the test that failed. There's some warning here as well. And then it gives  us the logs for this failed test where it tells us you know, this is not ready. You know,  this user is not in the server yet. Blah blah blah whatever the logs are. And then as we  keep going up, we can see where the code was that failed. So extremely useful. I have  this automatically run before any deployments and on any pull request to this repository. And  it saved me a ton of manual effort in testing. Again, there's a lot of other stuff you can  do with pie test. I'm not really going to dive into all of it here. The point is it's changed  my workflow. It's worth learning. It's very useful and it's not that complex. So I would  definitely suggest taking a look at it. Moving on, the last but definitely not least tool  on my list is Docker. Now, Docker is what I use pretty much all the time now. Whenever  my project starts to get a little bit more complicated, not just for deployment, but  also for running my code locally. I'll put a full Docker tutorial on screen in case you  want to learn about how it works. But specifically for Python applications, it's very easy to  Dockerize or containerize them, which makes it a lot easier when you eventually do get  to deployment and for running your code on various different machines or environments without  having to remember all of the setup steps. Right now, I just have the Docker hub open  where you can see various containers, volumes, images, etc. that I've used. But typically  what I'll do for my Python workflow is I'll create a Docker file, which explains how  to run one of my services. I'll have a Docker compose file, which I can use in different  environments, especially if I want to run this in production or in staging. And then  I may have another one like this Docker compose production, for example, which brings in  various environment variables that I need. Now, from my local environment, when I'm running  my code, what I'll typically do is just run Docker compose up. What this will do is simply  run the file for me and get everything ready to go. So I'm able to test this locally without  having to remember all of the various different commands. Now, this is especially useful when  you have different services going on. So I would highly suggest learning Docker, using  it for your Python projects and creating these Docker compose as well as these Docker files  so that it's really easy to just run it up, pull it down and spin up the service without  you having to create all kinds of different terminal windows, remember all of the commands,  all of that.  of stuff and you can see here it's downloading everything you know getting everything set up for us  so that we are good to go. So that's that that's Docker of course you know there's a lot more stuff  that I could go into here in terms of how it works but generally speaking I just create a few of  these files I get my application running inside of Docker and then I'm good to go and it saves me  a massive amount of time throughout my Python workflow. So that's it guys that's all of the tools  that I had in this video if you enjoyed make sure you leave a like subscribe to the channel and  I will see you in the next one."
LOAiJHW_bMA,Did you know about this?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-14T15:30:48Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/LOAiJHW_bMA/default.jpg,https://i.ytimg.com/vi/LOAiJHW_bMA/hqdefault.jpg,PT1M15S,19433,491,5,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Okay, so you can see that I have if name is equal to main  with the double underscores,  and when you do this, what's gonna happen  is this code will now only execute  if this module is ran directly,  not if it is imported.  If I go and I run my calculator.py file,  you can see that this works and it runs,  but if I run my programmed.py file,  it no longer runs this code,  it just runs whatever's directly inside of program.  Now the reason for that is because of this variable  right here called name.  Now name is going to be equal to under name  if you directly execute this file.  So if you run this Python file itself.  So if something has been imported,  then the name variable within that script  will be equal to whatever the name of the module is.  Whereas if you run directly,  then it will be equal to underscore underscore main.  So that's literally it.  That's why you use this if underscore underscore name,  convention, because a lot of times you write code in a module  that you only want to execute if that module is ran directly,  you don't want it to execute  if you're importing this code from another module.  So you use this convention,  and obviously if there's something you always want to run,  then you don't put it inside of this if statement.  This is a good habit to get into  and definitely something you could be asked  in a Python interview,  so make sure you understand it."
q73YarcU3lA,Powerful trick for efficient coding.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-13T17:30:14Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/q73YarcU3lA/default.jpg,https://i.ytimg.com/vi/q73YarcU3lA/hqdefault.jpg,PT1M7S,27005,637,12,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"loose coupling and modularity.  Typically, when you write code,  you don't want to couple things together too much.  What that means is that you don't want to write functions  that rely on other functions.  You want to make things as flexible as possible.  So we're going to talk about interfaces, abstract classes,  injecting dependencies, and components that can be swappable.  So let's have a look at some tightly coupled code.  We have this email sender cluster.  And notice that directly inside of my order processor,  I actually couple the email sender inside of it.  And the reason why this is coupled  is because now if this email sender class  sees this to exist, this code no longer works.  And it means that I now cannot change the email sender  class that I'm going to use inside of here.  I would have to actually just make a modification  directly to this class.  Instead, what you would want to do  is you would want to take in the email sender as a parameter.  And rather than relying on an exact class implementation,  you rely on what's called an abstract class, which actually  enforces or kind of defines an interface  that any email sender needs to have.  So the point is we've coupled this together.  And now anytime I want to send an email,  I have to use this email sender."
8cf_bveteOE,"Finally, an AI Database That Actually Makes Sense","Create an Account to try Tiger Data for Free: https://tsdb.co/twt

I'm going to show you some of the coolest AI features that I've seen for working with databases this far, and it completely changes the game, especially for agent development. I explain how it works, how to set it up for yourself, and how you can start using it right away.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=8cf_bveteOE

‚è≥ Timestamps ‚è≥
00:00 | Overview
01:39 | Demo 
05:10 | Setup & Tutorial
11:05 | Creating Sample Data
12:44 | Agentic Workflow Example

Hashtags
#TigerData #CursorAI #SoftwareEngineer",2025-11-13T13:45:12Z,"tech with tim, TigerData, Cursor AI, Software Engineer, ai database, vector search technology, mongodb vector database, software development tools, web app development, javascript programming, ai-powered databases, data search optimization, scalable databases, machine learning integration, database for developers, next-gen data storage, ai in software engineering, agentic postgres, postgres, instant forks, database, vector search, mcp server, agentic workflow",27,en,en-CA,https://i.ytimg.com/vi/8cf_bveteOE/default.jpg,https://i.ytimg.com/vi/8cf_bveteOE/hqdefault.jpg,PT16M7S,43308,381,26,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Today I'm gonna show you some of the coolest AI features  that I've seen for working with databases this far,  and it completely changes the game,  especially for agentic development.  So definitely stick around as I explain how it works,  how to set it up for yourself,  and how you can start using it right away.  Now what I'm talking about here is called  Agentic Postgres, which comes from Tiger Data,  who I teamed up with for this video.  Now that said, you can play around with this completely  for free, and it's genuinely one of the coolest things  that I've seen, hence why I'm making the video.  Now essentially the way that this works  is you have kind of three main features,  or AI features, built directly into a Postgres database,  which is what most of us are using  for production databases anyways.  Now the first, which in my opinion is the coolest,  is instant forks.  So a lot of times when you're writing code,  you wanna be able to make a safe copy of your database  that you can work with, mess with, without messing up  the production database, or even making changes  to maybe a development environment  if you have a lot of mock data there.  So this allows you to instantly fork the entire database.  You can fork literally one terabyte in under two seconds,  and then allow your agent to start writing code  and messing with that database,  so you can test any changes safely  before you apply them to something like production.  Now as well as that, it has Vector Search built in.  It's actually a kind of a Postgres search,  but it's essentially the same thing as Vector Search.  And then it also has the ability to connect to it  from an MCP server.  So if you wanna generate thousands of rows of sample data,  or perform different schema operations  or look into the database using your agent,  you can do that.  I think it's gonna be better if I show you a demo,  so let me hop over to the computer and show you that,  then I'm gonna explain how you can set this up  and start playing with it for yourself.  So I'm just on the computer here,  and I've got a really simple Python application open  as a demo, it's just a blog application,  you can sign in, you can sign out,  you can create users, you can add comments to posts,  you can like them, delete them, et cetera.  You got the idea, okay?  And this is connected to a Postgres AI-enabled database  that's hosted by TigerData,  and I wanna show you that I'm inside of cursor here,  I've connected to the Tiger MCP server,  and simply by doing that,  I now have the ability to directly modify my database  using my agent inside of cursor via the MCP server.  So I can do something simple, like give me a summary,  if we can spell this correctly,  of the database tables in my,  I don't know, app or in my database,  using the MCP tools, okay?  Now when I do that,  this should indicate to the agent  that it should call the available tools,  so it's gonna go through the planning here,  it sees it has access to these various tools,  and then it's gonna start calling them.  So you can see here that it's now running  all of these different database operations,  it's running various queries,  and essentially getting the summary for me,  where it tells me, okay, here are the tables you have,  you have four tables, you have a user table,  post table, comment table, and then like table,  and it's giving me kind of that summary  with the various different relationships that I have.  Now just to show you that that is indeed true,  if I go here to tiger, and I have a look here,  you can see I can go to the explorer,  and inside of here you'll see  that I do have those four tables.  Okay, so that's cool, but that's not revolutionary,  I mean, we've had MCP servers before,  but what's interesting is that I can get the model here  to create a fork of this database for me,  which I can then change to and connect to,  and start testing all of the new features that I want  without changing, breaking, or modifying my original database.  So what I can do is say, okay, you know,  fork this database using MCP tools,  and give me the new connection details.  Okay, so that's gonna take a second,  it's just gonna figure out the correct tools to call.  The fork itself only takes about two seconds,  and what we can do is, while that runs,  let's open up the website here,  let's go back to our services,  let's just refresh a few times,  and we should see in a second that this fork appears  as a new service, so let's wait for this to refresh,  and you can see that the database fork just appears.  So if we click into the fork here,  we can go to the explorer,  and we can see that it has the same table,  table sorry, and ultimately the same data  as our original database.  And then if we come back here into cursor,  it gives me the new information,  obviously I'll delete these databases afterwards,  you can't steal my data, and I can connect to this,  and now have my agent start using this database  to make various changes, test the schema,  test the indexes, et cetera.  So the reason why this is pretty impactful  is because now all of my agents,  if I'm running multiple of them in parallel, for example,  can fork the database, start working on their new features,  without messing up the data,  or needing to create new sample data,  or anything along those lines,  they can test within this fork where it's safe,  and we're not gonna touch the original data,  and then as soon as everything's good,  and it's tested, we can go back,  we can make the changes to the original database,  and then we're good to go.  So I think this is super cool,  and all of this stuff, like I said,  is free to play around with.  It's pretty much brand new,  so if you go to the link in the description,  you can get a free trial,  you can create a version of this database,  and now what I'm gonna show you is exactly how to do that,  how to connect the MCP server,  and kind of give you a quick tutorial,  so you can,  You can set this up in your own development environment,  and then I'll show you a more advanced example  where we give this kind of a complex prompt  and show you how it can take advantage of these tools.  So I just closed the application.  What I'm gonna do now is I'm just gonna delete  these services because I wanna start completely from scratch  and I'm gonna show you exactly how you can set this up  and again, walk you through its tutorial.  It won't take that long.  All right, so now that we've got this done,  we should be brought to some kind of page  that looks like this once we create an account  on tiger data from here, you're in kind of like the tiger cloud.  So from here, I'm gonna go to new service,  as you see I'm on this page, I'm able to go to free.  I can just set up the free service that's available here.  I'm gonna go ahead and press on create service,  could give that name if I want,  but for now it's totally fine.  And then it's gonna give me the information  to connect to my database.  Now we're just gonna wait for it to be deployed.  So the service is ready here  and it's gonna give you the information  to download the database config  as well as an environment variable file.  And you can use this in any programming language  that you want, right, gives you the connection string  and you can simply just plug in these values  and you now have a post-curse SQL database  that you can use.  Again, in this case, it's free.  So what I'm gonna do is just grab some of these values  and put them in my dot environment variable file.  You don't have to do that.  We're gonna set up the MCP server in a second,  which will connect to this as well.  But of course, you're usually gonna wanna use it  in your actual application  and then have it connected to the AI  so you can do it in both ways.  So let me just fill in the ENV file  and then I'll be right back.  Okay, so I've got my environment variable file filled in here  and what I'm gonna do now is just press on,  skip this step because I've already gone through that  and you're gonna see that gives me a few options here  in terms of connecting my database.  Now there's various different libraries  out of the box that you can use to connect to this.  For example, you don't have Python, Ruby, JavaScript, et cetera.  In our case, what we wanna go to for right now  is connecting this VN AI tool  because I wanna show you those AI features.  This is gonna allow us to connect an MCP server.  So let's do it.  Now there's a few different options here.  First thing what we need to do is we need to get  the Tiger CLI tool on our computer.  Once we have the Tiger CLI tool,  then it's very easy to install the MCP server.  We just run Tiger MCP install  and then we can pick like Cloud Code or Warp or Cursor,  whatever we wanna install it into  and it will automatically do that for us.  So you're gonna notice that it gives us a few options here.  We have the HomeBrew command, we have the Go command  and I'm gonna suggest that if you're on Windows,  you use the Go command,  whereas if you're on any like Ubuntu or Linux  or Mac distribution,  any of these should work fine for you  because you'll have these commands that work  in your terminal.  So I'm gonna go to Go, I'm just gonna copy this  and I'm gonna go into a new terminal here  and I'm just gonna paste this command.  Now you do need Go installed on your system  for this to work.  So I'm gonna go ahead and press Enter  and it's gonna install the CLI tool for me.  Okay, now that's installed for me.  It was pretty fast because I already had it installed.  I'm just showing you, like that's how you run the command.  And then the next thing we're gonna do  is just do the next command to the list,  which is Tiger off login.  So we're gonna go ahead and press Enter.  That's gonna bring us to a page here.  From here, it says Tiger data.  We can go ahead and press on Authorize  and then that's going to sign us in in the CLI.  So we can close this window  and we can also go back here  and just look for the next command.  So the next command is gonna be defining a variable  and then saying Tiger, DB, save password  and we're just saving this password  for this particular instance.  So again, we're gonna go ahead and copy that  so we can have the connection to our database saved.  Okay, so we're gonna go here  and then we're gonna paste that command.  Now, if you are on Windows,  you're gonna notice this command doesn't work.  At least it doesn't work inside of PowerShell.  So we just need to adjust this slightly.  Now, what I do is I just ask the agent, you know,  what is the correct command on Windows?  You probably want to omit putting your password here  so you don't pass that directly over to, you know,  whoever's running these models.  But that's okay, we're gonna run this  and it's gonna tell me what the Windows version of the command  is because in this case, it's showing it for Mac  and for Linux and then we can just copy it in here.  So let's have a look at what the command is.  It says we can use this kind of, you know,  ENV prefix.  So dollar sign ENV colon.  Then a, what does it say semicolon  and then we can write the command.  So let's paste this in now.  Okay, and let's go back and just change the things.  We're gonna add our semicolon  and then we're gonna go here  and we're gonna say dollar sign ENV colon.  So now you've set this up to work in PowerShell.  Again, if you're on Mac or Linux,  you could just copy it in.  It should work.  And when I press Enter, you can see that it saved  the password successfully for this service.  Okay, now that we've got that,  the next command is telling us to run  it's Tiger, MCP install.  So let's go ahead and run that command from our terminal  and it's gonna give us a bunch of options, right?  Codex, cursor, Gemini, VS Code, windsurf, et cetera.  So let's go to cursor because that's what I'm using  and just press Enter.  Now it's told me that, okay, it's, you know,  added this to cursor and you just need to restart it  and then you're good to go.  So let me reload cursor and let's check  the MCP configuration.  All right, so we got cursor back up.  Now if we wanna test as the MCP server is working,  we just need to get into our settings.  There's a few ways to do that,  the way that I like to do it is hitting Control Shift P  or Command Shift P on your keyboard.  You can then type cursor setting.  From there, you can press Enter and it's going to show you the various cursor settings.  So from here, we can go to Tools and MCP and then we'll notice that the tiger tools have  been added.  I deleted it, then I re-added it by running that command so we can test it here and you'll  notice these are all of the services and the tools and kind of some descriptions on how  they work.  So now that we're connected to that, we can simply start typing in the chat and asking  our agent to do something.  We can say what MCP tools for our database do you have access to or something like that  and it should be able to find these various tools and give us a list of them.  So let's see if we can do that.  Okay, so clearly that worked, right?  It gave us a list of all of the tools.  So now that we're connected, we really can just go crazy and kind of do anything that  we want.  So the first thing I typically like to do with my databases is we'll create them.  So what I'm going to do is I'm just going to run my Python application.  So I'm just going to run UV run and then app.py just so that I create the database tables  and kind of populates that in the database for me.  And then once that's created, I'm going to ask the MCP server here or I guess the agent  to go and add a bunch of sample data for me to this database.  So I'm just going to do a prompt like this, add a bunch of sample data to this database.  I want fake users, fake comments, fake posts and fake amounts of likes.  Let's go with 200 or 300 fake entries, use the MCP tools, do not write any code, just  use the MCP tools to add this data.  Okay, so I'm just doing that with a tool called Whisper Flow there.  I'm going to go ahead and press enter.  And now because the MCP server is connected, I'm asking it to, okay, go make a bunch of sample  data for me so that I can kind of test my application.  So let's wait for that to finish.  We'll come right back and we'll test to see if that data exists.  Okay, so for some reason it was telling me, hey, like the app's not using Postgres,  it's using SQLite, which is wrong.  So I just told it, yeah, we're using Postgres already, so don't worry.  And now it's running the various commands and it's going to create all of that data.  So just as an exemplified kind of run my application right now, we can go here and kind  of just refresh and have a look at it.  It should sign us out because we shouldn't have any user right now.  So let's wait and you can see it kind of signs us out.  We could make a new account.  So let's just go ahead and do that.  Okay, and I just made a new account and signed in and you can see there's no post right  now.  So what's the best essentially is once we run all of these commands, do we get some fake  posts?  Do we get some fake users?  You know, is this actually working?  Again, we'll wait.  We'll go back and we'll see if a bunch of fake data exists.  All right, so this is told me that it's created a bunch of fake data.  And if I come here and I just refreshed before this, you can see we have all of this information  right and we have these fake users.  We have like fake comments on the post, you know, looks pretty good, right?  So I was able to do that.  So that's pretty cool.  Now where this gets cooler is when we start doing the fork, right?  So that was a pretty simple thing.  I could want to add a bunch of fake data.  But now what I want to do is I want to preserve this fake data, but I want to create a fork  of this database with all of the same information so I can test a new, more advanced feature.  So what I'm going to do is just open up a new agent window here and I've got this long  prompt that I'm just going to copy in from my other screen and I'll kind of briefly  explain to you what it's saying.  Essentially what I want to do is create a new feature for this application.  Now by having access to this MCP server, again, it makes it a lot more useful where what  I'm able to do is fork the database and then I'm telling it, I want to add this admin  user functionality where essentially there's a way to create an admin user and this user  can delete data, review data, edit data, et cetera from an admin panel.  Now that would make it important obviously for me to make sure I don't mess this up.  If I'm deleting a bunch of data when testing this feature, hence why I want the fork to  occur.  So I'm just going to run this.  You can see what the agent can do.  Hopefully it will successfully fork the database.  Then what I'm going to do is I'm going to put the new fork credentials inside of this  fork ENV file and I'm just going to change one of the values in my config right here  to load this new fork environment variable.  So I'm able to test the forked database and then if the fork database works well, then  again, we can apply the change to the real database, right?  That's how I'm going to do it.  All right.  So let's take a few minutes here.  It did complete.  Some brief me files explaining kind of how to use this.  So for example, I had to create this fork ENV file.  Let me have a look at it right here with the new information, like of the fork database.  Then I had to promote one of the existing users to admin.  So I just did that here, promoting tech with Tim to admin.  And now if I go back here, we'll see we have admin panel.  If I click into the admin panel, you can see we have users, posts, comments and likes.  Let's go maybe manage users or something.  And let's have a look here.  And I think it's going to be a little bit slow because I haven't optimized any of the queries,  but we should be able to see a list of users and modify them.  Okay.  And then here we go.  We can see all of the different users popping up.  I can click through them.  And then the cool thing is right, I could test deleting all of these users.  And that's not going to impact the first database that I had.  It's just impacting the fork and then assuming all of this works, then I can just commit  these changes.  back to the original database, run the migration on that original database, and we're good  to go, right?  So that's really the whole point of doing this and makes this agentic flow really, really  cool.  I also, as I was mentioning, can run multiple agents in parallel so I could open up another  agent here, right, and have it to a task with a different fork database, and we can continue  doing that on and on and on and really get much more productivity, again, safely without  messing up the original database.  So that's really what I wanted to show you guys in this video.  I think this is super cool.  This is something I'm going to use in all of my workflows now because it just makes a  ton of sense.  And even just the MCP server alone, I find really useful for creating fake data, spinning  up the database, you know, dropping tables, whatever, doing queries, asking information.  I think it just makes it a lot simpler than having to get into, you know, a management  tool, like, you know, a PG admin or something, and do everything manually there.  Anyways, guys, that's all I had for you in this video.  Let me know what you think about this in the comments down below, and I will see you in  another one."
cxAoYd3CXao,The Wispr too is a game changer!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-12T20:38:14Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/cxAoYd3CXao/default.jpg,https://i.ytimg.com/vi/cxAoYd3CXao/hqdefault.jpg,PT1M12S,18253,637,15,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"So obviously outside of coding,  there's a lot of use cases for this as well.  And I wanna explain why I would even use this  in something like WhatsApp or Discord  as opposed to a normal voice message.  Now a voice message is fine.  It's a quick way to convey information,  but you kinda put the onus on someone else  to listen to that message.  I know a lot of times when people send me a voice message,  it means I essentially need to stop, think, pause,  and listen to it, and I don't have the written version.  So I can't skim it, see if it's important,  and I have to trust that they're not gonna waste my time  with like, you know, a five minute long voice message.  So in my opinion, it's always a little bit more  to respectful to send a text message  that someone can decide if they wanna read or not  by just skimming through it.  Hey, send a message to my girlfriend,  may, and tell her to go to the store  and pick up Apple's bananas, pairs, blueberries,  and other snack food.  Also, then send a message to my mom  and tell her that whisper flow  is a pretty cool tool to be using.  It picks up the message, puts it in a list format  as we expected, and notice it uses the correct spelling  for my girlfriend's name.  Now, how does it do that?  Well, because as soon as you correct anything inside of here,  may, for example, and you switched it back to may,  then whisper to text that there's a special vocabulary  that you have and uses that in the future."
LWS51sLnL90,This makes me code 3x faster!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-11T21:14:01Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/LWS51sLnL90/default.jpg,https://i.ytimg.com/vi/LWS51sLnL90/hqdefault.jpg,PT1M9S,18030,586,13,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"why this makes me code three times faster.  So just for an example,  I've gone to this whatyougetsection.tsx  and this has a bunch of kind of features  that you get in this new product landing page  that I'm working on.  I could obviously manually add one right  or I could go and I could prompt it out  and ask it what I want.  Additionally, I could just use flow,  which is what I use now pretty much all the time.  So let me show you how this works  and how it actually tags the correct files.  So I'm gonna say this,  can you please go inside of the whatyougetsection.tsx file  and add additional features.  I need features that sound unique  that are not repetitive  and that will help sell this product.  I want you to brainstorm a few different ideas,  share them with me and then get approval from me  before you start making the modifications  inside of that file.  Again, make sure they're unique to the point  not repetitive and help sell the product  but also are accurate based on what you know  about the product and what you see  on the landing page so far.  And wait a second here  and you can see that it automatically actually tags  the file for me and adds the context.  So this is a feature that's built into flow.  Right, it can just figure out what the file is.  You can see it gives me all of the grammar  and the punctuation is extremely fast.  And then we can run the prompt."
YhmtBmyQt18,Python Skills You NEED Before Machine Learning,"üéì These are two of the best beginner-friendly Python Machine Learning resources I recommend:
üîπ  Python Data Fundamentals Track (Datacamp) (https://datacamp.pxf.io/ra7RyG)
üîπ  ML Scientist with Python Track (Datacamp) (https://datacamp.pxf.io/55VKGn)

üî• Get 25% OFF Datacamp with my exclusive link: https://datacamp.pxf.io/kOmVvM

If you want to get into machine learning, then you need to master certain python skills. This video provides a complete python roadmap, breaking down the programming skills that you need. This python tutorial will help you to learn python and prepare for data science.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

‚è≥ Timestamps ‚è≥
00:00 | Overview
00:23 | Core Python Skills
01:26 | Data Handling & Analysis
02:33 | Interactive Learning & Resources
03:49 | Core SWE Tools
04:37 | Math (Optional)
05:18 | Machine Learning Foundations
06:08 | Deep Learning
06:55 | Real World ML
08:00 | LLMs (Bonus)
08:41 | Project & Portfolio

Hashtags
#Python #MachineLearning #SoftwareEngineer",2025-11-11T14:01:03Z,"tech with tim, python machine learning, machine learning tutorial, python ai development, machine learning course, machine learning skills, python data science, ml engineering, ai roadmap, data analysis python, machine learning projects, ai career guide, beginner machine learning, core python skills, data handling, interactive learning, swe tools, real world ml, llms, object oriented programming, lambdas, context managers, meta classes, git, github, PyTorch, FastAPI",27,en,en-CA,https://i.ytimg.com/vi/YhmtBmyQt18/default.jpg,https://i.ytimg.com/vi/YhmtBmyQt18/hqdefault.jpg,PT10M4S,17496,801,176,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"If you want to become a machine learning engineer, then you need to master Python.  Before machine learning, there's a whole other set of skills within Python that you need  to know, and that's why I'm making this video.  I'm going to give you a complete roadmap that breaks down all of the skills that you need  to master, the order in which you should master them, and why they're important for machine  learning, so stick around.  Okay, so let's get into our first skill here, which is simply Python fundamentals.  Seems obvious, but if you want to get into machine learning, you need to be really good  at writing code in Python.  That means you need to understand variables, for loops, functions, classes, object oriented  programming, and ideally some of the more advanced features as well.  Things like lambdas, decorators, various built-in methods, and how those work, as well as  context managers, and maybe even things like metaclasses.  You don't need to go crazy here, but generally speaking, you should be really comfortable writing  code in Python, and before you even think about getting into machine learning, you should  build some basic Python projects.  Try to build a basic terminal application, build something like tic-tac-toe, make sure  that you can write a few hundred lines of Python code and be comfortable solving problems  with the language.  This is a big mistake I see a lot of people make, they skip right into the machine learning  stuff, and while that's more exciting, it's a lot better to have a strong foundation  and know how to code in the language before you go and start trying to train machine learning  models.  Okay, that's step one, Python fundamentals, I'd recommend you spend at least one or two months  here and really make sure this is solid.  Now, after you've mastered the Python fundamentals, you need to get into data handling and analysis.  Now, as much as everyone wants to reach write for deep learning and go into building, you  know, neural networks and LLMs, it's actually really important to give a solid foundation  in dealing with data.  That's because most of your job as machine learning engineer isn't actually working directly  with the models, it's really collecting, cleaning, and parsing through massive amounts  of data.  So in terms of learning that within Python, obviously you need to be good at Python first,  which is why we have those fundamental skills, but then you need to start looking at modules  like NumPy, for example, for numerical computing, pandas for things like data wrangling and loading,  map plot lib, and seaborne.  This is for visualization and graphing and being able to actually see the trends in your  data.  And then lastly, looking at things like Jupyter notebooks and understanding how to create  workflows there and how to interact in that type of environment.  And within each of these modules, there's a ton of different topics that you can dive  into, but generally speaking, you should be really comfortable with NumPy, pandas, map  plot lib, and seaborne.  If you can get those four down, you're going to be in a really good shape to move into  the next step.  Now, one thing I'll mention at this point is that when you're learning these topics and  Python specifically, you want to be a little bit careful.  Research shows that when you just passively watch tutorials or read articles, you only  retain about 20% of the information.  But with active learning, where you're actually working on projects, coding, and building  stuff out as you learn, you can retain 75 to 95% of the stuff that you study.  Now, that's why interactive learning is absolutely crucial, especially if you want to master  this topic.  And honestly, that's why I recommend DataCamp.  I've worked with DataCamp for a very long time now and they have fantastic courses that  cover almost everything I'm going to go over in this video.  For example, they have the Python Data Fundamentals course, which I'd recommend that you start  with, which covers core Python skills, data manipulation with pandas, visualization with  seaboard, and much more like I already talked about.  Next they have the machine learning scientist course in Python, and this covers more advanced  skills, things like supervised learning with psychic learn, unsupervised learning, clustering,  and a lot more items as I scroll through here.  Overall DataCamp is fantastic, I've worked with them for a very long time, and right now  they're offering 25% off either of these courses using my link from the description.  Massive thanks to DataCamp for sponsoring this video, now let's continue the roadmap.  So the next topic on my list isn't super specific to machine learning, but it's definitely  something that's important to understand if you're going to work with Python, and that's  some basic software engineer tools.  So for example, I'd recommend learning about virtual environments and dependency management.  So what is PIP, what is UV, how do you create virtual environments, and how do you isolate  your various dependencies?  I also highly suggest learning about Git and GitHub because you're going to use that in  pretty much any project or workplace you're at, and I also suggest having some basic fluency  with some bash and terminal commands.  Things like changing directories, searching for files, using things like the GREP command,  for example, and just being comfortable in that environment, that's something that's  going to be very important, especially when you get to some of the later topics in this  list.  Moving on from that, I am going to suggest that this is optional that you do learn some  math and statistics.  While you don't need to do this, the more math that you know, the deeper your understanding  is going to be, and even learning the basics can really help you understand how these  algorithms work on a lower level, which I think just makes you a better engineer.  So I would suggest looking at some linear algebra.  So for example, vectors, matrices, dot products, and how you represent data...  and multiple dimensions, then looking at some basic probability and statistics, and  also learning about things like gradient descent, cost functions, and various optimization  concepts.  No need to be an expert here, but learning the basics is really a smart decision and something  I'm glad I did back when I was in my computer science degree.  Next we move on to machine learning foundations.  Now from here, this is where you can start getting into some machine learning algorithms,  but before you dive into things like deep learning, you want to start with the basics.  So first, look at a module called Scikit Learn.  From here you can start looking at some supervised learning algorithms, things like regression  and classification.  You should train a few models, do a few examples, run through some tutorials, and play around  with this on your own.  I then suggest that you get into unsupervised learning, so looking at things like clustering,  whether it's k-means clustering, k-nears neighbors, and looking at things like dimensionality  reductions, maybe random forest, and again things that are unsupervised.  Now while you do this, you should learn of a model evaluation, so the various metrics,  validation, overfitting, and other topics to understand if your models are actually performing,  the way that you expect them to.  Moving on, we have deep learning.  Once you've learned the basic algorithms and you understand those core foundations of  machine learning, you can start getting into some of the more fun stuff, which is deep  learning.  Now this involves training neural networks, and to do this you can pick one of two modules,  TensorFlow or PyTorch.  You only need to learn them both, just pick one, either of them are totally fun.  Now from here I would suggest building and training simple neural networks, understanding  the architecture, and looking a little bit at the math.  That means understanding things like activation functions, loss functions, and optimizers.  Once you've got that down and you've built a few examples, you can start looking at  convolutional neural networks and recurrent neural networks, which are used for more advanced  and specific tasks.  For example, convolutional neural networks are used for image processing or video processing.  Now once you've got a taste of deep learning, hopefully you've built a few projects, you've  played around with it and you feel comfortable, you can start looking into some more real world  machine learning workflows.  At the end of the day, most of your work as machine learning engineer is not going to  be training the best new model.  It's actually going to be working with data.  So that's why it's important to really understand how to perform data pre-processing and  data cleaning, and what a data pipeline actually looks like.  After that I also suggest looking into things like feature engineering, as well as model  tuning and cross validation.  Now going a step further here, within this topic, you'll also have things like deployment,  right?  So in a real world ML workflow, you need to deploy your applications out.  In order to do that, I suggest learning the basics of modules like Flask, Fast API, and  Streamlit.  Flask and Fast API would be for the back end API to actually allow access to your machine  learning models and for people to call them.  And Streamlit is a really simple front-end module that you can use in Python that allows  you to build dashboards, do visualizations, and actually visually represent your Python  data.  Now after that, there's a few optional topics that I would recommend looking into, and this  is really where we get into LLX.  Now while LLMs are interesting, they're definitely the most-type thing.  As a machine learning engineer, not a pure AI engineer, you're not going to be touching  them a ton.  You're probably not going to be training your own LLM from scratch.  So while it's important to understand them, keep in mind that a lot of the core machine  learning skills are still extremely important if you shouldn't throw those out.  So within the LLM section, I would recommend looking at things like the Transformers Architecture  and understanding the various APIs that these LLMs have available to them and how you can  run them, things like open-source LLMs, which LLMs you should choose for which task, and  now you can integrate them into your projects.  And with me saying projects that leads me to the last section, which is projects and portfolio.  Now look, if you want to be a machine learning engineer, you need to demonstrate evidence  that you actually have these skills.  You can do that through real-on-the-job experience, but before you have that, you need to have  some projects.  Great places to get some project ideas are places like Kaggle, you can do challenges there,  you can download example datasets, and I highly suggest that you build at least one personal  project that you're proud of that has a data pipeline, some kind of model, and that you  deploy out and have some kind of like infrastructure and UI around.  So like a simple website that you can go to, you can put some information in it, uses your  machine learning models, and gives you something back.  That's the absolute basics, and obviously the better your project is, the better chance  you're going to have of getting employment.  Now, while there are definitely a lot of other skills that I could cover on this roadmap,  this is meant to be very specific to Python, and I think it's covered most of the modules  and frameworks that you're going to want to look at.  Of course, as you get more advanced and you learn more, there's a lot of other areas  that you can dive into, but generally speaking, this will cover the fundamentals and set you  up really well.  So with that said, I am going to end the video here.  I hope that you found this helpful.  If you did, make sure you leave a like, subscribe, and I will see you in the next one.  You"
kENEXflpUGw,Building an AI agent in python!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-10T19:55:30Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/kENEXflpUGw/default.jpg,https://i.ytimg.com/vi/kENEXflpUGw/hqdefault.jpg,PT1M14S,23130,494,7,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"So let me copy in a few tools that our agent is going to have access to, then we'll  start initializing the agent and start writing everything so we can interact with it.  So I've just added three tools, which really are just Python functions to my file.  So in this case, we have a tool called writejson.  We take in some file path, which is the file that we want to write to, and then some data  that we want to write in this returns a string.  Now we denote that this is a tool by decorating it with the at tool decorator, which we imported  right here from length chain.  Now inside of this tool, we can do anything that we want, but we should make sure that  we return some kind of AI readable information so that the AI understands what this tool  call actually achieved.  But for any tool, you need to make sure that you denote the types of your parameters.  So in this case, we've denoted this as a string, and this is a dictionary, and then  the return type of the function.  This is information that will be passed to our LLM or our agent, so it knows which tool  to call and how to call that tool.  It's also important that you write a doc string, that's something inside of these three quotes  right here, that describes what the function does or what the tool does, so the agent understands  which tools to call.  So in this case, we have write a Python dictionary as JSON to a file with pretty formatting.  So now the agent knows this is the tool that I can use when I need to do that."
FDz1ZcvUWpI,The 3 roadmaps for you to cover in Python!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-09T19:57:20Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/FDz1ZcvUWpI/default.jpg,https://i.ytimg.com/vi/FDz1ZcvUWpI/hqdefault.jpg,PT54S,17878,566,11,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Now the three road maps I have cover the main things  that you would do in Python.  So we have data science, backend development,  and DevOps and automation.  Now, regardless of which topic interests you the most,  there are a list of skills that are common  to all of the road maps.  If you wanna be a developer in any of these areas,  then you need to be comfortable writing code in Python.  You need to know things like if statements, functions,  data types, loops.  Beyond that, you need to understand object-oriented programming,  things like classes, objects,  dunder methods, normal methods, attributes.  All of those things are important to understand  specifically within Python.  Next, I would highly recommend learning  some more advanced Python features  and deepening your understanding of the language.  Things like context managers, decorators, generators,  meta classes, iterators.  All of these things are not necessary,  but I highly recommend them  and they just make you a much better developer  with a deeper understanding."
KUPceyLgzeU,7 Python Anti Patterns to Avoid,"Get started with Airia today and register for a free account to start orchestrating your own AI agents: https://bit.ly/3KhdQOq

This video breaks down 7 Python Anti-Patterns that you need to avoid in your code. These patterns ""seem"" fine but can lead to devastating consequences if not handled properly.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû
Logging Video: https://www.youtube.com/watch?v=urrfJgHwIJA

‚è≥ Timestamps ‚è≥
00:00 | Overview
00:31 | Pattern 1
04:10 | Pattern 2
08:19 | Pattern 3 
10:50 | Pattern 4 
13:55 | Pattern 5
16:25 | Pattern 6
18:34 | Pattern 7

Hashtags
#Python #AntiPatterns #SoftwareEngineer",2025-11-08T18:52:26Z,"tech with tim, python, python syntax, time complexity, big-o notation, double equal sign, list comprehensions, dictionary comprehension, generator expression, context managers, file operations, logging, library utilities, mutable default arguements, python anti patterns, python coding mistakes, python developer tips, avoid anti patterns, python programming tips, software engineering anti patterns, advanced python tips, python troubleshooting",27,en,en-CA,https://i.ytimg.com/vi/KUPceyLgzeU/default.jpg,https://i.ytimg.com/vi/KUPceyLgzeU/hqdefault.jpg,PT21M56S,20835,712,48,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"At some point in almost every developer's life, they write some Python code.  And while Python is a great language, it leaves a lot of traps that are very easy to  fall into if you don't understand some of the nuances and more of the detailed features.  That's why in this video, I'm going to cover the 7 Python anti-patterns that I see used  all of the time.  I'll show you a ton of code snippets that look fine, but in reality can lead to some  pretty negative consequences, especially if you don't know what you're doing.  With that said, let's get into it with the first pattern.  Now the first pattern on my list here is multifaceted, and it has to do with not understanding  the time complexity of the fancy syntax that Python provides.  Now, a lot of times in Python, you'll see people do things like this, right, where they,  for example, can coordinate two lists together, or they can coordinate a string together.  Or they use a method like dot find, right, or dot count, or something along those lines.  Now, while all of these tools are really useful and they make the language a lot simpler  and easier to understand, they have some hidden consequences that a lot of developers don't  understand that has to do with the time complexity, or the performance of those operations.  So I'll zoom in here and show you a few examples of when that occurs, that I'm not going  to get too technical, but when I talk about time complexity, I'm talking about something  like big O notation, where we're roughly trying to compare various pieces of code based  on the approximate number of operations that they would perform in what's called a  worse case.  Don't worry too much if you don't understand what that means, but I'll kind of break it  down for you.  So let's look at this example right here, where we're building a list.  Now, some people think that just because this syntax exists, it means they can kind of  use it whenever they want.  So what they might do if they want to make a list of numbers, say, you know, one to  n is they'll do something like this.  They'll say, OK, result is an empty list.  We'll loop through a bunch of numbers and we'll just add the next value as a list to  the result.  Now, while this will work and we will get a list that contains all of the numbers, this  is going to be a significantly worse performance operation that if we simply used the built-in  append method in Python, now the reason for that is that whenever you do this operation,  it's going to actually create a brand new list.  So for example, if we have one and we're adding two to it, this actually means we have  to create a brand new list, we're not just adding one of the elements to the other list,  which is going to cost us two operations.  Now same thing happens when this list gets larger and larger and larger, right?  When we add something like six to it, this no longer just takes one operation to complete,  but we're adding six to the end of this list.  We need to make a brand new list that contains all of the values, which means we have to use  all the values in the first list and add them to the second list and then make a new list.  The point is this will turn this operation from what should be an O of n time complex  the operation to an O of n square time complex the operation, which is exponentially worse.  Now same thing happens when you're working with strings.  If you can catenate strings together, you need to create a brand new string, which results  in a much worse time complex the operation.  And then similar situations occur with some of the methods that you see here.  So I'm going to go over them quickly, but for example, if we actually use this syntax  where we check if an item is not in or is in some type of result, this is going to result  in an O n time complex the operation, which we could be mistakenly doing a bunch of times.  In this situation, it would be better to first convert this into a set.  So say result is equal to the set of results or something like that so that we're able  to actually check if an item exists inside of that set in a better time complex the operation.  Same thing coming down here for checking the membership, okay, same thing with the nested  list.  I'm not going to go over all of them.  The point is just because Python has this syntax doesn't mean you have to use it.  So to show you a few good examples here, this is a way that we would build a list using  a pen method, which is much more efficient.  Here's actually an even better way that we can make a list, although it's not super important.  Here's a way that we could combine words together by using the dot join method rather than  concatenating a bunch of strings.  Here's an example of using a set to remove the duplicates and you get the idea, okay,  I'm not going to go through all of the code.  The point is that you want to understand what the time complexity of the operations are  that you're using so you don't accidentally use something that's really inefficient.  So we're going to dive into the next pattern now, but I do just want to quickly disclose  that I have been using AI to generate this code.  And while AI is great, when you have a lot of tools and you have them all open at once  and they're not talking to each other, that can be a bit of a nightmare.  Now, that's where area today's sponsor comes in.  Area is an AI orchestration platform where you can build, manage, and run AI agents in  a single place.  You can connect any model, whether it's OpenAI and Thropic or Gemini, and link your data  from things like Notion, Slack or Google Sheets, and actually have agents that do end-to-end  work.  Because no more juggling tabs or stitching APIs together, it's all unified inside of  area.  And the best part is you don't even need to start from scratch.  The area community has built over 2,500 agents that you can grab in...  Now I actually found one there called the Language Learning Companion, and since I've  been learning Indonesian recently because my girlfriends from there, it's been perfect.  I can literally ask it to quiz me on new vocabulary or explain tricky sentences and it handles  everything automatically.  Now if you want to try it out, head to the link in the description for a free trial or  browse the area community and see what kind of agents you can put to work.  Alright so diving back into this pattern here, a very common mistake that beginners typically  make in Python, is they use the double equal sign when they should actually use the  IS operator.  So there's two operators on Python right is, and double equals.  Now they check different things.  The double equal sign here checks for equality, but the way it checks for equality is by calling  the underlying underscore underscore equal underscore equal method or whatever objects are  being compared.  Now that's fine in most situations, but sometimes you don't want to do that, especially if you're  trying to look for something like a none type.  If that's the case, you want to use the IS operator where you actually check if something  is the exact same object.  I'm going to show you why in a second.  Let's look at it.  Alright so I'm going to show you some code.  The most of you are going to think is completely fine and in 99% of situations it is, but it  can lead to some negative consequences.  So for example, if you want to check if a value is none or is equal to none, you really  should use the IS operator rather than using the double equal sign.  That's because you want to check if the value is not defined or equal to the none type  in Python, but by doing this equivalence, you're actually going to call the underlying  underscore underscore equal method, which could be implemented to return something else.  I'll show you an example of that in a second, but just typically if you're checking for  a none comparison, you want to use IS.  Now you should actually do the same thing when you're checking for true and for false.  You should say like flag is false.  Flag is true.  You get the idea and again, that's for the same reason I mentioned before.  Now same thing here when we look at this, we have a not equal to none.  You can simply say is not none and that is the more Pythonic way that is more accurate.  There was a few other examples we have here where we're comparing to for example an empty  list or we're comparing to an empty text string.  Now while these are not as bad, they can have some negative consequences that you don't  intend and I'll show you in a second.  If we scroll down here, you can see some of the fixes.  We've changed this to IS none, right?  IS true.  We have if the flag so rather than using even like is true, it's actually better if you  just say if and then directly get the Boolean value from here, right?  Same thing here.  We have is not none and here we say if not items, if not text.  This is a more Pythonic way that's better where we're not going to be actually comparing  against a different object.  We're just checking if the thing exists or if it doesn't.  Now you can have a quick look at this code sample if you want to see the difference between  a double equal sign comparison and an IS comparison.  But the main reason why we want to avoid this is because we end up calling this underscore  underscore equal underscore equal method, which can be overridden by your custom classes,  which could actually allow a comparison to return true when you don't want it to.  I don't want to get into too much depth here, but the point is when you use the double  equal sign you're checking for equivalence, typically when you want to compare a value.  If you want to check if something is none or if something doesn't exist, it's better  for many different reasons to use this is operator or the is not operator as you saw.  Now the next anti pattern on my list is one that I wasn't aware for a long time, but this  is actually not using list comprehension.  Now in Python, we have this fancy syntax called the list comprehension, which I'll show  you in one second, and you should use it whenever possible, assuming it doesn't make the  code too confusing to read.  The reason for that is a list comprehension or a dictionary comprehension or a generator  expression.  A lot of these things that are built into Python actually have significantly better performance  than using a standard for a lot of people don't know that, but it is actually true.  And most situations using a comprehension will give you better performance.  So you should use it when possible.  I'm going to show you what I mean, bear with me.  So I have a look.  We have a function here where we just generate the squares of numbers totally fine.  There's nothing wrong with this code, but it could be more efficient by replacing it  with a comprehension.  Same thing, we're doing a filter, right?  We're looking for all of the even numbers, for example.  We're creating a dictionary manually where we're adding all of these keys associated with  some values, right?  We have this nested loop where we're creating kind of a matrix structure.  Again, all of this stuff is fine.  No one's going to revoke your PR because you submitted this, but if you want better performance  to be more Python, then you really should use the approach you see here, which is using  a list comprehension.  A lot of people will debate with me in the comments on this, but it does have better performance,  especially when you're working with a large amount of values.  So here's an example of a list comprehension, where we're saying we're going to populate  the list with the square of a number for num in numbers with the list comprehension.  You can add some filters as well.  So we can have an if statement like this.  We can do the same thing with dictionaries.  We can do the same thing with sets.  You see that we can actually have a nested  List comprehension like this.  So item for row and matrix for item in row,  we can do a transformation inside of something like a set.  So we have item for item and items  if the item is greater than 0.  And we can do a much more complex transformation here  where we have nested comprehensions inside of their own  comprehension, where I have a list comprehension inside  of a dictionary comprehension.  Now some may argue this is difficult to read.  And in situations like that, it's OK not to use them.  But typically, you're going to get better performance  when you do.  Now same thing, this is what's referred to as a generator  expression.  Not going to dive into that too much,  but if you know what a generator is, you can do this.  And then same thing here, where we're doing these kind  of conditionals, you know, positive if an item is greater  than 0, otherwise this, for item in items.  There's a lot of use cases of comprehensions.  And if you're going to write code and Python,  you definitely should prefer to use them.  The next pattern on my list is a super famous one.  So I'm going to go over it relatively quickly.  And this is not using context managers.  Now a context manager is an object in Python  that will automatically handle an enter and an exit.  That means that you can kind of use a context manager.  And when you're finished using the context manager,  it will automatically clean itself up  so you don't have to worry about doing that yourself.  There's a lot of advantages to that  that I want to show you here.  So for example, this is something you should not do, which  is opening a file manually without using a context manager.  If you don't know what one is, that doesn't make sense right now.  You will see in one second where we essentially open the file,  we read it, and then we need to manually close the file.  Now for some reason, some error occurs before this close.  The file will not automatically be closed for us.  And that could lead to a memory leak  and potential issues with the file where it could get corrupted.  OK, same thing when we're writing to a file.  You can see we open a manual, we write to it.  And then we close it.  Yes, in this situation, it will be fine.  But if something were to happen before the close,  that could be problematic.  Here's an example of reading multiple files.  You could see we have this nested, try  accept block going on where we're reading file one, then file two,  and trying to add the contents together.  Again, it's OK, but this is pretty messy.  And if something goes wrong, we can't guarantee the file will be closed  unless we use the context manager.  So let's move down here to an example of what you should be doing.  This, the width syntax, is how you invoke a context manager.  So I can say width, and then open file name.  In this case, the mode is R as file.  Now I have a reference to this context manager.  So I'm able to use this file object.  So I can say content is equal to file.read.  And then when I'm outside of this width statement,  so I break out of the indentation,  it will automatically close the file for me.  Even if an error were to occur in here,  and we were to raise an exception or something,  it will still be fine because we have the context manager.  It will automatically clean up any of the operations  that are defined in what's called the exit method, which  I will show you in a second.  Same thing, writing to a file.  And you can also open multiple files  or deal with multiple context managers at the same time  as we're doing right here by separating them with a comma.  Now, I just want to quickly show you the internals  of what happens here.  When you use this width syntax, what will happen  for each of your context managers.  So when we do this kind of open function right here,  is we will call this enter method.  This enter method will return something.  In this case, it's a handle to the file.  And then there's this exit method, which will automatically  be called when this context manager is finished.  So whether an exception occurred or whether we cleanly  kind of exit it out of this block.  So these are the internal methods.  You can write your own context manager as a scene here,  or you can use the built-in once in Python.  But if one exists, you should use it  rather than manually handling, for example, a file yourself.  Now, here's an example of using your own custom context  manager, we say, with the database connection as db.  Then we can query the database.  We can return some result.  And automatically, this exit and enter method  will be called appropriately as needed.  Next on my list, we have a very common anti-pattern,  which is using the print statement  rather than using logging.  And I know all of us, including myself,  are guilty of doing this.  But if you're writing production Python code,  you really should prefer to use the logging module.  Now, I'm just going to quickly show you a few things.  Of course, we can print a bunch of stuff out.  Totally fine, right?  We can print with an exception.  We can print within a try.  We can print some logging information.  You know, we can print out like the date  or something along those lines.  We can debug some values.  Again, no problem.  A lot of people do this, and you'll be able to see the result.  The issue is you're not going to know what file it's coming  from, what time it's happening at, or what level of log it is,  whether it's a debug, whether it's an info,  whether it's a warning, whether it's an error, et cetera.  Now, you could manually write that into the print statement,  but it's not very efficient.  And you also have no way here very easily  saving this to something like a file,  so you could review it later.  So the good way to do this is to set up a logger.  And fortunately, the logging module and Python  is very easy to set up at a full tutorial,  which I will put on screen here, in case you want to check it out,  where you can create a logger.  You can set the level that you want the logger to be at,  which means kind of the min-  among level, it will log out for you. You can change the format of the logs. You're able to see, for  example, the time, the name of the file or the name of the logger, the level name, and then the  message or messages. You're able to then create the logger. In this case, you can give the logger a name.  The name we're using is the name of the file. That's what the underscore and squared name means.  From here, we can simply log something by logging with info, logging with debug. We can log with an  error. And now if we look at the logs, we're able to see much more clearly what's actually happening.  I'll show you an example of that a second. Same thing here. If you more examples of using the  logger, debugging some information, having this data logger going on right here. And I'll just show  you if I call this function, you'll see that we actually set this up to log to a file. So let me  bring this up here. I'm going to say Python. And then this is logging. And you'll see that we get  these logs, which are a lot better than print statements where it tells us, okay, advance this  name of the file, right? Then we have debug, info, info, warning, warning, whatever. And we  get all of the information. And then if we go here, let me just go, you'll see we have this  app dot log and we're able to get a log to the things that we put inside of the file.  Okay, hopefully that makes sense. But that was kind of what I was trying to show you there,  is that you can set up multiple different loggers. In this case, we can have one that goes to a file,  we can have one that goes to a console, we can set up the format, or we can just be a lot more  detailed and we can actually save the information, which is quite important, especially in a production  environment. Now, the next anti pattern on my list is one that everyone is going to use at some  points and typically for good reasons, but that is to ignore the standard library. Now, a lot of  people don't actually know all of the features that Python has and they end up writing a bunch of  code that's already built into the language. And while it's fine, it's not really a big deal.  Obviously, if you know about these features, you can use them, you can have more efficient code,  and you can take advantage of these built-in libraries that, you know, you should prefer to use  if possible. So I'm going to give you a few examples here. You can see here that maybe we're  going to count all of the items in a list and we want to see like the frequency of those items.  There's nothing wrong with this code, but Python actually has a built-in counter module that comes  from the standard library from collections, which you can use, which we'll do it for you, which I'll  show you in a second. Now, with this function, we could use it to, for example, find the most common  item and to do that, we kind of write this complex sort where we're using this lambda key,  and you know, we're checking like all of these different values and seeing if it exists.  And again, nothing wrong with that code, but it's just not the most optimal way to do this.  Same thing very commonly, people manually try to create their own file paths. Again, you can do  that, but there is built-in modules that help you do that. Even same thing, you know, checking if  a file exists, we can use the OS module to do this, but there's also a path lib module, which is  designed specifically for dealing with paths. So I'm just going to show you those examples now.  You can see like this is our exact replication of this function right here, where this will create  a dictionary for us that contains the frequencies of all of the items. Then we can use the counter to  find the most common item. So you can see that we're able to get that. And then you know, if it doesn't  exist, we can return none. Same thing for building a file path. We can just put a path around the  directory and then we can add various trajectories to it like this. We can check if a file exists by  simply wrapping it in path and going path dot exist and path dot is file. Same thing for getting  the suffix of a path. We can just directly use it from the path lib module. Now by no means by  saying you need to memorize the entire Python standard library, but especially if you're dealing  with things like paths or files or things like collections, you're dealing with a counter. Python  has a lot of those features that are pretty well known. So if possible, just use them. It will save  you a lot of time and you will just have better code. Now, the last pattern on my list in my opinion  is probably the most infamous one in Python. And that is because so many people don't know that this  is an anti pattern and it can really catch them off guard and lead to some really tricky bugs that  are hard to find or hard to solve. Now that is why using a mutable default parameter, mutable  default argument. Now essentially what that means is that when you have a default, I call a  default parameter, some people call a default argument in the function and you have something that  is mutable assigned to that. There's something that is mutable would be like a set, a dictionary,  a list, any Python object, essentially something that's not a like none type or int or what you  call string or tuple or Boolean or float. If it's not one of those values, then it's most likely  mutable. And that means it can change. Now, the reason why this is very bad having this example  here is because it doesn't work like you would expect it to work. If you modify this parameter right  here from inside of the function, it actually changes the value of the default that will be used  on a subsequent function call. Now without getting into a ton of examples here, let's imagine that we  call this function, right? We say, you know, add underscore item underscore bad and we pass an apple,  right? So it's actually just generating the example for me because AI is like this. You would expect  that, okay, it will just create, you know, a new list, it will just add this item to the list and  we'll just get back a list with one item every single time. That's actually not the case. You'll  see that if we run the print statements down here.  not going to run it, but this is exactly what will happen. First, we'll get a list with  an apple. Then on the second call, even though we're not referencing the list with the apple  at all, we're going to get apple and banana in the list. And that's because as soon as  we call this the first time with apple, you can imagine that it kind of just gets inserted  inside of this list because the default value itself has changed. It's kind of the same  thing as if I did like, you know, new items is equal to this. And then I made this equal  to new items, right? And then you can say I'm saying items out of pent item, but items  is just new items, which is this list. So this list just keeps getting larger and larger  and larger and is still being treated as the default value here in this parameter. So  you want to not do that. And I'm going to show you how to avoid that in one second. Let's  just get rid of these examples and go back to our AI generated code. Okay. Now, same thing  applies here, right? We're using a default value. Most commonly used with a list, but  also could be used with a dictionary. And it's going to cause the same errors, even if it's  inside of something like an initialization in a class. Okay. So let's scroll down and  see an example of how you should do this. If you do want to have, for example, a default  value, be a list or be a dictionary or be something mutable, you should simply assign it  to none. You should then check if the thing is none. And if it is, you can just initialize  the value equal to a list because this is done inside of the body of the function. This  will be a new list every single time. And you won't get the same error that you got before.  So you can see in all of these examples, we simply make the default value equal to none.  Then we check if it's done. If it is, we can initialize it to what we want the value  to be. And that saves us and avoids us from having that really annoying bug as you can  see down here. Anyways, that's all I had to show you guys here. Those are the seven Python  anti patterns. Let me know which one surprised you the most in the comments down below. And  I will see you in another video."
EibDfhzNvzg,3 things you have to do as a programmer!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-08T15:40:31Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/EibDfhzNvzg/default.jpg,https://i.ytimg.com/vi/EibDfhzNvzg/hqdefault.jpg,PT1M28S,11960,353,8,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"keep it simple, stupid, don't repeat yourself,  and you aren't going to need it.  First of all, the harder it is to actually write,  it's much more difficult to write simple code  than it is to write complex code.  So keep that in mind, if you know you have an ego  about writing something that's really complicated  and convoluted, you always wanna simplify everything you do  as much as humanly possible,  so that anyone in the future could get in there  and modify the code, and more importantly,  you can modify the code when you forget  what the heck you did three years later.  Don't repeat yourself.  It's very common for people to redefine  the same variables, redefine the same config.  You wanna make sure you're not repeating yourself,  you're writing reusable functions,  not anything you're doing more than one time,  you wrap it into some type of reusable component  so you can simply pull it in.  All of the code is contained in one place,  it's easier to test, it's easier to maintain,  and it's easier to change.  You aren't gonna need it.  Now, this just means that you don't wanna  overcomplicate things at the beginning.  Sometimes you don't need the most extensible,  flexible, testable code in the world,  and if that's the case, don't add it.  Don't add features that you don't actually need.  Don't over-engineer solutions unless it's something  that you think is actually feasible  to come up in the future.  So always ask yourself, what is the business need  before you go into the engineering?  Because a lot of us as engineers,  we forget that the whole value of code  is typically to generate money or value for a company.  So if you don't need all of those things,  if it's not gonna be required in the future,  you don't need to go ahead and do that over-engineering  and spend a massive amount of time building something  that just never is gonna see the light of day."
Z7Wg1tdgx9I,"If you're a software developer, watch this video!","DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-07T18:38:07Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/Z7Wg1tdgx9I/default.jpg,https://i.ytimg.com/vi/Z7Wg1tdgx9I/hqdefault.jpg,PT1M33S,32447,1041,18,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"maintainability and testability.  So when you are writing software,  you need to think about how you're going to maintain it  and more importantly, how you're going to test it.  All right, so let's have a look at an example  of a bad calculation.  Now this is a calculator that has a super complex  calculate method.  We have all these kind of nested statements.  We're dealing with tries and accepts and with statements.  We're just doing like so much stuff.  At first glance, it's very difficult for us  to understand what this function does.  And if I wanted to test it, there's like  30 different examples of things that could happen  in this function.  How do we make that better?  Well, we go to this example.  Notice here, I now start separating things  into smaller components, like we talked about earlier,  that are easier for me to test.  I have a calculation result.  Easy for me to check if the calculation result is correct.  I have an operation parser.  Rather than just passing a whole expression,  I now pass an expression to one function,  and this function is purely responsible  for parsing the expression.  That's a lot easier for me to test, right,  than a whole calculator function.  Then I have my calculator and look at  how much simpler this function is.  I have a, an operator, a b, I get the operation.  I perform the operation.  And boom, I can test this  and it doesn't take a million different edge cases.  Hopefully you get the idea.  Again, it seems more complex.  It takes more time up front.  Good code is difficult to write.  That's why we have senior developers.  People still get paid a massive amount of money.  And I guarantee you, if you ask AI  to generate this style of code,  it's not always gonna make the best decisions  you need to know deep down what the correct  architecture and design is,  which is why I'm showing you these patterns."
N0go7bRXvfs,The only way you will stay motivated as a programer.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-06T16:30:12Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/N0go7bRXvfs/default.jpg,https://i.ytimg.com/vi/N0go7bRXvfs/hqdefault.jpg,PT55S,15486,711,14,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"You are never gonna get anything real done  unless you're able to commit large blocks of time  and you are only writing code.  The times in my life where I've felt  the most productive and God in the most amount of work done  is when I've done five or six hour long coding sessions.  What happens for me at least  is I'll start to build a mental model  of the code and of the project I'm working on in my brain.  As soon as I have that built,  which usually takes a minimum an hour  of actually doing coding work,  I can get stuff done so rapidly  because I don't need to keep going back  and referencing things and I already know exactly  what I need to do in my brain.  However, if I'm distracted, if I have to pick up the phone,  even if someone just walks by my room  and I hear too much noise,  that can completely throw me off  and force me to pretty much restart that deep work process.  There's no way you're gonna become a great developer  by just doing 30 minutes a day or 45 minutes a day.  You have to put in those large periods of time  where you are deeply focused."
WPBXvDS-UEo,Is This the Fastest App Build Ever? (Base44 Demo),"In this video, I'm going to attempt to clone Airbnb in just ten minutes and get to a functional prototype. Of course, I'm going to be using AI and the platform I'm going to be testing in this video is Base 44.

Get started with Base44: https://base44.pxf.io/c/5252479/2049275/25619?trafcat=base

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=WPBXvDS-UEo

‚è≥ Timestamps ‚è≥
00:00 | Overview & Base44
01:25 | Prompting & Creation
06:00 | Analytics and Deployment

Hashtags
#Base44 #AIAgents #SoftwareEngineer",2025-11-06T13:01:06Z,"tech with tim, ai app builder, no code app development, base44 ai app, clone airbnb app, ai app creation tutorial, how to build ai apps, ai app builder demo, ai app development, ai tools for apps, build ios app with ai, base44 review, ai app builder review, ai app creation no code, top ai app builders, create ai apps easily, fast ai app builder, innovative ai app tools",27,en,en-CA,https://i.ytimg.com/vi/WPBXvDS-UEo/default.jpg,https://i.ytimg.com/vi/WPBXvDS-UEo/hqdefault.jpg,PT9M21S,18796,488,66,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"In this video, I'm going to attempt to clone Airbnb in just 10 minutes and get to a functional prototype.  Now to do that, of course, I'm going to be using AI.  And the platform I'm going to be testing in this video is base 44.  I want to see how good this is, and if I can actually get to a fully functional app,  and literally, like, 10 minutes, using this platform.  Now, this is a relatively new platform.  It's called an AI-powered creation platform.  At least that's what they're branding it as.  And this allows you to build real functional web applications.  You don't need to write any code.  You simply just prompt it, like you would prompt any other AI model or agent,  and say, able to go and create the app for you.  It doesn't require that you have technical knowledge.  Although, obviously, that's always helpful.  You simply describe what you want, and then it's able to add things like authentication,  back-end, databases, storage, no image upload, all of that kind of stuff.  So let's test it out and see what kind of result we can get.  OK, so I'm on the base 44 website here.  Now, full disclosure, I did team up with base 44 for this video.  They kind of inspired me to do this challenge.  And they also upgraded my account, so I have a bunch of credits.  That said, you can use this for free.  There is a free plan, and then obviously you just have a limited number of credits.  And then if you want to upgrade, you can.  And I will leave a discount code linked in the description,  in case you want to use this and mess around with it.  Anyways, what we do is go to the website.  We sign in with an account.  I've just created one right here.  You can also add teammates to it if you want.  And then you simply just put in the prompt for what it is that you want to make.  Now, well, I could just do something like clone Airbnb.  That's probably not going to lead me to the best result.  I have a lot of experience with these AI tools.  So what I've done is I actually created a series of prompts.  You can see them in this document right here.  It's about six or seven unique prompts.  And I'm going to do them one by one.  So that I kind of build small parts of the application.  And then I iteratively get closer to that kind of Airbnb finish product.  So that's what I'm going to do.  The first prompt is going to all be about the authentication system.  So I'm going to paste this in.  It essentially says, hey, build the initial auth system.  And then I tell it that this is going to be a clone of Airbnb.  So keep that in mind.  If I wanted to, I can attach images here.  And then I also can give it some styling instructions.  So if I press this, I can choose kind of the theme of styling that I want.  In this case, I'm just going to go with this kind of material design.  And I'm going to go ahead and press on enter.  So the first prompt is finished.  This is looking pretty good.  It's asking me what I want to select.  So I'm going to go, I'm a customer and then continue.  It's going to ask for my information.  Already has my name.  So let me test this out and make sure it's working.  So it looks like I was able to create an account here.  And you can see that there's a few different buttons.  Now, none of them are working right now because I didn't ask it to complete that.  But it seems like the auth is good.  Now, before I go any further, what I do want to do is enable a few settings here  that are going to make my life a little bit easier.  So I am going to go to this button right here,  where it allows me to view all of the files for the app.  And I'm just going to export this project to GitHub.  Now, the reason why is that I want to enable version control  is that I'm able to track all of the changes that are being made.  Now, it does have that by default with this right here.  Where it shows you the version history.  But it's much better if it's on GitHub.  So I can see all of the code differences.  So I'm going to go ahead and enable that and connect it to my GitHub.  All right, so the GitHub repo is made.  And if I want to update this now,  I can just go to update repository and then press the button.  It will automatically sync with GitHub,  which is exactly what I'm looking for.  Now, I also am just going to go to the settings here  where I can change the AI model if I want.  And I can go to AI controls.  Now, from AI controls, I'm just going to simply tell it  that I always want to maintain an Airbnb theme  and do everything related to cloning Airbnb.  So let me type that in.  Okay, cool. So I've got those custom instructions.  I can also freeze some files if I want.  But I'm going to go ahead and save that.  And then I'm going to continue here with the rest of my edits.  So the next prompt on my list is for the dashboard.  So I'm just going to go through a few of these  because it is going to take me a sec.  And let's kind of whizz through and see what we can get done.  Now, while this is running, I will mention that if you are a developer  like me and you do want to modify the code or have a look at it,  you can do that by simply going to the dashboard up here.  And then you can click through all of the different files  which are created here inside of React.  You can also see the different components.  So for example, like the roll card, profile form,  all of that kind of stuff.  You can also click on the tasks on the left hand side here  and it will open the, what do you call it,  the file that it's editing.  Anyways, if you go back to the dashboard as well,  you'll see a bunch of other settings  which I'll have a look at in a second.  For now, we'll just go back to the preview  and we can see this prompt is actually done  and now we'll go on to the next one.  And sometimes it does take a second to update here.  So you can just refresh the preview by pressing this button.  You can also switch it into the mobile view  and then you can have a look at what's created.  So you can see now it's looking a lot more like Airbnb.  I can switch my role.  I don't think you can click into these yet,  but we've got kind of the search function down  and now we'll move on to the next features.  So I just finished the last prompt here.  The app is pretty much completely built.  Sure, there's a few features we could add,  but generally it's pretty finished.  And if we click into a product now or a property,  we can see all the stuff we can add,  like you know, a check-in day, check out day.  We can reserve it.  It looks exactly like Airbnb.  If we go ahead and reserve.  you can see it brings us to our trips now, we can go to messages, we can message the host like  hello world right, then we can switch so we can go back to the vendor mode from here we're  able to see all the properties there's no bookings right now because we didn't book one that we have  and we can switch back to the customer mode and there's like you know obviously a ton of other  stuff that we can do here. Now what's interesting is that while I was running this there's a few times  I wanted to change something individually so I was able to use this visual edit where when you do  that you can just press on something so I could press here for example and say okay I want to  change the color or I want to change the typography or the spacing or the transparency or whatever  or I can go directly to the code alternatively I can just ask in the chat you know change the name  to Airbnb for example right and then I've selected the name now it's going to go look for that and  then change it pretty much everywhere on the site and you can see now that it's changed the  app name to be Airbnb. Now once we're finished with this so let's say we're happy you know with this  we've tested out we've looked at the preview what I like is that you can actually view an activity  log here so you can see all of the different requests if you're familiar with backend development  that are going on in terms of the get create etc which I think is really interesting for debugging  and you can go to your dashboard and you can start viewing all of the other information about  the app so for example you can view all of the different users you can invite a user you can  directly modify the schema for the user again if you know what that means you can go into the data  you can view that we have for example different properties we have bookings we have different messages  which are logged here right we have reviews we can go into the analytics we can see all of the page  views all the visits by which users at what time we could change the domain and then what I like  is the security component so this is definitely something you want to look at before you publish the  app this is something I would have to change before these different values here these different  entities we can actually create security rules so for example I can create an access rule and say  hey you know users can only access records that they've created that's good meaning you can only  view whatever you have user property check we can do like a custom check here to make sure they have  a certain role or something again I'm not going to do that right now but we could do that for all  of the security we can actually run a security scan to make sure that the app is secure we can go  directly into the code as I was showing you we can view the entities we can view all the different  components and then we can also view the API so for example we have an API for property booking  message for review and we can view the code neither Python or JavaScript and edit it directly and  then all of those changes will apply so while you don't need to be a developer it does have all  of these advanced developer features which I think is quite interesting then there's a bunch of  things like the app settings like the logo the name the main page right if you actually wanted to  deploy this out and then same things for the authentication in this case we just have it with Google  but you could have it with Microsoft Facebook etc so let's say we've gone through all this we're  happy we can simply press this publish button from here we'll just go ahead and publish the app  and then on this domain we'll be able to view it and mess around with it so I'm in the published  version so let me just go ahead and sign in and there you go it brings me directly to this page let's  look at another cabin here let's do some check-in day like November 1st to 8 or something okay let's go  here to 8 let's go maybe 3 guess all right let's reserve and then you can see this now pops up  in my trips I can cancel I can message you get the idea so sure again like there's a lot more stuff  that we need to add it's not fully finished but I think for about 10-15 minutes of prompting to  be honest this is pretty good we have advanced filters right so I can search for stuff if I switch  back to the role to the vendor mode I can add a property I have a form for doing that I can view  the bookings for an individual property see the amount of revenue that I've generated I can edit  that by going to the edit form and changing any of the values and overall it's a pretty comprehensive  platform that really required minimal effort of my part I just needed to prompt the model so that's  that guys that's going to wrap it up the state of the current AI tools is pretty ridiculous that I  can make something like this in literally just a few minutes definitely recommend checking it out  these tools just keep getting better and better and again I'll leave the link to that in the  description thanks for watching and I'll see you in the next one"
GUJuidMl5ls,Check the description for my full blueprint on how to land a high paying developer job.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-05T18:15:01Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/GUJuidMl5ls/default.jpg,https://i.ytimg.com/vi/GUJuidMl5ls/hqdefault.jpg,PT46S,36243,714,28,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Now a closure is simply when you have a nested function  that accesses a value from the outside function.  So I'm gonna say, adder five is equal to,  and then I'm gonna call my adder function  and give it the value five.  What this is actually gonna return to me  is now a function that I can use  that will add five to a particular value.  So now what I can do is I can say adder underscore five.  I can give this a value of 10.  We can store this in a result variable  and we can print out the result.  And notice that we get the value of 15.  Now we can utilize this function multiple times.  So this is how we actually create a function  dynamically based on a value  that we're passing to another function.  There was all kinds of ways to use closures  but they're typically used for something  like a function factory."
aEivWuMUjzM,How to create a safe LLM on your computer.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-04T19:51:18Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/aEivWuMUjzM/default.jpg,https://i.ytimg.com/vi/aEivWuMUjzM/hqdefault.jpg,PT54S,19219,543,4,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"So like I mentioned, you can control access to any LLM that you want, and you can use  something like OpenAI or DeepSeek.  But in my case, I'm just going to run an LLM locally on my own computer using something  called Alama.  This is completely free, it's open-source, and it lets you run models on your own machine,  assuming you have good enough hardware.  So once you've downloaded and installed this, you can open up a terminal or a command prompt,  and inside of here you can just type Alama to make sure this is working.  Now once Alama is working, you can pull an Alama model that you want to run locally.  Now to do that, you type Alama, pull, and then you put the name of the model.  In this case, I'll use a model like Mr. I already have this downloaded, so now it's  on my machine.  And then if I wanted to use this model, I could type Alama, Run, and then Mril, and then  I can just start chatting with the model like I would in any other case.  Now to leave, I can type slash buy, and that's great, and now we'll be able to use Alama  from our Python code."
g93XqSRxcAs,OpenAI‚Äôs New Agent Builder is Insane - Full Tutorial,"Get started with Rube today: https://rube.app/?utm_source=Social&utm_medium=Youtube&utm_campaign=2025-09&utm_content=Tech%20with%20Tim

Today I'm having a look at OpenAI's new agent builder. You can create some really interesting agents. I've been messing around with it, seeing what it's capable of and building a few agents of my own. I want to give you a quick demo and tutorial, and then share with you my thoughts.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=g93XqSRxcAs

üéû Video Resources üéû
OpenAI Agent Builder: https://platform.openai.com/docs/guides/agent-builder

‚è≥ Timestamps ‚è≥
00:00 | Agent Builder Intro
01:00 | AgentKit Announcement & Info
05:21 | Advanced Agent Demo
09:29 | Tutorial & Agent Build 

Hashtags
#OpenAI #AgentBuilder #SoftwareEngineer",2025-11-04T13:59:12Z,"tech with tim, openai, agent builder, ai tutorial, openai agent, ai development, machine learning, ai tools, automation, ai programming, ai workflow, ai platform, tech tutorial, ai integration, artificial intelligence, ai customization, AgentKit, listviews, LLMs, OpenAI, ChatGPT",27,en,en-CA,https://i.ytimg.com/vi/g93XqSRxcAs/default.jpg,https://i.ytimg.com/vi/g93XqSRxcAs/hqdefault.jpg,PT30M45S,150215,417,19,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Today, I'm having a look at OpenAI's new agent builder.  This was released a few weeks ago.  It's pretty cool.  You can create some really interesting agents.  I've been messing around with it, seeing what it's capable of, and building a few agents  of my own.  I want to give you kind of a quick demo slash tutorial, and then share with you my thoughts  because while it is really interesting, there are a lot of limitations that I don't see  many people talking about.  Anyways, let's dive into it and have a look at the agent builder.  So this is the interface for the new agent builder.  Looks like this.  This is an example agent that I was working on previously up on screen here, and you can  see that you have all of these different blocks, kind of like scratch or like a drag and  drop editor, and you can connect these together kind of just by dragging them through.  You can click in, you can view all of the different options, and they have things like  MCP connectors where you can connect directly to Google Drive or Shopify, or you can bring  in your own MCP server like this.  While that's pretty cool, it is fairly limited in terms of the external connections right  now, but regardless, you can still create some pretty interesting flows like the one that  I have right here.  Now I'm going to get into this flow.  I'm going to show you an example of an agent that I've built and kind of how to do that  and how to connect the different blocks.  However, I want to quickly go over a lot of the things that OpenAI has released recently  because it wasn't just this agent builder.  Now this is the original announcement back on October 6th about a month from when I'm filming  this video, and you can see that they actually were introducing agent kit.  Now I guess that's what they're calling all of these kind of tools combined together.  So for example, that includes the agent builder, the connector registry, and then chat  kit, which is kind of, I guess like an add-on to the agent builder, which allows you to  use these interesting widgets so you can have like forms, displays, list views, whatever.  You can actually make your own widgets so you can display the data coming back from your  agent in kind of a prettier, you know, more usable way.  Now what's worth noting here is that before this release, OpenAI had the responses API  as well as the agents SDK, which was a more developer kind of centric way of building AI agents  and communicating with OpenAI.  You've probably used it or seen it used before, and this is just adding tools that make  it easier to build those agents.  Now with that said, there's a lot of moving pieces here.  There's a lot of tools that OpenAI now has, and to be honest, I'm pretty confused by  all of the ones that they have and how they work together.  A lot of their documentation is currently not working or not up to date.  I read through a lot of it before preparing for this video.  So while all of this stuff is cool, it is still very early days, and I hope that they  fix it soon because there's a lot of stuff I wanted to do that I just couldn't figure  out how to do in a relatively short period of time because of how confusing some of these  tools are.  Anyways, that's kind of the new release.  I also just quickly show you that ChatKit is kind of this more developer focused, you  know, add on to this agent builder.  So while you can build your custom agent and you can mess around with it in the browser  and you don't really need to know how to code, if you want to use something like ChatKit  and have these really fancy widgets, which I'll show you in a second, you do need to have  a little bit of developer experience here and embed these directly in your front end  with some kind of flow like this.  Again, I'll have a look at that in a second, but just letting you know that while it seems  cool with the agent builder, if you really want this to work kind of like in a production  setting, you definitely need to know how to code, and there is a lot of configuration and  setup that is not that easy to do.  And just give you a quick idea of what I mean here if I go to the ChatKit Python SDK.  As you can see, it doesn't even have a readme file here.  It just has this like random Apache license that we're having a look at.  Pretty much a brand new repo with like kind of no activity and nothing going on.  And this is what they're expecting you to look at to learn how to use the SDK.  So yeah, it's, you know, early days here for a lot of the developer or more advanced tools.  Anyways, let's go back into the agent builder.  Let me show you this agent that I built and kind of how you could replicate the same.  And you'll notice here that OpenAI is really pushing towards building kind of agentic tools  and allowing developers to build AI agents.  And that's because as we advance more with AI, it's a lot less about just LLMs and how  well it can reason, but more so about the actions that they can actually take.  Now, that's exactly where today's sponsor as well comes in, and that's Rube.app.  Now think of Rube as your AI's chief of staff, not just a note taker, but a command center.  Once you connect it, Rube sits inside of your existing AI tools, whether you're using  ChatGPT, Clawed, Cursor, or even VS Code.  And it gives them the power to use Rube apps securely and autonomously.  Now, look here.  I can connect this directly inside of ChatGPT and also works inside of the agent builder.  And it's built by Composio.  And it acts as a universal action layer across more than 600 applications, so things like  Gmail, Notion, Slack, Salesforce, even your calendar.  You just authenticate one time.  And from that on, your AI can execute full workflows in plain English.  So instead of prompting something like summarize my emails, you can go all the way.  Find all unread emails from the past week, summarize the key points in Notion, and message  my team on Slack if any need follow.  Rube automatically handles the right tool connections, authenticate securely, and executes  each step in the optimal order all within your chat.  It also has memory, so that means it learns how you were, who'd a ping, how you need  things, when you prefer summaries, etc. Now, it's the first really unified action layer  that I've seen that actually feels like a natural extension of your AI. It's free right now  while it's in beta, so if you want to turn your LLM into something that can actually do things,  go try it out at the link in the description. Anyways, let's get back into it here and have a look  at these agents that you can build with the agent builder. Okay, so in terms of the agent builder,  let me give you a demo of one of the ones that I built so far so you can see kind of what's  possible and then we'll go into a blank flow and I'll show you kind of the basics of connecting  and some of the limitations that it does have. So what I'll do is I'll just press on preview right  here and from here I'm able to test my workflow. So the flow that I set up here is that I want to use  multiple agents to help me generate an outline for a YouTube video. So my idea is the first I want to  generate kind of like a viral YouTube video title. I want to select which title that I want to  generate the outline for and then I want to have the model go ahead and generate a full outline  and let me revise it based on my feedback. So you can see that that's kind of everything that's  happening here. So the first thing I'll do is I'll just tell it, you know, I want to generate  a YouTube video for OpenAI's new AI agent builder. Okay, so I just tell it that and then we can see  we can actually watch it run through this flow, goes into the if statement, goes here to the video  title generator and then starts generating our titles. Now we just got the output but you'll  notice here that it actually used a tool that I gave it. So it was searching the web kind of looking  for information on the OpenAI agent builder and then what it did is it generated a bunch of titles  in this JSON format and displayed it using one of the new chat widgets. Now this widget that you see  here comes from chat kit. Again, we'll talk about in a second, but that's not able to display this  in kind of a nice format. Unfortunately, pressing on these doesn't work directly inside of the  preview. In order to interact with the widgets, you need to connect this to your own backend server  and set up honestly quite a bit of code so that you can actually track the state and kind of register  the events and what are being pressed with these various widgets. But regardless, what I can do now  is pick one of these. So maybe something like I built three agents, right? And then I can approve  this. So it says, would you like to select one of these titles or do you want to try again?  If I press try again, then we can generate more titles. If not, I'll press approve and then it's  going to wait for me to actually select the title that I want. So now I can just paste in the title.  You know, I built three agents with agent kit. You'll see now that in this if statement,  it's going to go to this next agent where it tries to parse out the title from the text that I  provided. And then what it starts to do is ask, okay, do you want to generate, you know, an outline  for this video? So in this case, three agents, I'm going to go ahead and press on approve for that.  And then what it's going to do is start generating this outline for me. Now the way you set up the  flows here is not super intuitive. And to be honest, I wish they had a lot more blocks and options.  Because for example, you know, I can't just press on one of these things and have it be selected.  So the only way I can kind of like select an option from my agent if I'm using this type of  mode where I'm not trying to write a bunch of custom code is if I type it in, right? Which is why  I need to kind of do this repeated step of typing in this title when really I should be able to  just like press it and have the outline generate. So there's a few weird things like that you'll  they'll notice with the kind of flow as we start building one. But you'll see the what it's done  now is generated this outline for me. So I told the 14 minutes below the block kind of gives me  the outline of the video. And then if I want to start chatting with it and revising the outline.  And if that's the case, we would go into kind of this top loop up here because of how I've set up  the statements. Now the interesting thing about this agent builders that it does allow you to persist  state. So you'll notice that I have these kind of set state blocks here where anytime I do something  or make a decision, I can change the state, which then will adjust what's going to happen in the  next run. So for example, you know, we go and we generate a title and then I set the state saying,  okay, we've already generated a bunch of title ideas. Then when we select a title, I set the state  to indicate what title we've selected. And when I generate an outline, I save that outline in the  state. By having that different state, I'm now able to redirect the agent to go into different  paths and kind of use different AI agents so that it can do something different based on the  current step that we're on in this flow. Now a lot of other AI agent builders actually do this a  lot better in my opinion, but at least for a first stab at, you know, open AI's agent builder,  this is pretty good. And the state is very useful because it's persisted. Anyways, that's just a  quick example of something that I personally built here in the agent builder when I was kind of  learning this and messing around with it. Now what I want to do is get into a blank flow and kind  of show you how you can create your own go through some of the blocks and talk about how to connect  them because it's not extremely intuitive. So if you go into the agent builder, you can just do that  by searching, you know, agent builder, open AI. And if you have an account, you're able to sign in  and access it right here. You'll notice that kind of in the main window, you actually have a bunch  of different options. So you now have stuff for, for example, creating audio, writer, getting Texas  speech. You can do image generation here. I haven't messed with that too much. You can have  different assistants, which work quite a bit different than the agent flow there. You can view  your usage. These do use a lot of tokens. So just be careful. In my case, I think I use like  10 bucks the other day messing around with it. You can view your  logs, your storage, batches, all of that kind of stuff.  And something interesting here is that while the agent builder  does support vector search, so it allows you to actually  search through vector databases and find information.  In order to do that, you need to use a built-in vector search  with OpenAI, so you would have to create your own vector  store or upload your own files here to be able to pull  that data in directly natively in the agent builder.  Now you can do this from code, which I'll show you  in a second, but it is obviously easier in this kind of flow.  So if you come to the agent builder,  you'll see that there's a bunch of different templates.  You can have a look at them.  I don't find them that useful to be honest with you.  So what I've been doing is just creating a new empty agent  and kind of going from here.  So now that I've made a new agent, I'll just build  like a quick flow and show you kind of how to connect it  and some of the options that are worth going over,  but also note that you can use this directly  from the agent's SDK.  So for example, you can actually just copy all of the code  right here, and this is a kind of text-based representation  of the agent that you've built.  So you see we have a new agent, we have a workflow.  In order to run the workflow,  we keep track of the conversation history,  and then we run the agent.  And if I were to go here and add another kind of connection,  and then we go up here to code and we look at the agent's SDK,  you'll see it automatically adds the code for the guardrail.  So if you want to do something more advanced,  you can do that by going directly into the code  and modifying that or just running it natively  with the SDKs on your own computer.  Again, that's going to take a lot longer,  but you can do that.  Now, you also have the option here of embedding this  using chat kit.  This is a little bit easier than running all of the code here.  What this allows you to do is essentially rely  on OpenAI servers to kind of host your agent.  And what you can do is you can embed kind of the chat window  and all of the widgets directly on your own front end.  And then you can essentially send the request  to the OpenAI back end, deal with the agent,  and then get all of the feedback on your front end.  Like I said before, it does require a little bit of setup  there, but this allows you to have  a lot more customization and to actually interact  with the widgets and create some more complex flows.  If you guys want a full tutorial on this aimed at developers,  I'm happy to do that in the future.  So just let me know, but I wanted to just let you know  that it does have these features  and you can get more advanced as a developer.  If you want to, you're not limited just  to this kind of visual flow build.  Anyways, let's start building something quite simple.  So if we start going through some of the nodes,  you'll notice that you always need to start with a start node.  Now, from this start node, you're able to have  various state variables and you can define them  at the beginning or you can leave them undefined.  So for example, we get up something like the user's name,  and we can just leave that as an undefined value to begin.  We can have an object, we can have a list,  and with this state, because it persists  between the different runs of the agent,  you can create some more complex flows where you,  for example, ask the user for their name.  After you get their name, you ask them,  what they want to order, something along those lines.  So to show you an example of that flow,  we can have some agent right here.  You can call this name collection.  From here, what we're able to do is give it a system prompt.  So that's what this instruction is right here.  And we can say something like, you need to,  let's say, ask a user for their name,  find their name, and return it.  If there is no name, then return, no, or something, okay?  Great, so you can give it kind of the system prompt,  explaining what it needs to do.  If you want to add context to this prompt,  you can directly do that by just passing in the context.  Now, what I suggest doing is keeping this  as the instruction prompt, and then pressing this plus button  here, which gives you the user prompt.  So this one is the instructions.  Then from here, you can add an assistant or a user prompt.  So here, what we can do is just add the context,  which is this.  So this is from the start node,  whatever the user typed in, the workflow.input as text.  And now what will happen is it will read through this message,  use these instructions, try to pull out the name.  Now, from here, you can choose things like,  if you want to include this in the chat history,  you can of course, pick your model.  You could just leave it on GPT-5.  You can put the amount of reasoning that it should do,  especially if it needs to plan like a larger task.  In this case, it's minimal because we just want to get the name.  And then if you want, you can directly add tools here.  So in terms of adding tools to the agent here,  this really only works well.  If you're going to run this in your own environment,  and you're going to have your own back end setup.  The way that the tool calls work  is that if you use a function, for example,  you have to write in the definition  for how this function should be called.  And then the agent will essentially generate a tool call  that you would need to manually handle yourself on the back end.  So if I just generate something like, you know,  tool that gets weather or something,  so you can just generate it with AI,  it will create this kind of tool spec for us here,  but it won't actually perform the action for that tool.  So if you have a look at this spec here,  we define what the tool calls should look like  and how this function should be called.  But if the model generates a tool call,  we don't know what the actual function is  right for getting the weather.  So we would have to actually implement that ourselves  on our server to actually get the...  whether and then return that back to the model.  So while it's interesting, it does require a lot of  kind of developer intervention.  So if you want to use some of those tools,  keep that in mind.  This requires you to actually go into the code,  write the tool yourself, and kind of intercept  the tool call from the model, and then handle that.  Now, if you want to use, for example, a client tool,  same thing, you can write a client tool.  And in this case, it will be triggered  directly on your front end, whereas the other tools  are going to be triggered on your back end  if you're hosting this agent.  Now, there's a bunch of other stuff here.  I won't go into all of the settings,  but this so far should collect the name.  And then what we can do is we can change the output format.  So for the output format, we have a few options.  Text is the default.  We also have JSON and widget.  Now, this is extremely useful because a lot of times  you want these models to return something structured  that's consistent.  So in our case, we just want it to return a name.  So what we can do is we can have output format,  which is JSON, and we can go here and define the schema  that we want.  It's a return.  So we can go to add property here, and we can do something  like name, and then we can give a description and say,  the name, the user entered like that, right?  And then we can go to another property,  and we can do something like a Boolean and say, name,  found, and we'll say, if a name was detected.  So now what will happen, if we spell this correctly,  is the model will return only this information to us.  So we'll give us an object that contains this name field,  and this name found field, and we can then  use that to kind of figure out what to do next in our flow.  So I'm going to update this here.  We now have the response schema, and what we could do now  is we could go into something like an if statement, right?  So I can now put this into an if statement,  and I can start writing some conditions.  So I can do something like if, and we'll have the case,  so for the case name, we'll say, name, found.  And then the condition is we can look at the output  that came from this agent.  We can look, for example, if the name was found.  So we can say if the name was found was equal to true,  like that, then we can do something,  and then we can have another case, which is an else if,  or we can just leave it as else.  So here we're going to say if the name was found,  then what we can do is we can go into maybe another agent,  and we can ask the user to do something.  Otherwise, we could just end, right?  And we can bring in this end node.  So if we put in the end node, we'll just immediately  terminate it right there.  Otherwise, we can go into this agent,  and we'll just say something like answer,  the user's question, and always, let's say like this,  always refer to them by name, and then we're going to put  the name in here so we can add the context,  which is their name, perfect.  And then that's kind of all that we need,  and then what we could do after this is we can go  and we can end.  So that's a very simple flow.  If you want to test the flow, you can go to the preview,  and you could say something like, hey, how are you?  My name is Tim, okay?  So let's wait for this to run,  and let's see what happens.  So we're going into the name collection.  It says the name is Tim, the name was found,  and then we go into the if statement,  we go into this agent, and then from the agent here,  it says hi Tim, I'm doing well, thanks for asking,  how can I help you today?  So it didn't prompt us here to actually type something  and again, it just went directly into this agent  and kind of executed that instruction.  And that's the thing that I don't really like about this  is that I can't kind of enter another text string later on.  I need to restart the flow in order to do that.  So because of this limitation,  where you can't really provide new input  in the middle of the flow, it means that you need to build  these agents in a certain way so that they can kind of run  again from the beginning, but go down a separate path  based on the current state.  Now this is really only a limitation  when you're doing it inside of the agent builder,  like I am right here, if you use custom code,  then you can inject current state by using things like widgets,  which again, I keep saying, but I will show you in a minute.  But for now, let me show you the pattern that I've been using  so that this agent actually makes sense.  Because the idea is we want to ask the user,  okay, like what's your name,  and then we want to use their name  through the rest of the flow in future conversation.  So what we have right now doesn't really make sense  because we asked the user their name,  but then if they don't have any question in that text,  when we go to this next agent,  it doesn't really do anything for us.  So we need to move things around a little bit  where rather than us kind of doing this if else right now,  we actually do it at the beginning.  So let me just kind of disconnect these agents here,  and we're gonna put the if like this,  and we're gonna pretty much just change everything.  So essentially what we're gonna do here  is we're gonna start by adding some state.  So if we go to start, we have the name, right?  Okay, so that's good, so the state's already there.  And now what we're gonna do is we're gonna say,  okay, if the, and this is gonna be name,  so we're gonna say if the state dot name does not equal no,  which means it's not empty essentially.  So we have some name that means we found the name.  So if we found the name,  we're gonna connect it to this agent like this.  Otherwise what we're gonna do is we're gonna go  to this name collection agent,  and then after the agent collects the name,  we're gonna use this set state block,  we're in the set state,  we're gonna say that we wanna assign to the variable name,  and what we wanna assign is,  the name like this. Okay, so we're going to say, all right, we go to the name collection agent,  we get the name. If there is some name, right, we assign that as the string. Okay, and then we can  go to end. Now, there's other ways that we can do this that makes it actually work a little bit  better. So in fact, let's change this a bit just so I can show you how this works. So rather than  just storing the name, we're also going to have a Boolean and we'll say name found like that.  And by default, we can make this equal to false. So now in our if, we can actually make this a  little bit more clear and rather than state dot name, we can say name underscore found like that.  So we can say if the name dot found is true, then what we're going to do is go to this agent  right here, we'll create the user. Otherwise, what we can do is go here and then we can set state  and we can set multiple things. We can set the name as well as we can set if the name is found  and we can assign this the value of true. Okay, so we just have two sets here inside of this set  and then we end and then here let's make sure the name is correct. It is. So now we have the if  else at the beginning. So if we go and we preview and say, hey, my name is Tim. Okay, and just wait  one second. And now you saw we went into the name collection where it says, okay, you know,  the name is Tim. The name found is true. Now if I type like, hey, how are you? We should see that  we go into this top agent here, which we do because the name state was found and was already set.  So that's kind of how we do this with the state. So now we get the response from the agent where it  asks us how it can help us. So that's kind of the pattern that you're typically going to use is  you're going to set the state and then here you'll check for the state at the beginning and then  you can go down a different path if that's the flow that you want to follow. Now where this gets  even more interesting is when you can start integrating widgets. So for example, you saw that when we  collect the kind of name, it doesn't really give us any output, right? What it does is it gives us  this JSON, but it's showing that JSON in the chat, which doesn't really look very nice. So what  we can do is we can actually just uncheck this. So we're no longer displaying the response in the  chat. And then what we can do is we can kind of add another agent in here where we can maybe  greet the user before we move them to the next stage. So we can just connect another agent  for this agent. We can just call this greeter or something and say greets the user with the name.  Okay, and then we're going to add the context, which is name and a random fact. Okay, so now we can  actually just output some text and we can see that. However, if we want, we can make this even more  interesting by integrating what's called a widget. So rather than going output format to JSON or text,  we can use widget, which comes from checking. Now if we select widget here, what we're able to do  is add a widget and in order to add a widget, we need to create one. So I'm going to go to this  create button right here and it brings me to this new page, which is called the widget builder.  Now from the widget builder, we can look at existing widgets. You can see these are examples of  chat widgets, which is a way to return data and kind of a nice format. So you can see that we have  like this weather format, right? We have this date format or calendar format. So what we're able to  do is create these custom widgets, tell the model, hey, we want to output the text in this widget  format and the model automatically returns data that can populate these widgets. So for example,  here's a widget that I actually made. It's like this kind of YouTube outline widget. I'm not using  it right now, but it's one that I've set up. We have this suggested videos widget. You already  saw this in the first example. So you can make these widgets whatever you want. Now there's also  existing components that you can use to kind of build these widgets out. You can style them. You  can have charts. But what's really interesting is that you can just use AI to make the widget.  So for example, I can just ask something like, I want a widget that displays what the user's name  is and a random fact. It should be colorful and fun. Okay. So I'm going to go here and press  enter and then it will just generate a widget for us, which we can download, upload back into  the agent builder and then we can output text in that widget format. Okay. So it's been a minute.  You can see here that it's now generated a widget. We have like a dark theme one as well as a  light theme one. And what we're able to do is see the schema for the widget, which is the information  that our model would need to pass in in order to generate this widget. This is the default  information story. This is the schema, my bad. And you can see what it looks like. So this is the  code and then this is the widget itself. Now what you're able to do here is simply download the  widgets. You can just press download. I'm going to save it into my widgets here. And then what we  can do is go back to the agent builder and we can simply upload it. So I go to widgets. I'll select  the widget that I created. It shows us what it looks like. We can view the code for it. And now what  we'll do is close. And now if we run our flow, we should be able to see this widget. So I'm going  to say, hey, my name is Tim. Notice by the way, you can also see the state variables here on the  first run and you can modify those. And I'm going to press enter. So you can see it now greets us.  It says hi Tim says here's a fun fact. And then it gives us a random fun fact. And if we say  what is the weather or something? The weather today. Okay, we just go ahead and press enter. It should  now go into the other agent because it already has our name. And then it's  give us the answer. So let's give this a second. It's reasoning, blah blah looking up the weather  and says, I can help you with that. You know, tell me the zip code, whatever. Okay.  Anyways, there you go. That's a simple example of building the agent.  Now, of course, there is a lot of other tools that I didn't yet go into, right? For example,  we have user approval. With the user approval, it's pretty straightforward. It just allows the user  to either do a prove or reject. You cannot change the name of these buttons. That's it. So you can  just have one flow that you go off of if you want to approve something, one that you go off of if you  want to reject something. And this is kind of the one way that the user can intervene in kind of  the middle of the flow. But that's pretty much it. Let me just delete this one. You also have the  wall loop. This allows you to keep looping based on some condition. As you can see here, however,  this is pretty tricky to use. So I wouldn't suggest it unless you really need that flow.  You have notes, right? So you can just put a note and says, you know, check this, whatever, right?  If you want to notify kind of what's going on in there. And then you have the file search.  This only works inside of a vector ID created with open AI. So you can create your  on vector store, upload data in there and then search for results. But again, you need to do that  directly in open AI, which is makes it just not that useful. You have guard rails. What guard  rails allows you to do is kind of sanitize text before it goes through your flow. So we can make  sure there's no identifiable information. We can check for moderation, jail breaks, hallucinations,  etc. We can go in here and kind of add all of this different information and change all of  the settings here so that we can kind of make sure that our agent is safe. And it's not allowing  users to try to hack it or ask for things that they shouldn't be asking for. And to do that,  you would just connect that directly to the start node. So it just delete this, right? And then  the guard rail can go into the next flow. And from here, you can actually just have it kind of  quit immediately, right? So for example, if we do this and then we fail, we can just go directly  to an end block where now we won't go through the rest of the flow because the guard rails failed.  So that's pretty cool feature. That's interesting that they added that. And then you have MCP.  Now for MCP, you can natively connect to some of these tools like Gmail, Google Calendar,  Google Drive, etc. However, when you do this, it's not very easy to connect. So if you press this  button that says get access token, it brings you this crazy page where you essentially need to do  this kind of manual setup where you, you know, authorize the API to access a certain set of features.  And then you need to exchange this token for this access token and then provide this in here,  which expires in a few days. And overall, it is not very friendly, which is why I did not show it  in this video. Now, same thing for some of the other connections, you know, PayPal, etc. You need  these, all these access tokens, which are not easy to access. And then you have the server where you  can, you know, put in a server like the notion MCP server, for example, however, the only way that  this authentication works is using either custom headers or an access token and API key. And it  doesn't support an OAuth flow, which is how most of these MCP servers authenticate. So I'm not  going to dive into this too much, but essentially, yes, you can add MCP servers here, but it only works  if they're an HTTP MCP server. And if they do authentication using some kind of API key or  custom header, not if they use an OAuth flow, which now is kind of standard, which is very unfortunate,  because if they did implement the OAuth flow, which means like you can kind of sign in and it will  grab the token for you, then they would make this a lot more useful. But all of the MCP servers that I  wanted to use, I just cannot use from this agent builder tool because of how they want the connection  to be handled, which is quite unfortunate. Now, that's pretty much it. There are a few other  interesting tools. For example, like you can evaluate your agent and you can test it with multiple  different, what do you call it, kind of flows here. You can see how long it takes to run inside  of these different steps. You can actually have a greater, it's funny, you can use like a GPT  model to grade your own GPT models. And you can see how well that's performing. And if you get  outside of these workflows here, you can go in and you can actually look at, for example, fine  tuning where you can find tune models. And you can have this evaluation where you can evaluate  different kind of data sets in your agent. So you can actually name a new data set, right? And then  you can connect this to an agent and you can run through and test how it performs on those  different data sets. Pretty cool. They added a lot of interesting stuff here. But to be honest,  it only becomes useful if you're going to actually integrate this with your code. So while  yeah, we can build these cool agents, we can mess around with them in the preview window.  If you want any interactability, if you want to be able to pause the flow, if you want to change  the state dynamically, you are going to need to write some code to do that. Because for example,  if we go back to the widget builder, right? And we just go to the gallery, you'll see that all of  these widgets have like buttons like add to calendar, discard. We have forums, right? You know,  where we can enter all of this data. But this only works and we can only use these kind of inputs  if we connect this to our own back end, which is not made that clear by open AI and is really  limiting when you're using the agent builder in this kind of UI mode as opposed to if I can go  back to it the code. So I guess I got out of it. That's fine. Anyways, I think with that said,  guys, I'm going to wrap up.  video for now. I wanted to give a quick tutorial, show you some of the limitations as well  as the capabilities of this tool. Overall, I think it's really cool. I think OpenAI  has the possibility to make this the best agent builder out there. Right now, I would say  that it's pretty limiting, especially from a drag and drop perspective. If you want full  control here, you do need to write some code and integrate it. And I am planning on doing  that in the future story and making a full tutorial on how to do that. So if you're interested  in that type of video, leave a comment down below and let me know. And I'm sure I'll be  covering this more on the channel in the future. Anyways, if you guys enjoyed, make  sure you may like, subscribe, and I will see you in the next one."
oZICi5W8JIo,Have you used Langchain before?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-03T22:48:13Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/oZICi5W8JIo/default.jpg,https://i.ytimg.com/vi/oZICi5W8JIo/hqdefault.jpg,PT36S,25012,561,6,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"chain. Now, Langchain is primarily a Python-based framework for working with LLM's and building  Genai-based applications. It allows you to really easily use multiple LLM providers like OpenAI,  for example, and to do things like prompt templates, output parsing, buffer management, storing  conversation history, working with vector databases, all of the common things you'll do with LLM apps,  Langchain just makes significantly easier. As it says in the name, you can set up various  chains of operations that you want to perform and do this in Python with relative ease compared  if you're going to do this completely from scratch."
T1TmHvJBUcE,What is a decorator in Python?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-11-02T19:50:42Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/T1TmHvJBUcE/default.jpg,https://i.ytimg.com/vi/T1TmHvJBUcE/hqdefault.jpg,PT55S,22818,415,8,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"So what we see here with the timer function is a decorator.  Notice that what it actually does is return another function.  What we do is we write the at symbol,  then the name of the function, in this case, it's timer,  and we decorate a function with it.  We put it on top of this function.  So rather than using the decorator syntax here,  which is the at symbol,  what we can actually do is write the following line.  We can say the example function is equal to the timer function,  and then we can pass the example function to it.  When we do this, this is effectively the exact same  as simply writing the decorator above the function.  I know, seems a little bit strange,  but that's all it's doing.  It's simply taking this function right here,  passing it to this decorator,  and then replacing the function definition  with whatever's returned from the decorator.  So as you can see, what the decorator really does  is modify a function and typically add some behavior around it."
FLAzwdj2Ncw,Powerful advice from a proffesional developer.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-11-01T20:15:33Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/FLAzwdj2Ncw/default.jpg,https://i.ytimg.com/vi/FLAzwdj2Ncw/hqdefault.jpg,PT59S,22922,716,9,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"They say it takes 10,000 hours to feel like an expert in any field.  I've won a few things along the way that I want to share with you.  Bad habits compound.  It's very easy when you just start out programming to just want to get something done.  That's totally fine, but what will end up happening is you'll build some really bad habits  and be doing things with bad practice that you might not even realize are wrong.  And then you'll get to a phase in your career where you've been doing this so long and so often  that's really difficult to reverse it.  So a few examples of this are just using good variable names.  Another thing is simply type it.  If you're just getting started out right now, I highly recommend learn how to type properly  before you start doing it every single day for eight hours.  The next thing to touch on now is environment.  Having coded for over 10,000 hours, I've worked in pretty much any environment you can imagine  and I can tell you this is the number one factor at least from my productivity.  When I'm able to have an isolated environment, I get so much more done, probably two or  three times the amount of work, as opposed to when I have a place where I'm doing a bunch  of different things in that area."
cliZ-VzQxkE,I Let 3 AIs Compete to Build the Same App‚Ä¶,"Today, I'm putting three of the most hyped AI coding platforms to the test: Blitzy, Devin, and Factory AI. Now, each of these tools take a slightly different approach to building software. I'm going to give all three of them the exact same real world task, something the developers actually do in companies all the time. We're going to see which platform performs the best, and how much effort it takes from my end, the programmer.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=cliZ-VzQxkE

üéû Video Resources üéû
Blitzy: https://blitzy.com/?utm_source=YouTube&utm_medium=Social&utm_campaign=Tech%20with%20Tim
Factory: https://factory.ai/
Devin: https://devin.ai/

AWS Card Demo Repo: https://aws.amazon.com/blogs/opensource/introducing-open-source-aws-carddemo-for-mainframe-modernization/
Blitzy SWE Bench: https://paper.blitzy.com/blitzy_system_2_ai_platform_topping_swe_bench_verified.pdf
Devin SWE Bench: https://cognition.ai/blog/swe-bench-technical-report
Factory SWE Bench: https://factory.ai/news/code-droid-technical-report

‚è≥ Timestamps ‚è≥
00:00 | Overview
00:52 | Demo Task
02:31 | Prompt
03:20 | SWE Bench Results
05:50 | Blitzy
11:35 | Devin
15:58 | Factory

Hashtags
#BlitzyAI #CognitionDevin #FactoryAI",2025-11-01T13:58:04Z,"tech with tim, ai platforms, blitzy ai, devin ai, factory ai, best ai platform, ai comparison, ai tools review, ai technology, ai software, ai debate, ai showcase, ai solutions, ai performance, ai industry, ai innovation, Amazon Web Service, software engineer, refactoring, backlog cleanup, AWS CardDemo, COBOL, CICS, VSAM, JCL, SWE bench, software engineering benchmark, documentation",27,en,en-CA,https://i.ytimg.com/vi/cliZ-VzQxkE/default.jpg,https://i.ytimg.com/vi/cliZ-VzQxkE/hqdefault.jpg,PT21M45S,1937717,526,28,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Today, I'm putting three of the most hyped AI coding  platforms to the test.  Blitzy, Devon, and factory AI.  Now, each of these tools take a slightly different approach  to building software.  Blitzy claims that it can plan, code, and validate  your entire project, basically like a full stack  developer that just never sleeps.  Devon brands itself as an AI software engineer,  helping with refactors, migrations, and backlog clean up  inside of your real repositories.  And factory, on the other hand,  runs a network of droids.  So individual AI agents that can collaborate  and even hand tasks off between your local  and remote environments.  So here's the challenge.  I'm going to give all three of them  the exact same real world task.  Something that developers actually do in companies  all the time, and we're going to see which platform  performs the best, and more importantly,  how much effort it takes from my end, the programmer.  Now, the test project that I'm going to be using for this video  is called the AWS Card Demo Modernization repo.  I'm going to leave a link to it in the description,  so you can check it out if you want.  But this is an official AWS sample app  built specifically for testing modernization workflows.  So basically, it simulates what it's like to take  an old, monolithic app, and break it  into a modern microservice architecture  using AWS tools and best practices.  Now, I have the repo up on my computer right now.  You can see this comes directly from AWS.  It explains exactly what it is.  It'll go into a few more details.  But again, if you want to check it out,  I'll leave the link in the description,  and this uses some really old technology,  which I'll explain now.  So pretty much, this is an open source,  mainframe credit card management app.  This is built with Cobalt, CICS, VSM, and JCL.  I don't even know to pronounce some of those  because that's way beyond my time as a programmer.  Now, essentially, this is a realistic legacy stack  that's used by a ton of enterprises,  and that makes it a perfect benchmark  for seeing how these AI platforms  can handle the following.  Now, the four things this repo is really going to test  is how well these platforms can understand  an existing code base, specifically a legacy code base,  how well they can plan a modernization strategy,  how well they can generate new service code or infrastructure,  and then how they can validate  that the final system is actually working.  So I'm going to load the same repo into each platform.  I'm going to give them the same, extremely detailed prompt,  which I'm going to show you in one second,  and then we're going to compare how well they perform,  and again, the amount of effort required on my part.  So let me load up the prompt,  we'll quickly read through it,  and then we'll get into some of the examples  of actually using these platforms.  So on my screen, you can see the prompt  that I'm going to feed to these models.  This is extremely large.  I'm going to see how well they perform with one prompt,  and if we need to break it down, we will,  but this is a multi-page prompt,  or essentially I tell them,  hey, you are tasked with refactoring  this AWS card demo application  from the Cobalt mainframe implementation  into a modern Java 21 application.  I go through the core objectives, what to find success.  I go through the stack that I want to be using,  the overall architecture and patterns,  key modules and components.  Right, I gave it this really detailed prompt  on what I wanted to do,  so that it's very fair when I pass this  to these different models.  Okay, so that's the prompt.  I'm going to pass it to them in one second,  but first, I want to take a look at essentially  the benchmarks from these different platforms,  so we get a baseline of what we may be expecting,  and then we'll throw it into a real world situation.  So all three of these platforms  have released their sweet bench results.  Now, sweet bench stands for software engineering benchmark,  and this is a test that was created by Princeton  and HuggingFace to measure how well AI systems  can solve real GitHub issues.  So each task is a real bug or feature request  from an open source repo,  and the AI has to read the repo,  understand the problem, and then generate a patch,  and make sure that it passes the project's existing tests.  So this is how these platforms performed.  First, let's go over to Devon.  Now, I'll link all of these in the descriptions.  You can read through all the results if you want,  but you can see the Devon here in sweet bench  successfully resolved 13.68% of the issues.  Now, they're saying, you know,  this far exceeded the previous best,  whatever, you can kind of ignore it  when the companies talk about that,  because of course they want to pitch this as the best,  and then it gives you some information on sweet bench.  In this case, I believe it used the full sweet bench,  and keep in mind that all of these different companies  use different variants of sweet bench,  different testing methodologies.  So while the numbers are somewhat comparable,  it's not an exact one-to-one comparison.  Now, next, if we go over here to code droid, right,  or factory, because it really is using these code droids,  you can see they're saying that they achieved a 19.27%  on sweet bench full, and 31.67% on sweet bench light.  Again, this is not an exact one-to-one comparison,  because there's different variants of sweet bench,  and there's also different ways  that you're able to test these agents,  and you can use things like scaffolding, for example,  to make this perform significantly better.  And it was there you go, that is factory,  and now we go over to Blitzy.  Now, Blitzy claims, if we look at the abstract theory,  that it was able to have an unprecedented success,  rate of 86.8% on sweet bench verified,  which is a subset of sweet bench.  It's 500 of the requests, I believe,  exceeding the prior best by 13%.  Even more remarkably, it was able to do this  using no scaffolding hints or best of K attempts.  In other words, there's a lot of other ways  that you can essentially kind of cheat this  by doing multiple attempts, giving hints to your model,  changing the prompts, et cetera.  They're saying they didn't do any of that.  Now, I'm not here to validate any of these results.  This is simply what they are reporting  from these three companies.  In the case of Blitzy, this does seem like  a massive improvement over the other two.  And I think we'll see why in this video  when I demonstrate how that platform works.  Point is, pretty cool, those are the results  and take those for what you will.  You can read them from the link in the description.  Now, let's get into a real world task.  So the first platform to compare on our list here  is called Blitzy.  Now, Blitzy is a relatively new platform.  I actually have a full video breaking down  how it works, which you can check out on screen right here.  But the key to friendship is that this has an infinite context.  It can understand literally 100 million plus lines of code.  And it spends a really long amount of time  understanding your code base before it  starts generating any code.  The first step when you use Blitzy is you pass your repository  to it.  It ingests that repository, understands it,  and then generates an extremely detailed technical spec  or documentation for the repo.  It can be hundreds of pages long and can take  two, three, four days to generate.  That's actually how the system is designed.  They emphasize that you should spend  a massive amount of time writing the prompt  and describing what it is that you want.  And then Blitzy will generate about 80% of the code for you,  and then the remaining 20% is on you  to implement those final tasks.  So I'll show you how it works in a second,  but one thing to note about this platform is the price,  because it is very high compared to some of the other ones.  And I think that represents the value  they're trying to portray.  For example, you can use it for free to generate  these massive technical specs,  which we're going to have a look at in a second,  or you can use the pro plan, which is 10K per year,  or the team plan, which is 100K per year,  which is obviously a lot and is aimed at enterprises,  not individuals.  So this is not something you buy as a freelance game dev.  This is something you buy if you're Google, for example,  and you want to generate a massive amount of code.  Anyways, let me show you how the platform works.  So once you make an account on Blitzy  and you go to create a new project,  it's going to ask if you want to work  on a new product or an existing product.  Now, full disclosure here, Blitzy actually gave me access  to this platform to make this video.  Otherwise, I probably would not have done it  because I cannot afford 100K per year for a plan like this.  Point is, you can go to existing product, for example,  so we can click on that.  We can give it some titles.  I'm just going to go AWS and we can go create project.  From here, it's going to ask us to select our organization  and then the repo that we want to analyze.  So we'll wait a second and then we can search  for the AWS card demo.  Okay, so you can see I have the AWS repo right here.  We can select a branch, so we can just go with the main branch.  We can set up various environments  and then we can give in-depth details about our code base  which helps Blitzy understand.  Now, after we do that, we can press this button  to build the technical spec.  This is the first step.  Again, it can take multiple days to do this  and then it's going to give us the technical spec  which I'm going to show you in one second.  So here's an example of a completed technical spec.  I just have this project in multiple stages.  You can see it, you can see that it is extremely long.  In fact, I believe this one's almost 200 pages long.  It goes through advanced details.  In this case, it uses the cobalt systems.  We see like all of the assembly  and all of this low-level main frame code  that's going on gives us a full table of contents  of everything that's generated.  And this is the first step, which in my case,  I believe took about three days  before we were able to actually move on to the next step  and start generating code.  So this is that technical spec.  Then from here, what we do if I scroll back up to the top  is we press this build button.  From here, we can select what it is that we want to do  with Blitzy.  So in my case, what I did is I pressed on refactor code base.  And then from here, we can start generating  a really detailed prompt explaining to Blitzy  what it is that we wanted to do.  Now, again, the prompt that I used  is the one that I showed you earlier.  And then I waited a few days  and Blitzy actually submitted a pull request,  which I'm going to show you now  with all of the code changes.  So this is the pull request that Blitzy submitted.  You can see if we go to the files changed here  that we have 179 files changed.  We have, if we have a look here, 144,000 insertions  and 354 deletions.  And if we scroll through, we can see all  of the new modern code here developed  in Java exactly like I asked it to do.  Now, of course, I'm not going to read through  every block of code, but what Blitzy will do for us  is once it generates this, let's go back to the platform.  It actually gives us what's called the project guide,  which will explain to us what it's done,  and then what the next task story are  for us to complete as the human.  Because the thing is, this cannot do 100% of the coding work.  It's still on you as the software engineer  to finish the implementing.  But it guides you on how to do that.  So in this case, you can see that it explains this.  It says that it's completed 95% of the code.  The implementation is 100% complete,  meaning we shouldn't need to code anything.  And what we need to do next will be explained later.  So here it kind of goes.  Sir, it says, OK, I've done all of this, all of this,  all of this, all of this.  And then it says, what remains?  Here are the human tasks.  It says the remaining work consists  entirely of operational tasks that  are required to actually deploy this to a production environment,  which I'm not going to do, no code is missing or incomplete.  And then what I would need to do here  is deploy this to AWS, configure the production database,  set up the AWS services.  And it gives me that step-by-step list  that I would then go and complete as the developer.  Now, if we scroll down here, it also  explains to us that it estimates that it saved 560 hours  of human work and that there's a remaining 32 hours of work  that we would need to complete.  And a lot of that, again, is for this kind of like testing,  documentation, security audit, all of this kind of stuff,  and deployment, I'm not going to be able to validate  if that works because that would be literally  an entire job for me to do that.  But the point is, we've got into a stage  where most of the code is generated.  And again, this specific PR, I believe,  took four days to complete.  It was three or four days.  I remember the exact amount of time  after the initial ingestion, which was three days.  So in about kind of seven days of mostly idle time,  a little bit of time planning and writing the prompts,  we have pretty much the entire modernization complete.  Okay, so that's blitzy.  Obviously, quite impressive.  It's able to do all of that with literally a single prompt.  There was really no human intervention required.  Now what I'm going to do is go over to Devon,  and we're going to test that one.  So I'm inside a Devon now.  And what I'm going to do is kind of slightly in live time  show you how I would use this to do the modernization.  Now I'm going to treat this the exact same way  as I did with blitzy.  So what I'm going to do is I'm going to connect my repository.  So I did that the AWS mainframe modernization card demo.  I am in the agent mode, it's not the legacy mode,  but the new one.  And then I've given it the exact same prompt  that I gave to blitzy where I'm going to ask it  to essentially do all of this modernization for me.  Now this is a much more iterative approach  because this works significantly faster,  but it also does not have an infinite context,  and it's not capable of generating  into 150,000 line changes in a single prompt.  So I'm going to have to go a little bit back and forth,  but we'll see, even with my experiences as a developer,  if I'm able to get to that same stage.  So let's go ahead and press enter here,  I'll submit the prompt, and I will kind of fast forward  through this and explain to you my process  and if this works.  Now while that's running, I'll just give you  a quick overview of Devon.  Now Devon claims to be the AI software engineer.  It can actually directly integrate with Slack and linear,  which means if you submit a ticket, for example,  it can automatically pick that up  and start solving it or implementing the solution.  You can see that it can create a plan,  it can automatically test itself,  and then it can create a PR story that you can review.  Now, one of the cool things about Devon  is that it has access to its own computer  and own coding environments.  You can actually watch it in real-time generating commands,  using the terminal, opening up a browser  and testing something.  Pretty much all of these tools have that now,  but I like how Devon implements that.  And overall, it works pretty well on smaller projects.  So this isn't really designed to write hundreds  of thousands of lines of code as you're going to see,  but it is good if you're doing a small ticket  as it's kind of pitching right here.  Now, if we just go into the pricing,  because then it is fair to compare it like that,  you can see that it is $500 per month for the team plan.  The core plan pays you go.  I'm not sure exactly how much that would cost you,  but it starts at 20 bucks.  And then enterprise, obviously,  I don't know what that pricing is,  but I imagine it would get quite expensive,  depending on how much you're using it.  Anyways, let's go back and see if that is finished  and it looks like it is.  So let me open up some of the details, check it out,  and I'll be right back.  So this is the pull request that Devon generated.  Now it gives us a summary here  and says this PR implements a complete modernization  of the AWS card demo application  from its original main frame implementation  to cloud native Java 21 microservice using Spring Boot.  Okay, we can go through here  and explain the new directory that it created,  the database, the APIs, the cobalt program mapping,  and then tells us what we need to do here for human tasks,  similar to what Blitsey gave us.  Now, the main thing that I want to note here  is that it only changed 38 files, right?  So while it's claiming that, okay,  I know it's made this entire change for us  and we can read through that documentation to see it,  it's only made 3341 insertions,  and while that makes sense,  because it was only running for about 25 minutes,  I'm skeptical that this has actually implemented everything,  it has that full feature functionality  that we were looking for like we had gotten with Blitsey  where it did, I mean, what is that?  Like 50 times the amount of code changes.  So let me have a look and see if that's the case.  So like I was mentioning, this didn't implement  the full functionality, so I essentially told it,  hey, this is not implement the full functionality,  we need to make it the exact same as the original implementation,  but in Java, and now it's gonna go ahead  and start working on that by actually reading  through the entire code base.  So again, requiring a little bit more manual work here  makes sense because it is a little bit more iterative,  but,  Because it doesn't have that infinite context window and it doesn't create that detailed  spec beforehand, it's difficult for it to actually complete the full task that we want  without us really having to be a lot more careful in terms of checking it and making sure  it's giving us, you know, exactly what we're looking for.  So just as an example, right, I asked to do that and now it comes up with, you know, 17  more features that it missed that it needs to go and implement.  So if I want them to perform well here, I really need to kind of manually have all of these  different tasks that I want it to complete.  I need to write all of them out individually and then I need to go and ask it to perform  those kind of one by one or keep going back and saying you're missing it, you're missing it,  you're missing it, you're missing it, which is going to require a lot more human intervention.  Now again, it is working faster because, you know, it doesn't take days to generate the code,  but it requires me to be a lot more attentive in terms of what this model is doing and really kind  of go back and forth with it. So we'll let that run for now while that's running though, I want to  get started with factory. So let's hop over there and see how that one performs.  All right, so moving over to factory here, which is the agent native software development  environment. And you know, it claims it's the only software development agents that work everywhere  you do. Now, the cool thing with factory is that you can connect this to both remote environment  as well as a local environment. So what I'm able to do is actually directly connect this to my  own computer, which I'm going to show you in a second. So I can have like a project open on my  local machine. This can be connected to it. And it can be working through that rather than  working purely in the cloud, which I think is pretty cool. So I'll show you kind of how that works.  It has all of these different droids. So it has like a software engineering droid, you know,  a documentation droid. I believe it has like a product management droid has all these  different ones that are capable of different tasks. And it kind of collaborates between them and  hands off the tasks with them. So let's quickly go and look at the pricing. So you can see here,  you know, max $200 for month, same thing enterprise. Like we don't know how much that one's going to be.  They have the free one. And then they have the pro version. So let's hop into a session here.  Let's give it the task and then get it to start working. So what I've done here is I've  connected this to my local workspace. The way I did that is I have this thing called the factory  bridge. Let me bring it up on my screen here. And I've just opened the project in cursor here.  This is the original what do you call it project just on a new branch where we have all of the  cobalt, you know, information and all that kind of stuff. So I've connected to that. I've select  that project. And then what I'm going to do is paste in the same prompt that I had before. The  first one that I gave to Blitzy and the second one that I gave to Devon again, same prompt. And what  we'll do is just go ahead and press on enter and get this to start writing the code. So it's been  about 10 minutes now. And the factory has started here by just developing a pretty detailed plan  of what it's going to do. It hasn't written any code yet. So what I'm going to do is just tell it to  proceed here. So it says, what do you like me to proceed with the initial scaffolding PR? Yes,  proceed. And let's see if it's going to continue here and start writing out all of the code.  So it's been about 10 minutes now. We've generated looks like 30, 40-ish files kind of similar to  how many Devon had done before for the first iteration. It's giving us a kind of reme  here telling us how it's done this. And it's now telling me that it can continue by  implementing the ingestion for daily transactions, adding the test containers, etc. So I'm going to  say continue with the functionality and we'll see kind of how many more iterations we need to go  through here. So I've been messing with this now for another 30 minutes or so, sent a few more  prompts to it. I'm kind of getting it to iteratively build out the rest of this project. But the one  thing that I'm noticing is because this doesn't have as deep of awareness and context as Blitzy  does, for example, it's very difficult for this to know exactly what it's supposed to add.  And unless I'm extremely detailed in what I wanted to do, it's really missing a lot of the core  features and it's oversimplifying the project. And that's what I've noticed with both this and Devon.  Well, they definitely are faster and they can handle a lot of those smaller tasks super quickly  and a lot more iteratively, especially if you know what you want. If you want something a lot  larger and you want it just all done right the first time, it's going to be very difficult to get  these to do that. Unless you're extremely specific with the context that you're feeding it,  and you're really doing you know, prompt engineering like every single time the use send is  a prompt. So you can see again, this is kind of what we got to after about, you know, maybe 45  minutes of me kind of messing around. We don't really have that many files. Well, sure, it's simple  and like a lot of code was generated. It's definitely not, you know, a comprehensive view of the  application. So while I'm sure we can definitely get there and do the full modernization,  it's going to take me a really long amount of time to do that in a massive amount of human  effort in combination with this AI. Now same thing with Devon here, I messed around with it a bit.  I was kind of doing these back and forth while I was waiting for one to run and you can see that we  got up to about 6,400 lines of code. We have 77 files changed. And while again, I've started adding  a lot more features here. It's really not comprehensive and it didn't do the full modernization compared  to if we go back to the Blitzy pull request.  where we had exponentially more code changes,  179 files and 144,000 lines of code.  Now I'm not using that as the only metric,  but the point is because this had the full context  and it spent all of that time ingesting the code base,  it was able to produce just a better,  more accurate enterprise grade result,  whereas with Devon and Factory right now,  we're getting more of a hobby project  kinda type vibe for the code  because it's just not capable of generating  that many files in one time.  Can we get it to enterprise level?  I'm sure we can, but it's just gonna require a lot of effort.  So I'm not gonna keep going with this example.  This is kind of what I was aiming to show in this video  that all three of these tools,  obviously they have a different price point,  they have a different user,  and they're capable of different things.  If you want something enterprise grade,  I think it's clear that if you have the money obviously  going with something like Blitzie makes a lot of sense here.  If you want something that works on both the local  and the remote environment, if we go back here,  Factory works really well for that.  And if you want the kind of AI software engineer  that can automatically pick up those tickets,  solve some of those smaller tasks,  Devon seems to work quite well for that.  And again, you kind of have the pricing  reflecting the value there.  So anyways, that is what I wanted to demo in this video.  I think it's interesting to compare these agents.  Obviously it's difficult to do it across some  uniform standard.  There's always gonna be biases involved,  different examples they're gonna perform better in,  but I think generally this showed  what they're capable of.  And I think we also saw that with the sweet bench results  that I was talking about earlier in the video.  Anyways guys, that's all that I have for you.  If you enjoyed the video, make sure you leave a like,  subscribe to the channel,  and I will see you in the next one."
1-Ic_HtNS_U,Should you use AI as a beginner developer?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-10-31T21:26:18Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/1-Ic_HtNS_U/default.jpg,https://i.ytimg.com/vi/1-Ic_HtNS_U/hqdefault.jpg,PT49S,16400,403,16,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"So point number one in favor of using AI is  that it drastically accelerates the learning curve.  Now there's been all kinds of research out there  and I could see this firsthand from many of my students.  Those of them that use AI just learn faster  than those that don't.  That's because it can instantly reply to anything  that you need and you don't need to wait for someone  to answer you on Stack Overflow or for your teacher  or tutor to give you a reply  and it can adapt to anything that you ask it.  Now reason number two in favor of using AI  is that it really does reduce frustration.  I know a lot of times when you're learning something new,  you get frustrated with small errors, bugs,  little things that you don't understand  where otherwise you would need to spend hours  trying to look up the answer,  need to find someone to explain it to you.  But with AI, it can just instantly solve that problem.  It can instantly help you overcome  that little issue that you're running into."
Rq9GYPPkwPY,Is college ACTUALLY worth it?,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-10-30T19:24:22Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/Rq9GYPPkwPY/default.jpg,https://i.ytimg.com/vi/Rq9GYPPkwPY/hqdefault.jpg,PT45S,11392,237,7,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"I think if you're someone who's like a go-getter,  you know you're really motivated,  you know you're gonna work and like the time  you would spend going to college,  like you're actually gonna spend that time on your own  not playing video games and not just like  sitting around doing nothing,  then you can probably learn the stuff you need to learn  more effectively on your own than you can in college.  At that point, I was now making a lot of money  bluntly from my YouTube channel.  I'd already landed an internship at Microsoft  and all of the things the college was supposed to give me,  I pretty much already had, I'd already accomplished them.  And I just asked myself like, is this opportunity cost  really worth it?  Should I pay, you know, $15,000, whatever I have my own money  to finish this degree where I know every single second  I'm doing it, I'm gonna make less money.  It's gonna take away from the progress I can make.  And I ultimately just made the decision,  I really don't think I need this.  And if I do ever actually need it,  I can always just go back and finish it."
SR5NYCdzKkc,Learn Fast API With This ONE Project,"ImageKit is an image and video API plus AI-Powered DAM that we use in this project to handle all of our image and video operations, check it out here: https://tinyurl.com/bdf3mxxx

I'll teach you Fast API by working through a real project. I'll go over everything from the absolute basics to some more advanced concepts like setting up authentication, logging in various users, connecting to a database, and all of the components that you actually need if you want to build a real production grade application. This video is not designed for absolute beginners.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=SR5NYCdzKkc

üéû Video Resources üéû
ImageKit:  https://tinyurl.com/bdf3mxxx
ImageKit Docs: https://imagekit.io/docs/integration/python#generating-url-for-rendering-images-in-python-app
FastAPI Users Docs: https://fastapi-users.github.io/fastapi-users/latest/
Code in this video: https://github.com/techwithtim/FastAPIPhotoVideoSharing
UV Tutorial: https://www.youtube.com/watch?v=6pttmsBSi8M

‚è≥ Timestamps ‚è≥
00:00:00 | Video Overview
00:00:35 | Project Demo
00:01:58 | Web App Architecture & Theory
00:14:07 | Project Setup & Install
00:20:45 | FastAPI Setup & Basics
00:28:10 | FastAPI Docs
00:30:10 | GET & Fetching Posts
00:32:25 | Path Parameters
00:33:49 | Raising Errors & Status Codes
00:34:56 | Query Parameter
00:38:34 | Request Body & POST
00:43:28 | Output Type & Pydantic Models
00:46:30 | Database Connection
00:59:57 | Creating Posts & Saving to Database
01:05:22 | Retrieving from Database
01:10:27 | Image & Video Upload (ImageKit)
01:27:08 | Deleting Posts
01:30:54 | User Authentication and JWT Tokens
01:52:02 | Protecting Endpoints
01:58:00 | Streamlit Frontend

Hashtags
#FastAPI #ImageKit #SoftwareEngineer",2025-10-30T13:26:08Z,"tech with tim, fastapi tutorial, fastapi project, python api development, building apis with fastapi, fastapi routing, fastapi path parameters, fastapi response modeling, fastapi interactive docs, python web framework, python backend development, creating rest apis, fastapi for beginners, python api tutorial, developing web apps with fastapi, fastapi deployment, async python apis, ImageKit",27,en,en-CA,https://i.ytimg.com/vi/SR5NYCdzKkc/default.jpg,https://i.ytimg.com/vi/SR5NYCdzKkc/hqdefault.jpg,PT2H5M44S,60303,2027,160,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"In this video, I'll teach you fast API by working through a real project.  I'll go over everything from the absolute basics to some more advanced concepts like setting up  authentication, logging in various users, connecting to a database, and all of the components  that you actually need if you want to build a real production grade application.  Now that said, this video is not designed for absolute beginners, while I will teach you  everything from scratch as it relates to APIs and kind of web app development, I'm going to assume  that you have some experience in Python. That said, let's quickly have a look at the finished  project, and then we'll get into some of the theory and start writing some code.  So the project we'll be building here is a simple photo and video sharing application.  Think of it like the really early days of Instagram, except it won't have nearly as many features.  Now the way this works is you can sign in, so I've set up a really simple user interface here  in something called Streamlit. We'll talk a little bit about that later in the video,  but this isn't going to be focused on building the interface. It's more going to be focused on  the back end and the logic and the well API with fast API. So you can see that I was able to  sign in here and then immediately I'm brought to a feed where I can see some different photos,  I can see the date they were posted and the user that posted them. And then I also have some  videos as well. Now you have the ability to upload something. So for example, if you were to come  here and let's just pick maybe a random photo that we have here, okay, let's just go like this and  call this thumbnail, and then we share it. It's just going to take a second, and then this will  be uploaded to our feeds right now, just uploading the video. And if we go back to the feed here,  we should see the photo appear and you can see the photo shows up by us, and then it's on today's  date when I'm recording this video. Okay, so that's the application. I know it seems pretty basic,  but I promise this is going to teach you a ton of concepts that you need to understand as it relates  to fast API. And I think the most important thing is all of the authentication and authorization,  which most people skip in these beginner type tutorials. So with that said, let's hop over to  this my reward that I put together because I want to start going through some theory that's really  important to understand before we can even start building APIs. And by the way, as we get later  into the video, and we're going to start setting up the images and videos, that is notoriously  pretty difficult to do. In order to do that effectively, we're going to use today's sponsor image  kit. Don't worry, they're free to use and play with. You don't need to pay for them, and they  just make this process significantly easier. So big shout it to them, but more on that later.  Okay, so let's get into the video. Now, we're going to use fast API, right? This is fast application,  programming interface. That's what API stands for. Now, this is essentially a back-end framework.  What that means is that this is going to be running on some type of server, and it is going to be  essentially controlling data. All an API really does for us is it facilitates the access and control  of data. In our case, it's going to be image or video posts, right? Or different user accounts.  But before we can get into all of that, we need to start understanding some kind of core concepts  of web apps in general. So let's start by talking about URLs and endpoints so that we can get the  terminology out of the way. Now, this whole thing right here, and this one as well, is a URL.  You've seen this millions of times before, especially when you've browsed to a website,  and I want to just go over the components of the URLs so that we understand what they are.  Now, the first is the domain. The domain is essentially the website, the space of the URL,  so training.dev launch.us. This is our domain. Tech with Tim.net. This is the domain. The domain  will typically end in like .us or .com or .net or .ca or something along those lines.  Now, after the domain, you have what's referred to as the path or sometimes called the end point.  Now, this is the particular route or kind of the page or resource that you're going to be accessing  from this domain. So, for example, we have training of dev launch.us slash Tim. So I'm going to  the slash Tim page right here slash courses slash Python. So I'm going to the Python courses page  right. And for a typical website, these make a lot of sense. But for our APIs, we're going to have  to design these ourselves to kind of control the access and the route or the end point to particular  resources. So when we look at the project that we're going to build here where we're sharing  you know, videos or photos, we might have an endpoint that is, you know, rapi.com slash photo,  right. And then we can access a particular photo. You'll see what I mean in a second, but let's  keep going. Now, the next point is the query parameter. Now, the query parameter is some extra  bit of information that is typically used to filter the page or to get some more specific type of  data. It always will come after a question mark. So you'll see some kind of path or endpoint,  a question mark, and then one or multiple query parameters. In this case, we have a parameter,  video equal to one, two, three. Okay. And then if we come here, we have UTM sources equal to YouTube  and page is equal to two. So we have two parameters. And you can have as many parameters as you like,  you just have to have these ampersand that separates them. Okay. So you just understand that these  are the core components of a URL and an endpoint. Now, let's keep going here and talk about  the request and the response structure.  So whenever we visit some type of website,  we refer to that website as the client or the front end, okay?  So us as a user, we go to our computer,  we type some website.com, okay?  And then we are now on the client or the front end, okay?  And the front end is this kind of visual interface  that we're able to interact with,  that we're able to use.  In the case of our post application  or our photo application,  we can see the different posts, right?  We can make a post, we can sign in, we can sign in.  Now the way that that actually works behind the scenes  is that this user interface is communicating  with some type of API.  API stands for application programming interface.  The API you can essentially see as kind of a secure layer,  it's running on a different device,  some kind of server,  so some computer essentially sitting in some location,  and it's facilitating all of the access to our data.  So if we want to sign into our account,  we send a request from the front end  where the client to this API,  and this API returns some response, okay?  This is the flow that I'm trying to get you to understand.  You go to some website, you do something.  If this thing involves some access to data, right?  Especially if it's maybe some confidential data  or something, what needs to happen  is a request will be sent to some backend,  this kind of secure location.  It will essentially check,  can this user do the thing that they want to do?  And then if they can,  it will send this response back doing that thing.  For example, deleting a post,  we would send a request to the backend,  the backend would say, okay, yep,  you know, I'm gonna be able to delete this post,  and then it would return the response saying,  hey, this post was deleted.  I want to upload a photo,  I send a request to my backend,  I say I want to upload some photo,  it returned some response and says,  yes, your photo was uploaded successfully.  So all of the heavy lifting,  all of the secure operations,  everything related to data essentially takes place  on this backend or this API,  and that's what I'm gonna be showing you  how to build in this video.  Now, when we send a request,  so we have this front end, right, this client,  it sends some data to the backend,  and the main parts of a request are the following, okay?  We have a type of the request,  which we're gonna talk about in a minute, or the method.  We have a path, the path is what we looked at here, right?  So this path or this endpoint,  and oops, I didn't mean to say that,  and we have a body, this is optional,  but this includes additional data  that we wanna send along with a request.  So for example, like the image that we wanna upload,  or the caption, or the name of the post  or something like that,  and then we have headers,  this is typically other additional information  that has to do with things like authentication.  So in the header of our request,  we would include something that indicates  that we are this user, okay?  We are signed in as Timatek with Tim.net,  and the header would kind of indicate that  when we send that to the backend.  I know this seems a little bit vague, just bear with me.  We're gonna make all of this crystal clear,  sorry, when we actually get into the API example.  We then have the response, okay?  So the request is the thing that we send  from the front end to the backend essentially saying,  hey, we wanna do something,  and the response is what comes back from the backend  to our front end or to our client.  Remember, the front end is the thing  that you as the user actually see,  and then the backend is the thing  that we as the developer typically write,  that facilitates all of the communication and the data.  So from the response, we include a status code.  You may have seen something like 404 before,  which means not found.  That's an example of a status code.  So our backend will send a status code to the front end,  indicating what happened with the request.  Common status codes are something like 200, for example,  which means successful.  I'm gonna show you a few more in a second,  and you got the idea.  Then we have a body, same as we have the body  in the request, we can send some additional data  back to the front end that the front end may need,  and then we have headers.  Same thing, headers will be related  to typically security authentication,  the type of data, some weird things like that.  If I scroll down here,  I'm just gonna show you a few status codes,  and a few of the request types,  which are important to understand.  Actually, let's start with the request types.  So here's an example of a very simple API.  This is a books API, and this is the slash books route  or path, or endpoint, or whatever you wanna call it.  Now you can see that we have something called a get endpoint.  What this means is that we are retrieving some data  from this resource, essentially, from slash books.  We then have delete.  This is the type of method you would use  when you want to delete something.  We have post, this is the type of method you use  when you want to create something,  and you have put, this is the type of method you would use  when you want to update something.  So remember how I mentioned, when we send a request,  we specify some type or some method,  and that indicates what the front end wants to do.  So if the front end wants to get some data  about some books, it sends a get request.  If it wants to delete a book,  It sends a delete request.  If it wants to create a new book, it sends a post request.  And you can send all of these requests to the same routes, or the same endpoint, and based  on the type of the request, you can do something different.  So I hope that makes sense, but these are the common methods or types of requests that  you can set.  Then we go over to HTTP status codes.  Now, you don't need to memorize all of this, but these are just some examples of status  codes that you may see.  So you send this request, or you say, hey, I want to get a book, for example.  All right.  Then what the back end of the API is going to do is it's going to retrieve that data  for you.  It's going to send it to you.  And along with that, it's going to give you a status code.  So for example, it may say 200, which means OK, may say 201, because it created something.  You know, you get all these different ones, like these redirection, you have errors, like  bad request, unauthorized payment required, a bunch of stuff that you can look at, you know,  internal server error.  Don't need to memorize them.  I'm just showing you that there's a bunch of status codes that are commonly used in  web development.  OK.  Now, let's just have a look at an example request and response, and I promise we'll get  into the API.  And again, this will all crystallize, but this is just going to really help you understand  how we design the APIs.  OK.  So a user wants to update a post that they made.  So the type is patch.  This is actually the exact same thing as put.  So if you ever see patch, it's the same as put, which just means you want to update something.  If I wanted to create something, I would use post, right?  But I don't want to do that.  I want to update some using patch.  OK.  So the type or the method in my request is patch.  The path is slash API slash post, and then this is the ID of the post.  So I'm saying, OK, on it go to my API, I want to modify post.  This is the ID of the post that I want to modify.  And then the body would be this.  This is the data that I'm actually sending where I'm saying, hey, this is the updated title.  And this is the new caption that I want to use or the description or whatever for my  post.  Then the headers includes this.  This is essentially my authorization token indicating, hey, I'm authorized to be able  to perform this operation because of this thing right here, which we'll talk about later  on.  So we take all of this.  We send this to our backend, and then this is the request, OK, that we create.  Now from the backend, we get a response back.  So we send a request, we get a response back.  And the response looks like this.  We have status code 204, which stands for updated.  And then we have some body.  And this body says, hey, this is the title.  This is the description.  This is the post ID.  This is when it was updated.  This is when it was created.  And it gives us that information back to the front end so we can display it to the  user.  We then have some headers.  And in this case, we say, hey, the type of data that we're returning back here is  application slash JSON, which is essentially just the format of this data, which we can  talk about later.  OK, I know that's a lot of information.  So that is the kind of flow of an API.  And hopefully this is going to help us understand how we create APIs in a minute when we start  coding them out.  Now, last thing that we'll talk about a little bit later, I'll just quickly show it  to you is the authentication.  So when it comes to using an authenticated API, it's a little bit more complex than simply  sending requests and getting responses.  Essentially, what you need to do is get something called a JWT token.  This JWT token looks something like this where you send this along with every single request  to indicate, hey, I'm authorized to perform this type of operation, essentially, you're  identifying yourself and what user you are so that the API knows you can do this thing  or you can't do this thing.  You'll look at that later.  I don't want to confuse you at this point, but that is kind of the primer on web app  development and APIs again, think of an API as essentially this kind of backend server  that sits there, that facilitates all of the operations that have to deal with data,  creating, reading, updating, deleting data.  That's effectively what an API almost always deals with and it's doing that so we can  do it in a secure way and then return data to some front end where the user can view  it, display it, you don't mess with it, etc.  So with that said, let's get onto the computer and let's start actually writing some code  in fast API.  All right, so I'm inside of my code editor here and for this video, I'm going to be using  PyCharm.  Now you can use any code editor or IDE that you want, but I typically do recommend PyCharm,  especially for Python projects because, well, it is PyCharm and it supports Python the  best.  In fact, I do actually have a long-term partnership with PyCharm, so if you want to use it  for free, you can click the link in the description, try it out and see if you like it.  It definitely is a great editor and again, what I recommend for pretty much any heavy  Python projects.  Okay, so what I've done inside of PyCharm is I've just opened up a new folder.  You can see I've got a folder here called fast API tutorial.  The way I did that is I essentially just went to open and I just opened a folder on my  desktop.  Okay, and you can again use any editor that you want, I'll just make sure you open a folder.  Now, from here, what I'm going to do is I'm going to open up my terminal and I'm going  to start setting up my fast API project.  Now, in order to do that in Python, you need to use something called a package manager.  There's  Two notable package managers in Python, the first is PIP.  The second is UV.  Now I'm gonna suggest that you use UV  because this is significantly more modern  and it just works a lot better.  But if you don't wanna use UV,  you can replace the commands I'm gonna show you with PIP.  Okay, so UV is something that you need to install.  If you don't have an installed,  I will leave a video on screen that explains how to do so.  But once you have UV installed on your computer,  what you can do from this open folder  is you can type UV and NITs and then dot.  What this is gonna do is create a new UV project for you  where you're able to isolate all of the dependencies  for this particular project in this kind of one folder.  Okay, so we're gonna type UV and NIT dot.  What that's gonna do for you is it's gonna create  a few files inside of your folder.  You're gonna see a main.py file, a PyProject.tomal,  and a few other files that you don't really need  to worry about too much.  Now this PyProject.tomal file is gonna include  all of the dependencies for your project  and it's what we're gonna start modifying now  by installing some different dependencies  that we need for this project.  So if you wanna work with fast API,  in order to do that, you need to install it.  So what we're gonna do is we're gonna type UV add  and then we're gonna start by just adding fast API.  Okay, so we're gonna type UV add fast API.  When we do that, if we go back into PyProject.tomal,  you'll see this dependency has automatically been added for us.  Okay, now that we have it installed,  we'll be able to actually use it  inside of our Python code.  Now as well as fast API, what we're gonna do  is we're gonna type UV add  and we're gonna install Python-.env.  Now this is something that we need to use  to manage environment variables  because in a minute, we're gonna have some environment variables  for handling our images in videos.  So we're gonna go ahead and install this.  Now there's a few other things that we need to install as well.  So just bear with me.  We're gonna type UV add  and we're going to install fast API, dash users,  and then inside of square brackets,  we're gonna type SQL alchemy like this.  Okay, so make sure it's spelled exactly like this.  UV add fast API dash users, SQL alchemy.  This is what we're gonna use when we start handling  the authentication and the authorization  later on in our project.  So we're gonna go ahead and press enter  and then same thing, it should get added to our dependencies.  Okay, there's a few other ones that we're gonna need here.  So we're gonna type UV add  and then we're going to add the image kits.  So we're gonna say image kit like this  and sorry, it's gonna be image kit IO.  Now this is the package we're gonna use  to handle our images and videos again,  which we'll look at later on.  We're also going to say UV add or we're gonna add UV corn  and then standard.  UV corn is a web server in Python  that allows us to serve our fast API application.  You'll see how that works in one minute.  So we're gonna add UV corn  and I promise we are almost done  just a few more than we need to add.  And then sorry, we're gonna add one more here,  which is gonna be AIOSQ light like that.  We're gonna use this for interacting with our database.  We may potentially need some more later,  but for now I think this should be fine  and that should handle all the dependencies  that we need for this project.  Okay, so we're gonna close that  and we're just gonna quickly go here  and make a new environment variable file.  Now to do that, we're gonna go new file  and we're gonna call this file dot ENV.  This is the file that you create  when you wanna store sensitive credentials, tokens  or keys that your application is going to rely on.  In our case, we need to access a key for image kit  which is going to allow us to handle  the image and video uploads which I wanna do now.  Okay, so inside of this file,  there are three variables that we need to define.  The first is gonna be image kit,  underscore private underscore key.  All right, the next is gonna be the image kit  underscore public underscore key.  And then the last is gonna be the image kit  underscore URL.  Okay, so we're gonna put equal signs for all of these  and we're just gonna quickly grab these three values  so we don't need to come back to this  until much later in the video.  Now you may be wondering what the heck are we doing Tim?  We have Newman started writing the API.  I promise we're gonna get there.  I just wanna get through everything,  do all of the setup and make sure that it's all ready to go  so we can just focus on coding  and I'm not moving around too much.  Right now what we're doing is we're creating  this essentially kind of secret environment variable file.  This is something that's gonna hold some values  that we need for uploading the images and videos.  Like I mentioned, we're gonna use image kit to do this.  So what I need to do is get some keys and values  from image kit.  So I'm quickly just gonna open up the image kit website.  I'm gonna leave a link to this in the description.  What we're gonna do is we're just gonna make  a new account on here.  Again, it is free to use this.  You do not need to pay for it.  And essentially what this does is give you all kinds  of amazing tools for handling your images and videos  which is typically a huge pain.  But they have all kinds of things like image  and video optimization, format and cropping.  It's very interesting.  So anyways, what we're gonna do is make a new account.  I've already just made a new one.  So again, I'll leave that link in the description.  And from here, what we're gonna do is go on  to the developer options.  From developer options, we're gonna look for our public key,  our private key.  And then we're gonna get our URL, which is up here.  So I'm gonna copy my public key.  And then I'm going to put my public key right here.  I then am going to copy my private key, which is something that you do not want to share  with other people.  And before it will allow you to do this, you do need to set a password for your account.  So if you press this, I'm just going to blur my email, but I'll press the profile  page and I'll just quickly set a password.  Okay, now the password is set.  So we'll go back to developer options.  We'll go private key.  And I'm just going to copy this after I use my password.  So let's use that and copy this.  Okay, so now that I've copied it, I'm going to go back to PyTram.  I'm going to paste it.  Again, don't share this with other people.  I will delete it afterwards.  And then lastly, we're going to grab this URL endpoint, which should be right up here.  And we're going to paste this inside.  And now we have the keys that we need.  Okay, so we're going to close the environment variable file.  And now what we're going to do is start setting up kind of the scaffolding for our project.  So I'm going to make a new folder.  And this folder is going to be called SRC.  This is typically best practice when you're writing a fast API application.  You create this source or actually let's change it to be an app directory where you actually  have all of the code for your application.  And then you have this main.py file, which is kind of what triggers the application to  run.  So what we're going to do inside of this app folder is we're going to make a new file.  And we're going to call this app.py.  And this is where we're going to start actually writing our fast API app and start getting  into some Python code.  All right, so let's start writing a API.  We've gone to the point where everything is set up.  What we're going to do from this file right here.  So from here, we're going to type from fast API import fast API with this capitalization.  And we're going to say app is equal to fast API with a set of parentheses.  Now this is the fast API application that we just created.  And what we'll need to do now is start setting up the different paths or endpoints that  we want to have accessible on our API.  Now remember for our API, we're setting this up essentially to handle data to be able  to accept some type of request from our front end or our client and to return some type  of data.  So we can create data, delete data, read data, update data, right, we need to decide because  we're designing this API.  So I'm going to start by just writing some simple dummy endpoints just to test and see  how this works.  Then we'll get into endpoints and actually make more sense.  So the way that you make an endpoint in fast API is you type app, which is the name  of this variable right here that we defined dot.  And then you specify the method for this particular endpoint.  So it can be get, post, put, delete, depending on what you want this to do.  Now the most basic type, which is common is to use app dot get.  Now when you do this, what you're going to do is you're going to specify the endpoints.  We're going to say slash and that's something like, you know, hello, dash world, okay?  So this is the path or the endpoint.  Now I also forgot I need to put an app symbol here because this needs to be a decorator  in fast API, a decorator is something with the app before it.  And what you do beneath this is you define a function.  The function should typically be named something similar to this endpoint or path, but it  doesn't need to be.  You put a set of parentheses and then inside of here, you can return some data.  So let's just quickly return the auto completed data where it says message, hello world.  Okay.  So we have app.get slash hello world.  What we're saying is, hey, when you go to our API and you go to slash hello world,  this function is going to be called and then we're going to return this data.  Now the data that we always return from our endpoints is either going to be a pedantic object,  which we'll talk about later.  I know that might not make a lot of sense or it's going to be a Python dictionary.  The Python dictionary looks like this, right?  You have some key associated with some value.  And the reason why we return Python dictionaries is because when we create APIs, we work with  something called JSON.  Now JSON stands for JavaScript object notation.  It is the format essentially for dealing with data across the web.  And you can essentially think of JSON the exact same as you would think of as a Python dictionary.  Okay.  It's not exactly the same.  There's a few minor differences, but in our case, we can assume that anything that  is a valid Python dictionary will be a valid JSON object.  Again, keep in mind, there's some caveats there, but generally that is the case, especially  with simple data.  Okay.  So now we've got this application, right?  We've defined this endpoint, but what we need to do is run it.  Now, there's many different ways to run the API, but the way that I'm going to suggest  we do it is by going into this main.py file here, deleting everything inside of here,  and then importing this app file and running it using something called uvacorn.  So what we're going to do is we're going to say import uvacorn like this.  We're then going to say if underscore name is equal to underscore main underscore.  underscore underscore, then we're going to say uvacorn dot run.  We're going to app dot app colon app.  I know this seems weird.  I'll explain what is in one second.  We're going to say host is equal to zero dot zero dot zero and we're going to say the  equal to 8,000, and we're going to say reload is equal to true.  Okay. Now, what are we doing here? Well, first, what we're saying is,  all right, I want to use this web server called Uvacorn, which we've already  installed right with UV. And I want to run a web server. Now, for the web server,  I want to run an API on it. The API that I want to run is app.app. So that's  inside app. So the app folder here, the app file, and then I want to run the API,  which is inside of the variable app. So let's say I were to change this and I  called this high. Okay. Then I would change this to be high. All right. So just  keep that in mind. That's how I'm getting these variables essentially. So we have  the name of the folder is app, right? The name of the Python application is app.  And then this here is app, and we have app.app call him app. Probably should have  picked a better name for that. But it's okay. Hopefully you get the idea.  Now, when I say host, this is specifying the domain, essentially,  that I want to run this server on because we're running this locally on our own computer,  when I specify zero dot zero dot zero dot zero, that just means run it on any available domain.  So it's going to run on what's called local host, which is just our own host. So only we can access it  as well as our private IP address, meaning anyone else on the network would be able to access this  as well. If they knew the private IP address of this machine. Now, there is ways to run this  publicly. So anyone can access it, not going to get into that in this video. But essentially,  the way that you're going to be able to access this application is you're going to go to whatever  the IP address of this machine is. If we're on the same machine, it's going to be local host.  We're going to go to port 8,000, and then we can access this resource right here, which is  slash hello dash world. So for this, what we can do is run this main.py file. To do that,  we simply type uvrunmain.py. Go ahead and press enter, and it says that there's some issue.  This is because I'm currently running this app on another, what is it editor? So let me just  shut the other app down and rerun it, and then we should be good to go. You can see that it's running  now. Again, that issue you want to run into. It's because I had a demo application running in a  different editor that I have open. You'll see what's happened here. It's now says you've  run running on, and then it shows you the URL or the domain where this is running, right?  And then it kind of goes through this thing saying, hey, you know, started the reloader process,  and by me specifying reload equals true, anytime I save or make a change this file like if I do  something, I don't know. Hello here, and then I save this, you'll notice that the file or sorry,  the server will shut down and restart with the changes that I made. So it's really useful for  when we're debugging and building something because it just shuts down and restarts anytime you make  a change. Now, if I want to actually be able to view my application, what I can do is go to this  URL, so you can just click it and open it up. Now it's saying the zero dot zero dot zero isn't working,  so what we can do is change this to be one two seven dot o dot o dot one or local host port 8,000,  and when we do that, it should give us this thing here saying detail not found. That is totally fine.  That's exactly exactly what we're expecting. Okay, so our API is now running and it's time to talk  about the coolest feature of fast API, which is the docs endpoint. So here, what you can do whenever  you have a fast API application is you can go to slash docs. Okay, when you do that, it's going to  bring you to a page that looks like this, which actually specifies all of the end points and the  configuration that you've set up for your API. So from here, if I open this up, we'll be able to  actually test out our API by pressing this try out button. This is going to send a sample request  to this endpoint and then tell us what the response would have been. So what I can do is press try it  out. I can press execute. And then you see what it does is it sends a request to this URL. And then  it tells me that I got this as my response saying message, hello world. And then it also told me the  code of this was 200, which means success, okay, 200 successful response. So there you go. We just  send a request, right? We test it out. It's all working. This is the thing I love about fast API  is that you can actually do this. You can directly go here and test out all of your end points  by simply going to this slash docs endpoint. This will become more useful later on, but always check  this out. It's very, very useful. Now, there's also another endpoint called slash redock. This is  kind of a newer version of that docs endpoint. It works the exact same way. We can test this out if we  want, you know, test API, et cetera, et cetera. I can kind of see how this works. I am not going to  dive into this too much right now, but the point is there's this other endpoint called redock,  which you should be aware of, but the one that I prefer to use is called slash docs. Now,  just another quick thing. If we wanted to, we also could just directly go to slash hello-world.  If we do that, you see, we'll give us message hello world because we set up a get endpoint.  And by default, whenever you go to a URL in your browser, you send what's called a get request,  right? And because we sent the get request, we got the response back and the browser is able to  actually render it and show it for us.  But generally for all of the other endpoint requests we're going to be looking at,  we're going to have to use this slash docs page or another tool to test the API.  So we've now written this dummy get endpoint.  However, it doesn't really help us accomplish our project goal of creating posts.  So what I want to do now is I want to start adjusting the endpoint to actually make sense to our  project. It will change over time, but we're going to slowly build towards what's called a  crud application where we have create, read, update, and delete functionality.  So what I'm going to do is I'm going to delete this, and I'm going to start setting up some  stuff for handling posts. So what I want to do is I want to set up my application so I can  essentially retrieve and create new user posts. For now, we're going to start with text posts,  but then later we'll get into the images. So I'm going to make a new dictionary,  and I'm going to call this my text posts is equal to, and we're just going to have an empty  dictionary like this. Okay. Now what we're going to do is we're going to make an endpoint,  and we're going to say at app.get. And this is going to be slash posts. Okay.  And for the function, we're going to say define get all posts like that. Now what this is going  to do is just return all of the posts that we have. So we're simply just going to return text posts  like that. Super simple. If we go back here now to this and we refresh, you'll see that we have  why is it still showing that? Okay. Let me just restart my server because for some reason,  sometimes this messes up. So we'll just restart it. Okay. And I don't know what was going on  there. Had some weird issue, but anyways, I got this now back to the docs page. And you can see  we now have slash posts. And if I just try this out and execute, you see it just gives me an empty  response. Okay. That's what we're expecting because currently we don't have any posts. However,  if we put a post in here, then we would be able to retrieve it. So that's good endpoint.  But what I'm going to do now is I'm going to start making some posts. So I'm going to have some  ID like one. Okay. And I'm going to have this associated if I can type properly with some post.  So for my post, I'm going to have another dictionary. I'm going to have title, you know, new post.  And content, you know, cool test post. Okay. And now I want to make an endpoint that allows me to  retrieve one individual post. So first of all, let's just go back. Actually, let's quickly test  and go refresh. Okay. And let's try this out and execute. And you can see that we get the one  post showing up. But maybe I want to be able to kind of filter and get just an individual post.  So I'm going to make a new endpoint. I'm going to say at app dot get and I'm going to type slash  posts slash and then inside of parentheses, I'm going to type what's known as a path parameter.  So this is a dynamic value that we can actually change and adjust in order to get an individual post.  So we're doing ID, right? And then what I'm going to do here is say define get underscore post.  And I'm going to say ID is of type int. Now what this is doing is it's going to directly map  this ID parameter to the ID value that I have inside of this path parameter inside of curly braces  and give it as a parameter to my function. So I can use it inside of here. So now what I can do  is I can say return text post. Okay, dot get and then I can get ID. Okay. So now what I'm able to do  is if I go here and I refresh, we should see that we have another endpoint. You can see it says  get post with an ID. We can pass the ID. So let's pass ID of one and we execute this. It's not  giving us anything. And I see the problem. That is because ID is a string when it should be a number.  So if we change this to a number now and we go refresh and try out go with one and execute.  You can see now that we get the individual post rather than a list of all of the posts.  Okay. So just showing you this is how you create what's called a path parameter. Now if we want  to return an error here, if the post doesn't exist, what I need to do is I need to import this HTTP  exception. Now from this function, I can do something like if ID not in text post, then I can raise  an HTTP exception. I can specify a status code. In this case, something like 404. And I can say  the detail post not found. When I do that, that's going to indicate, okay, we've had a 404 error,  you know, not found, and then post not found. And that's how you can return an error. So now if we  go back here and we refresh and we try to access a post with ID like four or something and execute,  you'll see that it says detail 404 and then it gave us a 404 error code. Okay. So what I just did  quickly is I just had ChatchyBT generate a bunch of test posts because I'm going to use these  throughout the rest of this kind of section here to demo a few more things.  All right. So what we've done is we've added a bunch of text posts. We've added what's called a  path parameter. We had a normal kind of query endpoint here. And the next thing that I want to do  is show you how we can use what's called query parameters inside of our functions. So up until  this point, it's been pretty straightforward, right? We just can call slash post, we can call  or a particular ID, now I want to make it work  so that we can do some kind of more advanced filtering  using query parameters and then we'll continue from there.  So I'm actually going to go inside of this function right here  and I'm going to start adding some optional query parameters  that we can pass to this that will allow us to kind of filter  some of the content.  So query parameter remember is the thing that comes  after the question mark, so something like maybe length equals 10  or something, right, whatever, so that we can actually filter  kind of the number of posts maybe that we're receiving.  So what I'm going to do is I'm going to add a query parameter  called limit, I'm going to say limit colon int is equal to  and by default it's going to be none.  Now what I've just done is I've just specified that I now  have the ability to pass a query parameter called limit  to this post endpoint and I can then check if this query  parameter exists, if it does I can use it,  if it doesn't, I don't have to.  So my idea with the limit parameters that maybe I don't want  to receive all 10 posts, maybe I only want to receive the first  three, well, I can specify that with the limit.  So let me show you how this works.  I can do something like if limit, then what I'm going to do  is say return text post up to the limit.  Okay, now this is not bulletproof because if the limit  is larger than the number of posts that will give us an error,  but for now that's fine, we'll just use that.  And then otherwise we'll just return the text post.  So now if I go back to my page here and I refresh,  you're going to see that if I look at posts,  we have the ability to add this limit query parameter.  So what I can do is go try it out for limit,  I can pass maybe three, for example, and then execute  and what it gave us an error, okay, that's weird.  So the reason we got the error sorry is because we're trying  to apply a list operation on a dictionary.  There's multiple ways we can fix this,  but for now what I'm going to do is just to make it easy  is I'm going to say list of text post dot  and this is going to be values like that.  So we'll just convert the values into a list  and then return them.  So let's go back here and let's go refresh.  And then we'll go here, you could see we have a limit again.  Let's go maybe five and execute.  And now you see we get a list with five items.  If we change this to three, we get only three items.  And if we don't have any limit at all  and we execute, we get all of the items showing up, okay.  So just showing you that's how you add a query parameter.  If you want to do that, you simply specify it  in the parameters here.  You can make it optional, which means  you can have something like is equal to none  or you can make it mandatory by removing this.  And now you have to pass the query parameter.  If you don't, then you could have potentially  get some errors inside of the function.  You can pass multiple parameters like maybe content,  length or something or whatever.  And then you can specify something like int,  can make it string.  The reason why you need to specify the type here  so that it can be auto-documented and validated  by fast API, the way the fast API works  is that it automatically validates all of the data input  that's coming into the function and out of the function for you.  So when I specify that this is an int,  if I try to send something other than an int to this function,  it's actually gonna raise an error for me, okay.  Other than a number.  So this documentation is actually very, very good  inside a fast API and that's why you use  what's called a Python type int inside of the parameters  and you specify like what is the function return,  what does it accept so that it can be really well documented  and it can have what's called this data validation.  Okay, so at this point we've looked at query parameters,  we've looked at path parameters,  we've looked at the get endpoint extensively.  Now I wanna look at the post endpoint and creating new data.  So what I'm gonna do is type app.post  and I'm gonna do slash post, okay.  Now from here what I wanna do is be able to create a post.  So I'm gonna make a function called create underscore post.  What we're gonna take for creating a post  is actually something different than for getting a post.  So like I said in fast API it has automatic data validation  which means it's gonna check the data  that's being sent into the function to make sure it's accurate.  Now up until this point we looked at the query parameters  and the path parameters but there's another way  that we can send data to our API  and it's by using something called the request body, okay.  The body is kind of like more hidden information.  It's not directly inside of the URL.  It's in the field called body.  And the way that we accept that type of data  is by creating something called a schema in fast API.  So what I'm gonna do is I'm gonna make a new file here  and I'm gonna call this schemas.py, okay.  Now inside of here what we're gonna do  is we're gonna define the type of data  that we want to accept in our various endpoints.  So in order to do this we're gonna say imports  or we're gonna say sorry from PyDantic  imports the base model  and we're gonna define a Python class.  So we're gonna say class, post, create, okay.  And this is going to inherit from the base model.  And then we're going to specify in here the fields that we want to accept essentially for a post.  So for a post, we're going to accept a title, and we're going to accept some content, okay?  So title and content for a post.  Now the way that this works is that you inherit from this base model, which is kind of this special object in Python that has some special features.  And what we're able to do now is use this as a type to kind of receive body data inside of our functions.  Again, I know it seems a little bit confusing.  This is referred to as something called a schema, very common inside of fast API to use this.  And it's common that you put it in a separate file called schemas.  So from app.py, we're going to say from app dot schemas import.  And then we're going to import the schema that we just wrote, which is the post create schema.  Okay. Now what we can do is for our create post, we can say post.  So let's do this post colon post create.  Now when we do this, because we're using a pedantic model by default, fast API knows that we're receiving request body, okay?  So not receiving the query parameter, receiving the body.  So now what we can do is we can use this post data directly inside of the function to create a new post.  So we can do something like let's do the following.  Okay, we're going to say text posts and then max of text posts dot keys plus one, because we need to find what the next idea essentially should be.  And then we're going to say is equal to and we're not going to do post dot dick.  What we're going to do is we're going to make a dictionary and we're going to say the title is post dot title.  And the content is post dot content.  Now because in my schema, I've defined that my title is a string and my content is a string fast API will make sure that these are indeed strings before it allows me to call this function.  If they aren't strings, it's actually going to automatically raise an error for me and tell me that I have a bad request, which means when I try to access the title or access the content here, I know that they're going to be valid.  So again, fast API automatically validates the data that comes into the API based on the types that you set, which is extremely useful.  So now we've created this post endpoint, it's just going to create this new post.  But what we really should do is we should return the new post that was created.  So to do that, actually, let's just do this.  We can say post is equal to like this or maybe just new post is equal to this.  And then we can say this is equal to new post and we can return the new post.  So now we have a post endpoint to create a new post.  So what we can do is we can save should automatically reload.  So now if we come here and we go try it out and we change this to like, you know, cool post and new post or something and we go execute.  You can see it gives us the data back.  And then if we go back to post looks like the limit is required this time.  So let's go like 12 and execute and you can see we get the new post and our cool test post is showing up.  Awesome. So all of that is working.  We now know how to accept request body, right?  So this different type of data and to create data.  Now to delete data, it would be pretty straightforward.  You go app.delete and then same thing and you would kind of continue along these lines.  And there's more stuff that you can do related to that.  I'm not going to show that this second.  We'll show it more when we actually get into kind of the finalized project.  All right.  So we're almost going to move on to databases,  but I just want to cover one or two small more things about fast API that you should be aware of.  Now the first is going to be the output type.  So when we created the post here, right?  We're just returning new post.  And if we go back to our kind of documentation here,  let's just go to slash docs and have a look at it.  You'll see that it doesn't show us like what type of data is going to be returned.  Okay.  It gives us kind of an example,  but this isn't exactly what we're looking for.  It's not the best documentation in the world.  So what we can do to enhance the documentation and actually give us some more validation in our code,  which is better is we can specify the type of data that's going to be returned from these functions.  So for example, for my create post,  I can actually put this arrow here,  and I can specify that I'm going to be returning this post create type.  Now that's going to look exactly like this, right?  So it's the same schema that we had here.  Now if we wanted to return something else,  we can do class post return or post response, for example,  can be the same thing, but just so the name makes more sense.  And then we can change this to post response.  And we can import this from here post response.  So now we're indicating, okay,  whatever we're returning from this function is going to be of this type.  Now what this is going to do if I go back to my documentation here,  and I refresh is is now going to indicate to us.  If we look here, the type that's actually  to be returned to us you can see it gives us the value here example value is going to have title  and content being returned on the successful response because we've specified that type.  Now what it also does is it means we can only return data from this function now that is of this  type. If I try to return something else like just a normal dictionary if I were to actually execute  this endpoint it would give me an error and say hey this doesn't match this schema there must be  some kind of problem okay so it adds a layer of protection for us to make sure that we're only  returning what we want to return and actually in fact let me show that to you if I change this  to like an empty dictionary and then I go to my front end and I refresh here and I just go like  try it out and I execute you'll see it actually gives me an error and it says hey you know missing  this data type we're missing title we're missing content which we should have in the response so  we need to go back to new post and then it'll work from now on okay so if we want to type the rest  of our data we can do that as well so for example when we're getting a post we should also say that  this will be the post response and then forgetting all of the posts we're not going to type this one  right now because the response types are actually a little bit different even though it's not intended  anyways you get the idea you can do this okay which is another useful thing to do inside a fast  API and if you wanted to have like a list of posts you do something like list okay and then  post response like that's awesome so now that we have that what I want to do is start connecting  us to databases because right now you'll notice if I refresh this application all of a set of my  data is going to disappear only the data that I have written inside of my code will stay persistent  now that's because right now all of our data is just inside of a dictionary that's stored in  memory so when our code refreshes it all gets cleared and kind of re-initialized with this new  dictionary now that's not ideal so what we're going to start setting up is database connection  so we're going to go to our app folder and we're going to make a new file called db.py now inside of  all of these Python API libraries you typically have something called a ORM and ORM stands for an  object relational mapping and it's something that allows you to prevent writing SQL code or  no SQL queries and instead to write Python like code to be able to define data retrieve data create  etc okay now the ORM that we're going to use here is something called SQL alchemy I believe we  already installed it if we didn't then we can install it again in a second but the point is  this will allow us to really easily work with our data so bear with me here because this is a  little bit of code that we do need to set up not all of it's going to make you know 100% sense  right now but I promise it will later on as we keep going okay so let's start with some of our  imports so the first thing we're going to do is we're going to say from collections.abc  import the async generator we're then going to say import UUID which is something we can  use to generate a unique identifier we're then going to say from SQL alchemy import create engine  we're then going to say from SQL alchemy okay and this is not what I want we're going to say  import the column so let's spell column correctly we're going to import string we're going to import  text date time and foreign key which we'll use later on and I spell foreign correctly no I did not  so let's spell foreign key correctly okay we're then going to say from SQL alchemy okay this is  going to be dot dialects let's spell that correctly dot postgres SQL import UUID we're then going  to say from SQL alchemy dot ext dot async IO import the async session and the async session maker as  well as the create async engine so let's bring in the async underscore session maker again I know  this stuff seems confusing it's just a little bit of setup and then you never need to do it again  and then we're going to bring in from SQL alchemy dot rm import the declarative base but this is  actually going to be a little bit different it's going to be declarative base like that and the  relationship okay now by the way all of this stuff I do not have memorized you don't need to memorize  it it's simply something that we need to be able to set up the database once the database is set  up then it's a lot easier for us to work with this so what we're going to do is we're going to  define a variable and we're going to say the database url is equal to sqlite okay so SQL  lite plus aiosqlite okay colon three slashes dot slash test dot db now what this is going to do  is it's going to allow us to connect to a local database file on our own computer called test  dot db which is in the current directory and sorry this needs to be a plus here so let's fix that  that we want to use sqlite plus aiosqlite which is essentially an asynchronous version of c  will light, which is a really simple database  that we can run locally.  Later, if you wanted to connect to a production database,  you simply need to change this URL to a URL string  for like a remote database or a different type of database,  and then everything in your code would stay exactly the same.  You would just work in a different database.  Now, what we're about to do here  is we're going to define what's called our data models,  and then we're going to create the database,  which will automatically create the data models for us.  Now, essentially the data models  is the type of data that we want to store.  And if you've ever worked with databases before,  you'll know that when you want to store data,  you need to specify the structure of that data,  at least when you're working with a SQL database,  which is what we're doing right here.  So we need to specify like, okay,  what do we want to store for a post, for example?  Well, we need to know the user that posted it.  We have to have an ID.  We want to know maybe the caption of the post,  the URL of the file.  That's the kind of stuff that I'm talking about here, okay?  So what we're going to do is we're going to create  the data model for storing a post.  We're going to make it a little bit more complex now.  And we're going to start working towards actually  being able to store videos and photos for our API.  So what we're going to do is we're going to say class post.  And this is going to inherit from the declarative base.  Now, this is important.  You need to inherit from the declarative base  so that it knows that we are making this a data model.  And this is something that we're going to store  in our database, okay?  Now, we need to specify the table name.  So we're going to say, I'm just going to store a table name.  I'm just going to store a score is equal to post, for example.  And then we're going to start specifying all of the fields  that we want to have or all of the columns  that we want to have in our data model.  So we're going to say ID is equal to column.  And then we're going to say, UUID.  We're going to say, as underscore UUID is equal to true.  We're going to say primary key is equal to true.  And we're going to say the default is UUID.UID4.  And let me just fix the spelling here.  Okay, let me quickly explain what we're doing here.  Essentially, what we're saying is we want to have this ID column.  Now, for every single entity that you have in a database,  you need to have some ID.  Now, the ID is typically what's referred to as the primary key.  The primary key is something that must be unique.  So in this case, every unit that we have needs to be unique.  That's why we've marked it as primary key.  And because we've specified this UUID thing,  what this means is that we're automatically going to generate  a random unique ID for it every time we insert one  into the database.  So every time we create a new post,  a new ID will randomly be generated that is guaranteed  to be unique, which is the primary key  or the way that we will look up this entity.  Okay, now the next thing that we're going to have  is we're going to have a caption.  The caption is going to be some column.  And this is going to be text.  Now, you'll notice that the way that we specify the data  that we want to have is we say, okay,  we're going to have some name, some field name,  so a caption ID, we say it's going to be a column  if we're storing data, if we're storing a relationship,  we would set it to a relationship  or a foreign key or something different.  And then you specify what you want in that column.  In this case, I want to store text, right?  So I say, okay, caption, it's going to be text.  Then I'm going to have a URL.  This is going to be the URL for the,  what do you call it, photo or video.  And this is going to be column of string.  And we're going to say, no,able is equal to false,  which means this can't be, no, it has to have a value.  We're then going to say the file type  is equal to column.  Same thing, string, no,able is false.  We're then going to have the file underscore name.  It'll be the exact same thing.  So string, no,able equals false.  We'll then have a created at and we'll say column, date time.  And rather than no,able, we're just going to say default  is equal to date time dot UTC now.  And then we're going to import date time.  So we're going to import date time like that.  Not now, import date time like that.  And now this should work.  So that's all that we need for the post.  Later, we will adjust the slightly to link it  to an individual user.  But for now, because we don't have users in our app,  we're just going to have kind of a simple post.  So the way that this will work now  is that whenever we want to create a post,  we'll need to pass a caption, URL, file type,  file name and created at.  Or actually create that will be automatically created for us.  And then we'll be able to make this new post  and store it in our database.  If we had other data models, we would define them inside of here  or in other files and import them inside.  But for now, this is how we're going to do it.  So next, we need to actually create the database.  So we're going to say our engine is equal to this  create async engine with database URL.  We're then going to say the async underscore session  underscore maker is equal to the async session maker.  And we're going to pass our engine.  And then we're going to say expire on commit is equal to false.  Don't worry too much about that.  Essentially, what we need to do right now  is we need to create this database engine,  which can look at all of these models  and automatically create the database for us.  We're then going to say async define create db underscore  and underscore tables.  With this.  going to do is create the database for us as well as create the tables. So we're going  to say async with engine dot begin. Okay, and then this is going to be as connection.  And what we're going to do is say a wait, con the connection. So dot run underscore sink.  And then we are going to say the declarative base, okay, dot metadata, dot create all.  Now what this is going to do is it's going to find all of the classes that inherit from  the declarative base. And it's going to create them inside of the database. That's all  that it's doing. We're then going to have another function. We're going to say async  define gets underscore async underscore session. Okay, this is going to return an async generator  with an async session and none. And then we're going to say async with, and I know this  is confusing bear with me. We're going to say the async session maker as session. And we're  going to yield the session. Okay, again, bear with me. This is actually almost done at this  point. What we're doing is we're creating all the databases and the tables, right? What  this does is it starts a database engine and then it creates all the tables and creates  the database. Then we have this get async session. What this is going to do is it is going  to get a session, which will allow us to actually access the database and write and read from  it asynchronously. Okay, so we're doing this using async. If you don't understand async  and Python, don't worry too much about it. I will explain the kind of important stuff  later. So that's all we need from this particular file. Later, we will add a few other things  to store our users for the application. But for now, this is fine. Okay, so there we go.  We've now ridden the database stuff. What we're going to do now is we're going to go into our  app.py file and we're going to start importing some of the things that we need so we can actually  use the database. So we're going to say from app.db import the post, the create db and tables  and the get async session. Okay, now what we need to do is we need to set something up so  that as soon as the application runs, we create the database automatically if it's not already  created. Now in order to do that, again, this is going to look a little bit complex. Don't worry,  just set up once and then you're good. We're going to say from SQL alchemy.exd.async.io and then  we're going to import the async session. Then we also need to import something called the async  context manager. So we're going to say from context lib, this is built into Python, import the async  context manager. We're then going to say at async context manager and we're going to say async  define lifespan. We're going to take in our app, which is an instance of fast API. And what we're  going to do is we're going to say, wait, and we're going to say create db and tables and then we're  going to yield. Don't worry too much about this. It's kind of advanced Python syntax. You don't  really need to understand. And then all we're going to do here is when we say app is equal to fast  API, we're going to say lifespan is equal to lifespan. What this is going to do is it's going to  automatically run this function as soon as the app is started. It's going to create the database  and the tables for us and just make sure that this is essentially handled correctly and cleanly  exit once the when sorry, the application stops. Now these other imports we'll use later on for  now. We'll just leave them in. Okay. So now if we just want to do kind of a sample test here,  we can shut down our server and rerun it. And it should automatically create the database for us.  However, it's giving me an issue saying datetime.utc isn't a function. Let me quickly fix that. So  we're going to have to actually change this to say from day time import day time. So just change  that import here in the DB file. And now if you come back here and we shut this down and we restart  and we got another error, let me quickly fix that. Okay. So another silly error here,  we're going to go inside of our DB.py file. What we're going to do quickly is say class base.  And this is going to inherit from the declarative base. And then we're just going to say pass.  And we're just going to change all instances of declarative base down here to say base.  Kind of a silly error again, a little bit complex. And then same thing when we go here,  just change this to say base. And that should fix the problem for us. Essentially we just cannot  directly inherit from declarative base. We need to do this kind of other base class first a little  bit weird, but that will allow us to set up the database. I know the database setup seems a little  bit confusing, but once it's set up again, you don't need to change it. So let me just shut this  down and then restart it. Okay. So the server is running. We didn't get any errors. And the way we  can test if this is working is if this test.db file was created. It looks like it was for me,  which means the database connection is set. And now we don't really need to touch much in this  database file. And we can just start using the database to actually create new posts. So in  fact, let's start doing that. Let's actually scrap pretty much everything that we have so far.  I know it seems like why do we get rid of it? But trust me, we're just going to write this in  a better way now. And what we're going to do is we're going to start writing the endpoints for  uploading or creating a new post and doing the image and video upload. So as I mentioned,  we're going to start doing the file.  Upload now to do that we're going to have to import a few more things and again just bear with me  I'm going to explain it step by step as we go through that and then we'll start adding the users a bunch of other stuff as well  So what we're going to do is from our fast API import at the top actually we're going to import file  We're going to import upload file  the  What is it form  And the depends  Okay, now we're going to make a new endpoint  I'm going to say at app dot and this is going to be post because we're going to be uploading a file  And this is going to be slash upload now this is going to be to essentially make a new post  So when we make a new post we're going to upload either a video or a photo  And then some caption for that video or photo and then it will be posted  So in order to do this we're going to say async define  upload file  We're using async because we're going to have some async operations in here where we essentially wait for something to occur  Fast API is asynchronous by default so you can always use the async keyword for these functions  Now what we're going to do is we're going to say file and this is going to be upload file is equal to file with three dots inside  What this means is that we're going to be able to receive a file object to this endpoint, okay?  We're then going to say the caption is a string which is equal to some form data  So rather than actually just accepting a request body we're going to accept something called the request form  There's different types of data you can send to the endpoint  For example, you can send a file you can send a form you can send a request body you can send query parameters  This is just another type so we're going to accept the caption from some form data, okay?  We're then going to say our session is an async session  Which is equal to depends and this is going to be get async session  Now this is going to look a little bit weird, but in fast API we have something called dependency injection  This is essentially a dependency injection  It'll light up in a second here when we start using it where what's going to happen is we're automatically going to get the asynchronous session  By calling this function and pass it as the variable session inside of this function  This is how it works when you want to essentially trigger another function to run as a dependency for this function  So we're saying we want to get the asynchronous session sorry for our database  So we can use the database inside of this function in order to use it in this function  That's how you do it you write this kind of dependency injection where you say this function depends on this right here  It will run the function it will get the database object  It will pass it to us and then we'll be able to use it directly inside of here  Okay, so now inside of here what we're going to do is we're going to take the file and we're going to upload it  That's going to take us a second to be able to do because we need to use image kit  So before I do that, I'm going to show you how we can create a new post with some kind of fake post data  And then how we can do actually the upload for that  So to make a new post we can say post is equal  To post and we can specify things like the caption  Is equal to the caption  We can say the URL is equal to  You know dummy URL and later we'll fill that in  We can say the file what is this file underscore type  Is equal to for now we can just go photo then we can do a comma and we can say the file underscore name is equal to dummy  Name okay, so let's go dummy URL dummy name  Again, there's a few other things we can add later, but for now this is fine  Now in order for us to actually add this to the database the way that we do that is we say session  dot add  Okay, and we simply add this post here that we created then we say a wait  session  Don't commit so the way that you add something is you create a new post or create a new object of whatever it is that you want to create  You add this to the database session and then you commit the session  It's important that you commit this  Because committing it will actually save it adding it to the session is like staging it saying hey  This is ready to be added, but it won't actually fully be written into the database unless you commit the session  Now another thing you can do after this is you can say a wait  session dot refresh  And you can refresh a particular object and what this will do now is it will go and look in the database and  Populate any entries here that were automatically created when it was added to the database  So for example  We have this created at and this ID when we specify the post we didn't specify an ID or a created at  That gets automatically created when we commit this in the session  So when we refresh the post it essentially gets hydrated with that extra data where we now get the ID  And the created at as a part of this post which we can now return to our user  So what we can do here  is we can just say return, and then we can return the post.  We don't need to do that, but we can if we want, right?  So we can say return post, and then we will get that data.  So we can test this, but before we're going to know  if it was actually added to the database,  we need to write an endpoint that's  going to allow us to view the different posts.  So we're going to say app, jot, get,  and we're going to call this the feed.  So we're going to say slash feed.  We're then going to say async, define, get, underscore, feed.  And what we're going to do here is we're going to say the session.  This is an async session is equal to depends on get async session.  Now the reason we're doing that is because we  need to access the database here in order  to get all of our posts.  So we need to bring this in as the dependency injection.  Now quickly, I do need to import something.  So I'm going to say from sql alchemy import select,  because this is going to allow us to select different posts.  So now what we're going to do is we're going to say result  is equal to a wait session.  This is our database.execute.  OK, and this is how you can execute a query.  And we're going to say select.  And we want to select on the post, what do you call it, object,  or post kind of table.  And we want to say order underscore by.  And we're going to say post dot, OK, like this created underscore at dot descending.  OK, so querying here is a little bit weird.  But what we're able to do is say, OK, I want to select  posts, right?  So I want to start looking through posts.  And then you can add these various filters,  like I want to order it by all of the posts that are created at and the descending.  So I want to go in the order in which they were created.  Then I can also do something like dot filter, right?  Or like all these other things.  And you can filter by specific criteria.  I'm not going to go through all of it.  But essentially, if you just look up like SQL alchemy, fast API online,  you'll see all of the different ways that you can query different data.  If you want to just get all of the posts, and you don't care about doing any kind  of filtering, you can just say, select post, that will give all of them to you, OK?  And then if you want to check various fields or relationships, you can do that.  We'll look at that a little bit later on.  OK, so now we have our result.  This is going to be all of our posts.  Now what we're going to do is say post is equal to, and we're just going to go row,  OK, zero, four row in result dot all.  Now what the result dot all is going to do is just give us all of the results  from this particular query.  The reason why we're doing this is because I want to convert this into a list.  Essentially, we need to step through all of the results and take them and pass them  into this in order for us to actually access them all at once.  It's due to the way that fast API returns the results here, returns it in what's  called a cursor object, where you're stepping through the database.  So what I'm doing is I'm looping through all of the values,  and then just pulling them into individual values that I store inside of here.  OK, then what I'm going to do is I'm going to say my posts underscore data is equal  to a list, and I'm going to say four posts in posts, and I'm going to start creating  kind of a more comprehensive post object that I can return to my front end.  That's going to include some data that we need about our posts.  So we're going to say post data dot append, OK, and then inside of here,  we're going to have an object for the object.  We're going to say ID is equal to a string of the post dot ID.  So I'm going to convert it from a UUID object to a string.  I'm then going to say the caption is the post dot caption.  I'm going to say the URL if we can spell this correctly is the post dot URL.  I'm going to say the file underscore type is the post dot file type.  And then I'm going to say the file underscore name is the post file name.  And I'm going to say created at is the post dot created at dot ISO format,  which is going to give me a timestamp in a format I can actually read.  Then I'm simply going to go down here and I'm going to say return posts.  And I'm just going to return all of my post data.  OK, and that should be post data like that.  So that is going to complete this kind of get feed function,  which will give me all of my posts.  This should allow me to create a post when I upload a file.  Again, for now the file we haven't specified, but we'll do that in a second.  So now let's give it a test and see if this works.  So let's rerun our back end.  I'm just going to shut this down and restart it.  Let's go here.  Let's fresh.  We see we have an upload and see it's this multi part form data.  So I'm going to try it out and now it allows me to choose a file.  So let me pick some file here.  OK, so I just uploaded some files, some pay slips from while ago.  Let's go caption hello world and let's execute.  And let's see what we get and it gives us the response body.  OK, photo, dummy URL, date, hello world and the ID.  So now if we want to see if it's actually in the feed,  what we can do is go to get feed, try it out and execute and you can see.  We get the post, I think I pressed this twice, so we get two posts showing up here,  but it's reading those from the database.  And the important thing is that if I were to shut this application down and restart it,  these would still be in the database because, well, they're here persistently, right?  And they're stored in this file.  If we wanted to delete them, we can just delete this database.  Okay, so now we have the ability to upload or create a new post and to kind of view the post.  Now we need to start actually handling the image and video upload.  And to do that, we're going to use image kit.  So what we're going to do is make a new file here.  And we're going to call this image kit or not image kit images dot PY.  Okay, so from here, we're going to go images dot PY and we're going to start importing a few things.  We're going to say from dot ENV import low dot ENV.  We're going to say from image kit, okay, I owe import, if we can spell this image  get. And remember, we imported this or installed this at the beginning.  We're going to import OS and then we're just going to call this load dot ENV function.  We're then going to say image kit is equal to image kit.  And we are going to essentially specify all of the variables that we defined here in our dot ENV file.  So to do this, we're actually just going to use this autocomplete.  We're going to say our private key is equal to OS dot get ENV image kit private key, public key, OS dot got  get ENV public key URL endpoint OS dot got ENV image kit URL endpoint.  Okay, so the same variables that we have here and actually let's just make sure they're spelled correctly  because this one is a little bit different.  So let's fix this to just be image kits.  You are L. Okay, now what are we doing here?  Well, this load dot ENV function will look for the presence of this dot ENV variable and  essentially load it for us.  Okay, so we'll load these values in so we can now access them now to access those variables.  So we use this OS dot got get ENV function, which will be able to find the presence of these  environment variables and load them into our code.  Very important that we're doing this on the back end, not on the front end.  And I want to explain to you how we now kind of upload content using image kit,  which which, which is what we're about to do.  So let's go into app.py and let's import image kits so that we can start using it.  So what we're going to do is say from app dot images, import, and we're going to import image kit.  And then we're going to say from, and this is going to be image kits, I O dot models,  dot upload file request options, import the upload file request options,  because we're going to use this in a second to specify how we upload the file.  Now, before I start to kind of diving into the code here, I want to go to the image kit  documentation and start kind of explaining to you how this works.  All right, so if you remember at the beginning of the video, we would have created an image kit  account. The account looks something like this where you have this dashboard.  Now, image kit can automatically host all of the images for us.  And it can handle uploading, deleting them, cropping them, modifying them,  and more importantly, just being our storage.  So we don't need to worry about storing images and videos, which can be a huge  paint. Now, you do have the ability with image kit to connect this to external storage.  So for example, if you go to external storage here, you can add a new one and you can connect,  it's like an S3 bucket if you're familiar with what that is or other locations where you can  essentially have image kit managing this external bucket.  You don't need to do that, but you can.  In our case, we're going to use image kit as our dam.  So it's automatically going to handle all of the asset management for us.  Eventually, when we start uploading stuff, we'll see in our media library,  that it will show up here. We'll be able to click into the various files.  We can view them here. We can view the information.  We can edit the tags, get embeds, URLs, all of this kind of stuff.  Just makes it very easy to manage the images.  Now, in terms of using image kit, what we can do is use a single API, funny enough,  we're building API, and we're going to use an image kit API to upload the images.  Once the images are uploaded, we can then just change some query parameters in the URL for the image,  and we can specify the width, the height.  If we want to add text on top of it, if we want it black or white, if we want to crop it,  whatever, as you can see, it's showing you right here, which makes this extremely useful.  It also has performance optimization, a lot of other features, but let's go into the docs.  So I'm going to go docs like this.  Let's go to the Python documentation.  You can see it supports a ton of different frameworks.  I'm going to explain to you how we upload it.  Now, you can use this with a lot, as you can see, JavaScript, react,  Angular, all of this kind of stuff.  In our case, we're doing this from Python.  And so because we're doing that, we imported or we installed the image kit IO library,  and then we initialized it like this.  Now, we're going to be doing what's called a back end or server upload.  So essentially, the user is going to send some image to our back end,  and then our back end is going to upload this to image kit.  Now, it's important that we do it this way so that we can securely control what images we upload,  or which  once we don't, and have them stored on our server,  whereas if you were to upload this directly from a front end  or a client's like a JavaScript application or something,  that's not as secure, OK?  And you don't have as much control  because you're essentially exposing different tokens  for ImageKit on your front end, which you may not want to do.  So it shows us right here some kind of code snippets  of how you can do the upload.  You have some URL to an ImageArcase.  It's going to be some data, which I'll show you.  And we can do ImageKit.uploadFile,  pass the different piece of information,  and then it just gets uploaded.  It's going to return to us, essentially, an object  that looks like this, where we have the URL for the image,  the name, tags, all of this kind of stuff,  that we can then use and store.  OK?  And then if we want to generate URL, we can do something like this.  Again, we're not going to talk too much about everything here,  but that's kind of how we do the upload.  Hopefully, this makes a little bit of sense,  but the point is user will send a file to our API.  Our API will then upload its ImageKit.  We'll grab the URL, save that in our database,  and then serve that to our user on the front end.  So we're going to go in.  We're going to import a few other things  that we're going to need to perform this upload.  So what I'm going to do is I'm going to say,  import SHUTIL.  I'm going to import OS.  I'm going to import UUID, and I'm going to import temp file.  Now, the process is going to be that when the user sends us  this file, we're going to create a temporary file,  which is a copy of this file, where then going to upload  that copy, and then essentially remove or delete that copy  from the machine, because we'll no longer need it.  So what we're going to do is create a variable,  and we're going to say, our temp file path is equal to none.  We're then going to say, in a tri-block with temp file,  dot named temporary file, we're going to say delete  is equal to false, and we're going to say the suffix is equal  to OS.path.splitText.  And we're going to say this is going to be file.fileName,  and then this is going to be at index1.  OK, this is a little bit weird.  Again, just bear with me here.  We're going to say this is as temp file,  and we're going to say this is as temp file.  What this is going to do is essentially  make a named temporary file that ends in whatever the file name  is that was uploaded here.  Then inside of here, since we have this temporary file,  we're going to say the temp file path is equal  to the temp file.name, and we're going to say shutil.copy.fileObject.  And this is going to be file.file, and then the temporary file.  And let me just correct myself here.  What we're doing is when we create this temporary file object,  we're using or having the end of the temporary file  have the same extension as the file that was uploaded here.  So if they upload a JPEG, for example,  we create a temporary JPEG.  If they upload a mp4, we create a temporary mp4, OK?  So what we do is we create the temporary file.  We then copy the contents of this file into the temporary file,  and then that kind of completes this with statement.  Then we're going to start doing the uploads.  We're going to say our upload result  is equal to imagekit.uploadUnderscoreFile.  What we're going to do is we're going to say file is equal to,  and we're going to open the temporary file path in this RB mode,  which stands for read bytes.  We're then going to say our file name is equal to file.filename.  And we're going to say the options is equal to,  and this is going to be the upload file request options.  And in here, we're going to say use underscore unique file name.  This is going to be equal to true.  And we're going to say the tags is equal to,  and inside of a list, we're going to say back end upload.  So we know that we uploaded this from our API.  Now, this is all we need.  That's literally how easy it is to use imagekit.  We just write this one line where we essentially open the file.  We upload it to imagekit.  And then it's going to give us a result that contains all  of the metadata that we need.  So we're going to say if upload result dot,  this is going to be response dot HTTP underscore status underscore code  is equal to 200.  That means that this was successful.  Then what we're going to do is all of this,  where we essentially create the post, OK?  Now, we just need to structure this a little bit better  because it's a bit difficult to read.  But we have this tri-block, right?  So I'm just going to put an accept block here.  So we're going to say accept exception as e.  And then we can put a pass right here for now.  And then we're going to say finally.  And in the finally block, we're just  going to make sure we clean up the temporary file.  So we're going to say if temp file path, OK?  Or, or sorry, not or, and os dot path dot exists, the temp file path.  Then we're just going to say OS.  dot unlink, and we're going to unlink the temporary file path, and then we're going to say file.file.file.close.  Okay, so this is just going to clean up our file objects. So at the end of this function, we're all good and everything's cleaned up.  Okay, and then for the exception, let's just quickly handle this. We're just going to say raise, HTTP exception, status code 500,  and we'll just put whatever the string error was so they were able to have a look at it.  Okay, so now at least the tri accept block is done, and we just need to handle this part.  So what we're saying is, all right, you know, we've now created the temporary file. We've uploaded it.  We're going to check the response, and we're going to make sure that this was successful.  Now, if it was successful, what we're going to do is we're going to create this post.  But for the URL this time, we're going to change it to be the upload result dot URL.  For the file type, we're going to say this is video if file.content underscore type dot starts with video slash  otherwise we're going to put the type as image. And for the file name, this is simply going to be the upload result.  Okay, dot, and this is name.  So now we're actually using the content from image kit, and we'll actually will have the URL for the image.  Hopefully that makes sense, but that's pretty much what we need to do for the upload.  And I think that should actually be good.  So what we'll do now is let's bring open our terminal again.  Let's just restart this, and let's go back here, and let's test this from our docs.  Okay, so let's go upload. All right, we're going to go try it out.  We're going to put a file. So we need to upload an image.  So let me just upload one of these images here. Let's go hello world, and let's send this.  And it says module nt path has no attribute split text.  Okay, so I need to remove one of the teas here. So it's split text in one word.  So that was my problem there. Let's go back and refresh and just try this again.  So we're going to go try it out.  Upload again, just upload an image or a video needs to be some media.  Say hello, and then execute this.  It's going to take a second because it does need to do the upload.  And then we got some issues saying, none time object has no attribute HTTP status code.  So we probably just spelled something wrong.  So let's go here and fix this.  Yeah, so we have upload result. This needs to be dot response underscore meta data.  Okay, so let's spell meta data correctly.  And now let's test it again.  Apologies guys, this is just a part of programming.  Refresh.  Try it out.  Choose a file again, some media.  Okay.  Hello world.  And let's see.  And here we go, we get the response body.  And now what I want to check is the URL.  So it has a URL here. So let's copy this.  And let's paste this in our browser.  And we should see that we get the image now and it is uploaded.  And importantly, if we go to the media library,  we should be able to refresh here.  And we should see that now the images appear happening twice because we uploaded it twice,  even though we got an error the last time.  And you can see this shows up.  And by the way, this is Kenny, one of my co-founders from DevLaunch  and someone that we were filming a testimonial video with.  Anyways, that's kind of the random image that you guys are seeing.  Okay, so it's working.  We can see it's uploaded here in ImageKit.  It's working now from the back end.  What I want to do next now is test out this feed endpoint.  And see if this gives me all of the content.  So it's execute.  And you can see there we go.  So we have this new post, right?  We have the ImageKit URL.  And now I just want to talk about kind of the advantage of using ImageKit.  And what we can do with these URLs that is super cool,  which I'm going to show you in one second.  So I'm going to grab one of these URLs, which I would recommend that you do.  I'm going to show you how we can modify it.  Sorry, but literally just changing some parameters in this URL.  Okay, so I have the URL in this one tab here.  And then I also just pulled up the ImageKit documentation.  And what you're able to see, let me just make this a little bit bigger,  is that we can have these transformation parameters directly in the URL  to modify the image.  So notice I have, you know, ImageKit demo.  And then we can do these transformations of like the width and the height directly on this URL.  Let me show you, and then I'm going to show you a bunch of other ones that we can do.  So what we do is we go in between the file name  and the, what do you call it, project ID for ImageKit.  And we just put this in directly.  And when we do that, you see that I just modified the width and the height directly by cropping it,  by literally just putting those parameters.  If I put like 500, see now that it goes up.  If I put width of like, I don't know what is this 700,  see now we get an image that looks a little bit more complete, right?  And we can just add it directly like that.  Now we also can pass this as a query parameter if that's easier for us to do.  And you can see it shows some examples of kind of resizing the image.  Now if we go here to ImageTransformation,  you'll see there's just so many that we can do here.  Right, like we have an AI transformation,  which is currently in beta, which is kind of cool.  We can add overlays directly on top of the image.  So we can have like some local image  we wanna put on top of this image and directly embed it.  We can do effects and enhancements, or enhancements  so we can have like E contrast.  So let's actually copy this and see if we can get it.  So we'll do TR and then H-300 E contrast, okay?  And make sure there's no space.  And then if we run that, you can see  that it gives us some more contrast.  We can sharpen it.  So if we wanna pass E sharpen, let's change that to E-dash.  Sharpen, and you can see it now sharpens the image a little bit.  It's a little bit difficult to see  probably with my screen recording software,  but it is doing that.  And then we have video transformations.  These are cool because we can have, for example,  like thumbnails for videos.  So if we upload a video, we can try to get a thumbnail  from a specific portion of it.  But for example, we can use this IK thumbnail.jpg.  If we just put that at the end of the path,  it'll just give us the first frame as a thumbnail.  We can get a thumbnail from a specific time five.  So we're doing like five seconds in.  That's how we're getting the thumbnail.  We can do transformations on the thumbnails.  We can trim the videos.  We only get a certain amount of length from it.  And then of course, the most important thing  in my opinion is the optimization.  So you can do image optimization.  So you can automatically compress the images  without losing quality and load them significantly faster.  You also can do video optimization.  And there's like so many different things.  So if you do care a lot about image and video,  definitely check out these docs  that I will leave in the description.  And one with video specifically  is like changing the quality of the videos.  So you're not loading massive 4K videos or something.  And even if you said it's like 90% of the quality,  it's three times smaller, which is significant.  So anyways, that's the images they are working.  Now I want to continue with the API.  So we have the ability to kind of get a feed  to what do you call it, upload a file.  Now let's write the ability to delete a post.  And then what I want to do is move on and talk about  authentication.  So we actually have different users kind of signing in.  And only the user who made a post can delete a post.  And like you need to be signed in to be able to make a post,  that's pretty important, right?  So let's make another endpoint here.  Let's call this app.delete.  For deleting, we're going to take in slash posts.  And this is going to be a path parameter  of our post underscore ID.  What we're then going to do is say,  async define delete underscore post.  We're then going to say post underscore ID.  And this is going to be a string.  We're then going to say the session is async session  and that depends on the get async session.  We're then going to have a try for the try.  We're going to say the post underscore UUID  is equal to UUID.UUID.  And then this is going to be the post underscore ID.  We're then going to say result is equal to await session.execu  and we're going to say select post dot where, okay?  And we're going to say where the post dot ID  is equal equal, just two equals,  to the post underscore UUID.  Now, the reason why we need to convert the post ID  to a UUID is because this will be a string by default.  And we needed to be this UUID objects  when we do the comparison they match, okay?  So then after this, we're going to say the post  is equal to result.  Now we're going to say dot scalers, okay,  with a set of parentheses and then dot first.  What this is going to do is just return the exact result  rather than giving us this kind of object  that we need to loop through.  So that's what scalers does,  even though I know it sounds a little bit confusing.  We're going to say if we do not have any post,  then we're going to raise an HTTP exception  and we're going to say the post is not found  with status code 404, okay?  And then otherwise what we're going to do  is just delete the post.  We're going to say, wait session dot delete post.  And then we're going to say, wait session dot commit  like that.  And when we commit this, it will delete the post.  We're then going to return  and we'll just say success is true.  And then we can have some message  like post delete is successfully.  And then we're just going to have an accept  in case there's an error.  So we'll say accept exception as e.  And then what we're going to do is just raise  an HTTP exception saying, hey, there's some error.  This is the error, okay?  And that should be all that we need to do  for deleting a post.  So we can save that and let's now give it a test.  So let's go to here, let's grab a post ID.  So maybe one of these old ones and let's refresh.  And let's go to post, let's pass in the post ID  and execute this and it said,  404 post not found.  Okay, so that's maybe an issue.  Let's go feed and let's try to get the post.  And okay, it looks like it did delete that post  maybe because it said 404 but then it deleted it.  So.  Let's copy this, let's paste the other one,  and let's do it, and there we go.  Okay, now it's a success-true post deleted successfully.  Okay, so that looks like it's working,  and then if we go back to the feed,  we can execute it,  and now we only have one post inside of here,  which is a valid post.  Cool, so deleting is working,  upload is working, getting is working.  Now what I wanna do is I wanna start handling  the user authentication.  This is all great, but it only kind of matters  if we can like sign in,  and for example, if I make a post,  you shouldn't be able to delete it, right?  We have to have kind of rules and authentication,  and that kind of flow for our endpoint.  So let's go ahead and start doing that.  To do that, I'm gonna go over to app.py.  I'm gonna make a new file, call this users.py.  Now this is where we're quickly gonna talk about JWT tokens.  Let me hop over to the kind of, I don't know,  whiteboard and explain that to you.  Okay, so we're gonna talk about authentication, right?  This is arguably the most complicated part  of most web applications, and for this app,  we're gonna use something called JWT tokens,  or JWT auth.  JWT stands for JSON web tokens.  They are a very common format for web authentication,  and the way that they work is that they essentially  validate or authenticate a user by the user,  including this token, in all of the requests  that they send to the server.  So this little diagram that I have for you explains it,  let's go through it.  So essentially the way this works is you have some user.  Let's call it Sally, right?  And she logs into the application.  Now before she can log in, she needs to make an account,  but to make an account, you don't need to do anything fancy.  So let's imagine, no, she makes some account,  she has some credentials, okay?  Now she signs into the server.  The way that she does that is she goes from her computer,  so she's on some website, and she sends her login details  to this auth endpoint.  So maybe that's her username and her password, right?  Now this is our API, our kind of our server,  and what it does is it checks the user credentials,  and it says, okay, are these valid or are they invalid?  They should be valid.  So when they're valid, what's gonna happen is  it's gonna generate a signed JWT token.  Now this is a special token that just looks like  a random string of characters that essentially identifies Sally.  It tells us, okay, this token belongs to Sally.  So if I see this token, it means that Sally  is the one who sent this request.  That's effectively what that means.  Sally signs in, she then gets some token back,  and this token is Sally's token.  Anyone that has this token is Sally in the eyes of our API, okay?  So what Sally does is she now stores this token,  or really her computer stores it in the browser,  she's not gonna do it manually,  and now for the rest of all of the requests  that she uses with our API, she sends this token  along with the request.  So she has the request, plus this JWT token,  we verify the token is correct, and then we say,  okay, who is this?  Oh, it's Sally, okay great, so it's Sally,  so we can now go do this thing  because Sally's allowed to do that thing.  That's essentially how this works.  This is an oversimplified explanation.  The point is user signs in, they get some token,  they store this token, they then send that with every request  as they kind of hit our API and start interacting with it,  and that identifies them to us as that user,  and there you go, right, that's how it works.  Okay, so that's what we're gonna implement.  Now to do that, we're gonna use something  called fast API users, which is a module that we installed  that just makes this process a lot easier.  So in our user's file, we're gonna say import UUID.  We're then gonna say from typing, import optional,  and we have a lot of other stuff to import as well.  We're gonna say from fast API, import depends and request,  and then what we're gonna do is say from fast API,  underscore users, import the base user manager,  the fast API users, and the UUID mix in as well as models.  Okay, now this is giving us an error  because I need to make this fast API users plural,  and now we're good.  Then we're gonna say from fast underscore API,  or fast API underscore users.authentication,  okay, and we're gonna import the authentication backend.  If we can spell this correctly,  we're also gonna import the bearer transport  as well as the JWT strategy.  Now with this, you can use various types of token strategies.  In this case, we're gonna use JWT.  Don't worry, there's some other ones as well,  but we're not gonna look at those right now.  We're then gonna say from fast API underscore users.database,  import the SQL alchemy user database,  and we're gonna say from app.db, import user,  and get userdb, which are two functions that we're gonna,  go and write now, okay. So because we're now going to have users in our app, we are going  to have to make some changes. We're going to go to database.py and we're going to start  writing a user model that we can essentially use to store users, okay. So to do this,  we're going to say from fast API underscore users dot dv import the SQL alchemy and this  is user database, also going to import the SQL alchemy user table you you ID. Okay. This  is complicated. That sounds crazy long, but these are just what we need to import. And  then what we're going to do is beneath the base, we're going to say class user. And this  is going to inherit from the SQL alchemy base user table you ID and base. We're then  going to say relationship, okay. And this is going to be post. And then we're going to  say this back populates the user. Essentially what we're doing here is we're creating this  table, this user table so that we can have a relationship between our posts and between  our users. We want to know what post was created by what user and what posts exist for what  user. So we're going to say posts is equal to this. And now on this user, we'll be able  to find all of their posts. Okay. So that's what we're saying back populates user. So  what I'm going to do now on this post database model is I'm going to create the relationship  content to the user. So that from a post, we know what user posted it or what user created  it. And from a user, we know what post that they have. So on my post, I'm going to do this.  I'm going to say my user ID is equal to column. And then this is going to be what if we  want here UUID, we're going to say as UUID is true, we're going to say foreign key. And  this is going to be user dot ID. And we're going to say nullable equal to false. Okay. Now  a foreign key is essentially a reference to another table. So in our case, what we're  saying is for this post, we want to have a foreign key, which references the ID of a user.  That's what we're doing. So we know the user ID that posted this post that made this post.  Now as well as that, we're going to create a relationship. And we're going to say user  is equal to relationship. And then we're going to have user and we're going to say back  populates posts. Now these relationships automatically link these objects together and allow  us to use the dot posts and the dot user attribute on both posts and user. And the foreign  key allows us to have this link so that we know the user's ID. Now what we've created  here is what's known as a one to many relationship, where one user can have many posts.  There's different types of relationships that we can define in our database models. This  is not a SQL course. So I'm not going to get into that, you know, two in depth, but  the relationships to be aware of are one to many, many to one and one to one. Most frequently  you are using one to many, which means you have one user with many potential posts, right?  Now if we wanted to flip the relationship around where one post had many users, for example,  we would simply change the foreign key to exist on the user table rather than on the post  table. So typically the child, so in this case, like one user has many posts to the post  would be considered a kind of a child of the user in terms of the relationship hierarchy  is the one that contains the foreign key. Again, this is something you need to look at  more if you're designing databases. And again, this is not a SQL course. The point is  we need to make this relationship. So now users are linked to posts. Now that we have  that, we've created the user. It's inheriting from base as well as from SQL alchemy.  We can go back to users and we can start using this and actually, sorry, there's one more  function. I forgot I need to write here. So let's go down to the bottom and we're going  to say async define gets underscore user underscore DB. We're going to say session. And this  is going to be the async session equals depends. Okay, let's pull depends correctly.  And depends is a capital, of course, we're going to say depends on get async session.  And then what we're going to do here is we're going to say yield SQL alchemy user database  session and user. Now why is this giving me an error? I guess I didn't import it. So  let's go from fast API. So from fast API import depends with a capital D. And I think  that should be good now. Essentially, what we're doing is just writing a function that's  going to get us the user database table. So that's effectively what this is doing. Again,  don't worry too much better. The database stuff is a little bit confusing. The point is it  will just give us the database table. This associated with the users, which we're going to have  to use here now inside of this users.py file. Okay, so from here, we're going to create  some variable called secret. This should be equal to some random string. You can actually  generate this with a specific function on your computer. Point is you don't want to share  this secret string.  because this is actually what's used to sign your JWT tokens,  which identifies them as unique to this particular app.  If someone were to have access to the secret key,  they would be able to decode your JWT tokens,  which you don't want.  So this is something that you want to keep secret,  hence the name secret.  In my case, I'm just making it something random.  So now what I'm going to do is I'm going to say class, user manager.  And this is going to be UUID, ID, mix in.  So we're going to inherit from that.  We're also going to inherit from the base,  user manager.  And then we're going to have the user and the UUID.UID.  OK, again, I know some of the stuff seems confusing.  This is directly out of the Fast API users documentation.  You just set up one time, and then you're good to go.  You don't need to memorize it just bear with me.  So now what we're going to do is we're going to have  the reset password token secret and the verification token secret,  both being equal to the same thing, which is a secret.  Can make it different if you want, but that's all that we need.  Now, we actually don't need to do anything else inside of this class,  but I just want to show you that we can write various functions here  so that we can handle things that happen when a user registers,  when they forget their password, or when they are requesting  to, for example, verify their token.  So what you can do is you can hook into all of these common user operations  that are going to automatically be written for you by Fast API users.  So we can do something like async, define.  And then you can see there's a function like on after register.  And this is a function that's automatically handled for us.  And what we can do is we can just say, you know, print,  you know, user has register.  And there you go, right?  So after the user register, boom, this print function will run.  And if we wanted to do something specific,  we could do that inside of here.  We could have another one, like async, define,  and then on after, forgot password, right?  And then boom, we can do something on after request, verify,  and then we can do something.  I'm just showing you some examples  of you could hook into these if you look into the Fast API user's docs,  and you can control what's happening based on certain operations  that will be automatically handled for you.  So now what we're going to do is we're going to write a quick function.  We're going to say async define, get underscore user underscore manager.  And we're going to say the user DB is equal to SQL Alchemy user database.  And this is equal to depends, get user DB, okay?  We're then going to yield the user manager with the user DB.  So essentially, we're taking our database user kind of injecting that inside of here.  And now we have this user manager class,  which will allow us to manage the users in Fast API.  We then are going to have the bearer underscore transport,  which is equal to the bearer transport.  And then we're going to have our token URL,  be equal to off slash JWT slash login.  So when someone wants to log in, they go to this endpoint,  and then they can pass their credentials and they can log in as a user.  We're then going to say define, get underscore JWT underscore strategy.  And this is going to return JWT strategy.  We're going to pass our secret and we're going to pass our lifetime seconds.  Now the lifetime seconds is how long you want a JWT token to be valid  before before the user needs to sign in again.  I believe this is 3,600 seconds, which is going to be,  what is that, 10 minutes or one hour or something?  Yeah, I think, yeah, so sorry, this is one hour.  So 60 minutes is 3,600 seconds.  So you can change how long you want the token to be alive for essentially.  And if you want to invalidate the token after a certain period of time,  by default, JWT tokens have some lifespan.  The longer you make them, the more convenient it is for users,  but also the less secure because that means like,  you know, someone could come onto your computer, for example,  and they would, you know, be able to just start using the application  because the JWT token is still alive.  Okay, now we have the JWT strategy.  We're going to define the auth backend,  which is going to be equal to the authentication backend.  We're going to say the name is equal to JWT.  The transport is the bear transport.  And we're going to say get strategy is get JWT strategy.  Okay, we're then going to say fast API users is equal to fast API users.  User, uuid.uuid, get user manager, and auth backend.  So when we define fast API users, what we do is we specify,  this is the user model that we're using.  And this is how we get the user manager.  This is the backend that we're using, which is JWT tokens.  Then we say the current active user is equal to fast API users.  Current user active equals true.  What this is going to do is when we call this current active user function,  it's going to automatically give us the current active user  by going and checking the user's JWT token.  Again, I know this stuff is confusing.  You're not going to understand a lot of the stuff that's being written.  The point is this framework when you do the little bit of setup  that we're doing here will automatically.  handle all of the authentication for you,  we just need to kind of hook it up and do this setup.  Once we do this setup, all the JWT auth  will be handled automatically,  and all you need to do is just use this,  which you're gonna see.  So now we've written everything that we need  for users.py.  So what we're gonna do is go back to app.py,  and we're gonna start actually using this  because now we need to essentially connect  different endpoints to this, what do you call it,  JWT kind of backend, which you're gonna see.  So now that we've done that,  we're gonna import this.  So we're gonna say from app.users,  and we're gonna import the auth backend, okay,  we're gonna import the current active user,  and we're gonna import fast API users.  Now what we're gonna do is for our app,  we're essentially gonna connect  the different auth endpoints that we need  to our fast API users endpoint.  So you'll see what I mean in a second,  but we're gonna say the following,  we're gonna say at app.include underscore router,  and we're gonna include the fast API underscore users.get,  underscore auth underscore router,  with the auth underscore backend,  and we're gonna say the prefix for this is equal to slash off,  slash JWT, and we can say the tags is equal to auth.  Now what we're doing here is we're saying, okay,  in my app, I want to include all of the endpoints  that are automatically provided by fast API users.  So I'm just gonna say app.include router,  and I'm gonna connect it to all of the endpoints here,  and I'm gonna prefix this with slash auth slash JWT,  which means I go to slash auth slash JWT,  plus all of the endpoints that are automatically included  by my fast API users kind of module that I brought in here.  Okay, so things like resetting your password.  After you forget the password, what happens?  All of those endpoints are automatically written  and handled here for you, and we just include them into our app.  You'll see what I mean in a second.  Essentially, we're just including some routes  that are automatically written  inside of fast API users in our app.  Okay, now we're gonna keep going  because there's some more routes that we need to include.  So we're gonna say app.include router,  and this is gonna be fast API users.get register routes.  This time, we're gonna prefix it with slash auth,  and the tags will be auth.  However, for the register routes,  we need to pass in some schemas,  which we're gonna write in a second,  which is user read and user create,  and then we're gonna go write those in schemas.  So let's do that really quickly,  and then come back, and I can explain what we need.  So for user read, what we need to do is,  we need to say from fast API,  underscore users imports schemas.  I then need to import UUID.  So I'm now gonna come in, I'm gonna say class, user read,  and this is gonna be from schemas.baseuser,  and this is gonna be UUID.UUID.  Okay, and then this is simply gonna say pass.  I'm then gonna say class, user create.  This is gonna be schemas.baseuser create,  and then I'm gonna say pass, and I'm gonna say class,  user update is gonna be schemas.baseuserupdate,  and then pass.  Now, these are schemas that automatically come  from fast API users, but similarly to some of the schemas  we have before, we need to just create  our own kind of dummy schema that inherits from it,  that we could then override if we want to.  So that's exactly what we're doing.  Now we're gonna go back to app,  and we're gonna import these schemas that we need.  So from app.schemas, we're gonna bring in the user read,  the user create, okay, and the user update,  which we'll have in a second.  All right, and now this should be good to go.  Okay, so that's that for the registration routes.  So again, same thing, we're now gonna have the ability  to register automatically be created for us.  I'm gonna show you this in the documentation  in a second from fast API users.  Now if we wanted to bring in other routes,  we can do that.  So for example, we can say at app.include underscore router,  and then we can say fast API users,  dot get research password router, right?  And now if we do that, we now have the ability  to reset the password.  Now let's keep going.  Let's say app.include router,  and we can do the get verify router.  Now this one we actually need,  because it will allow us to verify user.  So we bring that in, and then notice automatically,  we bring in user read.  And then lastly, we can have get users router.  So I'm gonna say app.include router, get users router,  and then we can include the user read and the user update.  Okay, so let's quickly just reload this,  and I'm just gonna shut this down and restart it,  so that we can test and make sure it's working.  So now,  If I go here, you can see that I have all these new routes  that are popping up, right?  Like login, log in, register, forgot password,  reset password, request verify token, verify.  Users me, users me, users ID, users ID, users ID, right?  All of this kind of stuff that I'm able to now utilize  because I'm using fast API users.  Again, I'm not gonna go through literally  every single thing here, but I will show you the basics.  So what I wanna do now is I want to register a new account.  So what I can do to register is I can go try it out  and I'm just gonna do a new account here.  So I'll go Tim at techwithtim.net.  And then for the password, we'll go 1, 2, 3, 4, 5, 6, 7, 8.  Okay, we'll just make is active true  and then we won't set anything for the superuser  is verified.  You can change the C, you don't pass these  when you register later on,  but for now in kind of debug mode, that's what we're doing.  So actually, let me just change this like Tim1  at techwithtim.net, let's execute this.  And then it's going to now give me my ID, my email,  and then all of this information.  And now what I can do is I can sign in with this user.  So what I'm gonna do is I'm gonna go to authorize,  I'm gonna pass my email and my super secure password  and press on authorize.  And now it's going to essentially sign me in.  Now that I'm signed in, it's gonna give me this token.  And what will happen is whenever I send any requests,  it's going to use this token.  So now I can go to, for example, user slash me  and I can just send the request here  and you're gonna see that it tells me,  hey, I am Tim1 at techwithtim.net.  And notice that automatically,  this super long token was included in my request  because that's how this works.  So if you sign in here with authorize,  then by default, this token that identifies you  is gonna be sent in all of the future requests  as you're using this documentation  and you're gonna be able to verify if your user  or if you're signed in or if you're not signed in, et cetera.  So now all the user stuff is working.  However, we need to associate users with the posts  and we need to make it so that I can't actually  call these endpoints like upload feed or posts  unless I'm signed in, so let's do that.  So I'm gonna go to main.py  and the way that I can make some of these routes  what's called protected is I can add a dependency  that forces the route to get the current active user.  And if the current active user doesn't exist,  it won't let me call this endpoint.  So for example, to be able to actually make an upload,  well, I need to have a user, right?  Like I need to be signed in as a user.  So what I can do is I can just change the function  to be like this.  So I can just say user, colon, and then I can say user  and I can say this is equal to depends  and this is current active user like that.  For user, I can just import that from my database.  So let's just import user like so.  And now what will happen is if I try to call this function  and I'm not signed in and I cannot get the current active user,  this function will not work.  So literally all you have to do now is if you wanna protect  these routes, you just add this dependencies.  So for example, for the feed same thing,  we add the user, we say, okay, you know,  it's just to get current active user  and now it won't work unless we have the user.  Now same thing for the posts,  we're gonna get the current active user.  So let's do that and we're gonna have to change  some of the content of these functions now  so that it actually saves the user  that is doing this operation.  So let's go back to the DB and for our posts,  we're now associating with users.  Okay, so that's all good.  But for our app, when we are uploading images,  we now need to associate them with that user.  So for our upload result here,  let's take user underscore ID  and let's make this equal to the user dot ID.  So now we're storing the particular user  for every single post.  Okay, so that's good.  That's all we need to do there.  Then for deleting the post,  we need to only allow the user to do this  if they're signed in as the correct user.  So once we check for the post,  down here we're gonna say if the post dot user underscore ID  does not equal the user dot ID,  then we need to raise HTTP exceptions.  So let's do this.  Okay, and we're gonna say status code 403,  which means unauthorized, you don't have permission  to delete this post.  So now if I try to create a post with an account  that didn't make this post,  or sorry, I tried to delete a post with an account  that didn't make it,  it's not going to allow me to do that.  Okay, so now we've just added the authorization check  and I think that is pretty much good.  Now we're gonna go to get feed  and forget feed, we're gonna make some enhancements here  so that we actually know which user made these posts  in the feed.  So first things first,  what I'm gonna do is I'm gonna include the user ID  in my response here.  So I'm gonna say user underscore ID  is equal to the string of post dot user underscore ID.  And I'm also gonna include if we are the owner of this post  so that the front end knows that.  So we're gonna say ease owner  and we're gonna say post dot user underscore ID  is equal to user dot ID.  So now we're checking, all right,  is the user ID of this post equal to R.  If it is, that means we made it, if it's not, well, we didn't make it.  Okay, and then I think that should pretty much be good, but there's one last thing actually that we will do.  Okay, so for every single one of our posts, I also want to include some basic information about the user.  And in this case, that's going to be their email.  And what I'm going to do is I'm going to get the user's email.  So I'm going to say email, and then I'm going to say this is post dot user dot email.  And I think that will work, but I'm not 100% sure.  Let's see.  Okay, so now we kind of have protected our endpoints so that only authorized users are able to use this.  And that should pretty much wrap up the API, but of course we want to test this.  And then I'm just going to have a little simple front end that I'll show you how to use.  So we can actually see it visually.  All right, so let's authorize ourselves by signing in with that account.  We're going to say Tim1 at techwithtim.net.  Okay, if we can spell this correctly.  All right, then we're going to have one, two, three, four, five, six, seven, eight.  And authorize.  Okay, so now let's go.  Okay, that's fine.  From here, let's go to the feed.  And let's try to get the feed.  Okay, and when we get the feed gives us internal server error.  Let's see what the problem is there.  Okay, and of course the error came from this where I'm getting the post dot user dot email.  That is not working properly just due to how we're loading the user.  So I'm going to do another approach here.  This is a little bit more complicated, but we'll allow us to get the emails.  So I'm just going to say result is equal to a weight.  This is going to be session dot executes.  And I'm going to say select user.  Then what I'm going to do is say users is equal to row zero for row in result dot all.  Then I'm just going to create a list of all of my users.  This is not the most efficient way to do this, but for this example, it's fine.  So we're going to say user dictionary is equal to, and this is going to be you.  Dot ID.  And this is going to be you dot email for you in users.  Okay, now what we're able to do is we're going to be able to get the users email like this.  So to get the email, we can simply say user underscore dict.  And then this is going to be dot gets and it will be post dot user ID.  Otherwise, we'll just put unknown.  Okay, so now this, if we save, it should reload.  Okay, and now if we go back to the feed, let's try it again.  And you see now that we get the post and it is working and saying we are not the owner of this post  because we were not signed in as that user.  So now if I take this post ID, right?  And if I try to delete this post, you're going to see that it doesn't work.  So let's go here because I'm not signed in as the correct user.  So let's go here and try to delete execute.  And you see it says you don't have permission to delete the post.  Perfect.  So that wraps up the API.  The API is working.  It's fully functioning.  The next thing that I'll quickly show you is how we can get a nice little user interface here  so we can actually play around with the UI.  Now, I'm not going to write the user interface from scratch.  If you want all of the code for this, it will be linked in the description down below.  You can simply copy it and paste it inside of here.  What I'm going to do is just make a new file.  And I'm just going to call this front end dot PY.  I'm just going to copy a bunch of code that I've written previously,  which is the front end and paste it in here.  Now, this code uses something called streamlit,  which is something that we need to install.  So what we're going to do is we're going to keep our back end running.  We're going to go into a new terminal.  We're going to type UV add streamlit.  Now, that's going to add streamlit to our dependencies,  which is going to allow us to now run this front end.  So again, all of this code that you see will be available from the link in the description.  You can literally just copy it into a file called front end.  And this is going to handle essentially interacting with the API  that we just spent all of that time writing.  I will go over how it works in a second, but let's just quickly test it.  So to do this, I'm going to type essentially UV run streamlit,  run main dot, or not main.  This is front end dot PY.  When I do that, it will start running streamlit.  It should just open it in your browser.  And then you have a user interface.  What you can do is you can type in an account,  like Tim at Tech with Tim.Net.  You can type in the password.  When you do that, you can either sign up and make a new account  or you can just log in.  And if you press log in, it should bring you now.  Let's wait a second to the feed failed to get user info.  Okay, interesting.  So we'll fix that in a second.  But it should bring you to the feed once I fix this problem.  And you can see here that it now loads the feed.  We have my username, the date, the image, and then we can delete this.  And we can also expand it directly from here.  Now, I want to talk about kind of how this works.  So I'll walk through the code a little bit.  But again, just copy the code from the link in the description.  It's not really valuable for me to write this out with you  because this is not a tutorial on streamlet.  Now, first things first, the JWT token is something  that we store in our session.  That just means that we're storing it,  so we're constantly using it anytime we send a request to the back end.  Okay, the way that you send JWT...  Buty token request is you include bearer plus the JWT token.  And then when you do that,  you're able to actually send an authenticated request.  You saw this in the examples  when we were looking at the documentation from FAST API,  but I'm just doing it directly,  manually here in Python.  Again, I'll show you how the request looks in a second.  So here is the login page.  So when I want to log in,  what I'm doing is I'm just passing a username and a password,  and I'm passing it to this URL.  So auth JWT log in, right?  Passing my data, and then I'm able to log in.  Now when I do that, I get some token data,  and I store that access token in my state,  so I'm able to use it as my JWT token to sign it.  I then get my user info by passing a request to user slash me  so I can make sure that I'm signed in successfully,  and I store that again in my session state.  Same thing for registering.  I send a request to all slash register,  and then after I register,  I send another request to get my JWT token,  so that I'm good to go.  Okay, now we have the upload page.  On the upload page, what I do is I have files, right?  So I have a file, which is the uploaded file  that I select, which I'm gonna show you in a second,  and I have a caption.  I then include that in the request to upload, right?  As well as my headers, which include my JWT token.  That's then able to upload the image,  and then show it on the feet.  Now the cool part here is when we start talking  about actually displaying the images with ImageKit,  because it makes it super easy for us to view the images  and to actually perform transformations on them.  So let me show you with the UI.  If I go here, and I go to upload,  okay, so let's go to upload, let's change this here,  and let's upload here, this one with MinibinMe,  which is a testimony, and I'm gonna say,  hello world, dev launch, worked, okay,  because this helped him land a job.  Let's go share, and then it's gonna upload this file for me  to my backend API.  And if I go back to the feed now,  just takes a second to load,  we'll see the image appears here.  And one thing you'll notice if I make these larger  is that we have this caption that I'm kind of putting  directly on top of the images by using ImageKit,  where I say hello world, dev launch work.  Now it's quite small, I'm gonna show you how to make it larger,  but the way that I do that is from my UI  before I load the image, so if we go down here,  let's do this.  You can see that I have these file types,  so I check if it's an image,  which is all we've done right now,  but I'll show you videos in a second,  then what we'll do is we will essentially transform the URL  to use the transformation that puts the caption  directly on top of it that looks like this.  So this is essentially the text that you use  if you wanna add a caption.  If I wanna make it bigger, I can say like font size 100,  and then it will make it much larger,  and then it directly transforms the image from me  from this one URL and passes it back very quickly, okay?  So that's how I'm kind of transforming this.  Now I wanna show you uploading a video,  which we'll do in one second,  and then displaying the caption for that video,  but that's kind of how I'm doing that transformation  with ImageKit and displaying the images.  So let's go back, and now if I refresh this,  let's sign in again, so 1, 2, 3, 4, 5, 6, 7, 8,  and go log in, then let's wait a second here, okay?  And we'll go to the feed, and okay, get rid of that,  and you can see now it's quite a bit larger,  because I made the font size 100,  if I made it like 1,000, obviously it would be even much bigger,  and you can see the text shows up on the image.  Now, if I want upload a video, I can totally do that as well,  so let's go files, and then we find a video.  Okay, so I just found this screen recording that's not that big,  so I'm just gonna upload this screen recording,  so you can see right there,  gonna go ahead and press on share,  because it is a video,  it will take a little bit longer to upload,  so we'll just wait for that to complete,  and then as soon as it's uploaded, okay?  So let's go back to the feed here.  We should be able to see it directly from ImageKit,  see it's gonna take one second to load here,  and then there you go, we get the video,  and we can watch it, right?  And it just shows up directly here.  Now, same thing with when we transform the images,  we can transform the video.  So let me show you a few examples of how we actually do that.  Let's go here,  and what I'm gonna do is,  I'm just gonna put in some transformation parameters.  Right now, you can see that I'm just putting it quality at max,  and with 300, but I can adjust this to, for example,  crop the video.  So for example, if I just take this transformation parameter,  I'll just show you what this does,  but essentially it crops the video,  and then adds a blurred background,  and puts it in vertical format for me.  In this case, it's already vertical,  but if it wasn't vertically, it would do that.  So if I go back to my, was it sample here, UI?  Let's just go back to the feed, so it reloads.  Okay, and actually you can see that this did work now.  So it resized to be quite small,  and you can see now that we have kind of this video  like in the middle,  and then we have this blurred background,  which is exactly what I got the transformation to do.  The quality is quite low, obviously,  because of how I adjusted it,  and the size that I made it,  but you can see that it is working.  And sorry if I just scared you there with that auto-  that scared me as well, but the point is, it is loading.  Cool, so I think that's pretty much it, guys.  I mean, that covers everything that I wanted to show you.  We made an application that's able to post photos  and videos, is able to handle user auth  connected to a database, has all kinds of different  more advanced features that you typically don't see  in more beginner tutorials.  And while I know this was a really long video  and a lot of code, I wanted to be super detailed  and covered everything that's much depth as I possibly can.  If you guys enjoyed this video, make sure you leave a like,  subscribe to the channel, and I will see you in the next one."
kV37p-VLh9s,Make sure you code is as portable as possible.,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-10-29T18:54:39Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/kV37p-VLh9s/default.jpg,https://i.ytimg.com/vi/kV37p-VLh9s/hqdefault.jpg,PT1M18S,29501,881,9,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"portability. How can I make sure the code that I'm writing is as portable as possible and  is going to work in as many situations as it possibly can? All right, so let's look  at a bad file handler. Notice that we have this data processor and then inside of here  we hard-code some input and output directories. Now immediately by us hard-coding these  directories, what we've done is just ensure that this code will never work on any machine  other than ours. The reason for that is that I would need to manually change this, which  is obviously not good for the code that doesn't make it portable. And this is a Windows  file path, which means even if we did have these exact directory structures on Mac or Linux,  for example, this would simply not work because of the fact that we've hard-coded the Windows  style path rather than using a dynamic path, which you can do in Python. So if we go to  a good example here, you can see that what I do right away is I import OS and I create  this environment variable file. Inside of here, I put all of the dynamic values that I may  need to change depending on the environment in which I'm running this code. I have my  API information, I have the current environment I'm in, I have the file path directory which  works cross-platform. And now if I go here, I rely on environment variables rather than  relying on hard-coded values. Same thing for my file paths, I use the path variable from  the pathlib, which makes this dynamic and works cross-platform."
PAiT0Hg_R1Y,Make sure you follow this backend developer roadmap!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-10-28T19:29:33Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/PAiT0Hg_R1Y/default.jpg,https://i.ytimg.com/vi/PAiT0Hg_R1Y/hqdefault.jpg,PT1M21S,28323,1233,20,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"get into my personal favorite roadmap, which is for a backend developer, specifically focused  more on web development. So yes, you'll be working in Python, but you should understand  HTML, CSS, and a little bit of JavaScript. So you're at least comfortable reading the  code and writing little snippets of it. Next, you're going to want to understand core  networking methods and things like HTTP and APIs. So you should understand what a put request  is, a patch request, what an endpoint is, what query parameters are, and how the internet  works, at least on a surface level. Moving on, you're going to want to learn some  various backend frameworks. I'd recommend you start with something like flask. This  is the most lightweight. Then move into something like fast API, which is a bit more  performant. And then lastly, get into Django, which is really a full stack framework that  allows you to build a website completely from scratch, both the front end and the backend,  not just the API component, which the other two mostly focus on. Next, you're going to  get into databases and ORMs. And an ORM is an object relational mapping. And something  that's very popular and Python for working with your core database. So you're going to  want to learn definitely about SQL alchemy. This is something that works with flask, fast  API, et cetera. And then the Django ORM, if you're working obviously in the Django framework,  I would also recommend looking into reddies for things like caching and message cues. I  would also look into some database optimization techniques and learn about things like indexing."
e0FvoOtdAQc,3 Unique Python Features You NEED To Know,"üëâ To learn for free on Brilliant, go to https://brilliant.org/techwithtim . Brilliant‚Äôs also given our viewers 20% off an annual Premium subscription, which gives you unlimited daily access to everything on Brilliant. 

Python is definitely an interesting language that has many unique features. However, many of these features are never actually used out in the wild because people simply don't know they exist. So in this video, I'm going to go over some more modern and relatively new Python features that I rarely see used that I think are interesting and that you should definitely know about.

DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim?video=e0FvoOtdAQc

‚è≥ Timestamps ‚è≥
00:00 | Match Statement
04:24 | Dataclasses
08:47 | Positional & Keyword ONLY Arguments 

Hashtags
#Python #Brilliant #SoftwareEngineer",2025-10-28T13:55:52Z,"tech with tim, Python, python match statement, python dataclasses, python arguements, switch statement, programming languages, python keyword arguments, python positional arguments, python parameters, APIs, data classes, python coding, python programming, advanced python, learn python, software engineering",27,en,en-CA,https://i.ytimg.com/vi/e0FvoOtdAQc/default.jpg,https://i.ytimg.com/vi/e0FvoOtdAQc/hqdefault.jpg,PT16M2S,15827,556,26,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Python is definitely an interesting language that has many unique features.  However, many of these features are never actually used out in the wild because people simply  don't know they exist.  So in this video, I'm going to go over some more modern and relatively new Python features  that I rarely see used that I think are interesting and that you should definitely know about.  They're not all in the most recent version of Python, but they're things that are in modern  Python that I think are worth knowing.  With that said, let's dive in.  The first feature I have on my list here is called the match statement.  Now, it's also referred to as structural pattern matching has a few different names  and it was released in Python version 3.10.  Now, you've likely seen this before, but I doubt that you've actually used it in your code.  And when I review Python code, many people don't actually seem to use this.  OK, so what is the match statement?  Well, the match statement, when you simply works exactly like a switch statement in various  other programming languages.  For example, let's just move this down here.  You can have a look at this code right here.  You see we have some inner function.  This function has a match statement inside of it.  And all we're doing is we're trying to match the status to one of these various cases  that we have.  So we have a case for success.  That simply means if status is equal to success, go ahead and do this.  We have a case for error means same thing.  If it's error, you know, go ahead and do this pending, do this, and then we have a default  case.  A default case is kind of like an else statement or default, if you're familiar with  a switch statement, where if the status doesn't match any of these that will go ahead into  this default case, the default case isn't required.  We don't have to have it, but in this case, we do where we just put the default case  to handle anything else.  Okay, so if we were to run this function here, you can see that we can kind of go through  this match statement and we can process all of these different values that we have in  our list.  And then we would get the output, you know, operation completed and error occurred, still  in progress, et cetera.  So that alone is pretty useful.  It can allow us to prevent writing into a ton of nested if statements and we can just write  it like this match statement, where we're trying to match a particular value.  However, where this gets more interesting is when we get into a more complex pattern matching  scenario.  So this match statement doesn't just work to match strings or numbers or, you know, particular  value, you can actually match patterns.  So have a look at this second example down here.  What we're able to do is we have a case for simply the value zero, right?  So just like before, we can match if data is equal to zero.  We also can use this pipe operator and we can check for multiple values.  So we can check if it's one or if it's two or if it's three and all of that will be  handled by this case.  And we can also check for the structure, which is why a lot of times people refer to  this as structural pattern matching of the object, which is data.  So in this case, we can say case first and second.  Now what this is saying is we're looking for any kind of data where we have an array  or sorry, a list I should say in Python of two values.  So for example, if you look down here, we have apple and banana, that would match with  this pattern right here.  And then we would be able to extract the values.  So apple and banana were the first and second item by using the variables first and second.  I know it looks a little bit weird.  It looks kind of like magic.  But that's how this works.  And the same thing with a dictionary or an object in Python, whatever you want to refer  to it as, right?  What we're able to do is we have names of the key name, some value name, the key age,  some value age.  In this case, we're matching with anything that is a dictionary that contains exactly  these two keys and then we can strip out what the values are and print them.  We're processing them.  However, we want.  We also can just check if something is a string.  This is kind of interesting, right?  We can just use the string function and now we're saying, okay, I want to match anything  that is a string.  Then if we go down here, this is the default case.  So I'm going to run the code for you so you can quickly see that this does indeed work  and notice that we get all of the match statements here up above, right?  And then same thing, we have all of the match statements here.  Now it's important to note when you use the match statement that it's going to attempt  to match in the order in which you write these cases.  So for example, if we change this to zero, right?  And then we had some string zero.  We would actually match with this first statement here, not with this statement down here,  okay?  Because it's going to go into the first case that it sees, especially because we have  the return.  Now there's a lot of other information, sorry, about the match statement.  You could do some really interesting, complex stuff here.  I definitely would suggest checking it out.  I'll leave a link to the documentation in the description down below.  This is a feature that I rarely see used, which can be extremely powerful, especially  when you have a variety of different type of data and you want to process that in some  kind of format, right?  So we can look for the exact type of pattern, really simplifies and cleans up our code,  and then we can handle all of these different cases as we see fit.  Now, the next feature on my list is actually relatively old compared to the other ones  on this list.  However, it is still something that's definitely worth knowing about and that I see few  Python developers, especially beginners are intermediates using.  Now, that's called data classes.  In order for us to see the value of this, we need to actually look at how you would typically  write a class before data classes existed.  In Python, if you want to have a class that represents data, so represents like a user  or a book or some kind of entity, you would typically write it something like this where  you have this init method, maybe you take in an ID, some name, maybe some roles for this  particular user, and then you're almost always going to  be defining a few methods on these objects  to make them more usable in your code.  For example, you'll use this magic method wrapper,  which gives you a string representation of the object,  so you can actually see what it looks like  if you're debugging the code, for example,  and you write something like this,  where you have user, name, and then the rules.  Then you have something like equals, for example,  where you're gonna check the equivalence of two objects.  You might have the string method,  you might have a few other ones as well, right?  But a lot of times when you're just trying to represent data,  you're almost always just writing the same  kind of boilerplate code.  You're always writing the same equal method,  you're always writing the same wrapper method,  and there isn't really a good reason to do that,  other than the fact that there's no better way.  So what I'm gonna show you now is what's called  the data class, which avoids you having to do all of this.  So we're gonna open up this example here,  and notice that we have this class right here,  which is a data class,  and this is exactly the same as the class that you just saw.  It's equivalently pretty much the exact same,  there's a few very, very minor differences,  and it's written in significantly less code.  There was no init method, there's no equal method,  there's no wrapper method, right?  We didn't have to do any of that,  but this actually functions the exact same way.  On this data class, I can use the double equal sign, right?  Between two user objects,  and it will test for equivalence in the exact same way  as our other class.  I can try to print it out,  and when I print it out,  I'm gonna get that wrapper,  where it's gonna show me exactly what this looks like  in that debugging format.  And by default, if I don't pass a role,  it's automatically gonna be an empty list  because of this field that I brought in here  from the data classes.  Now, I have a whole video on data classes,  which I will link on screen,  which you can watch if you want the really in-depth explanation,  but the point is these are very, very useful.  Now, one thing to note here is that I did enable frozen on this  because I decorated it with the data class decorator,  and when I do that,  it means that you cannot change the values  inside of this user object,  you can freeze it, right?  You can make it immutable,  which is also an interesting component of data classes.  So in order to make something a data class,  you use the data class decorator,  you define the different fields that you want,  you can use standard Python types,  or you can use from the typing module, for example,  if you want something like a list,  and then if you want some kind of default value,  you can do that with this field.  So default fax remains create a new list.  It's important you do it like this  and not define a list due to how Python  kind of interprets that list object.  And then if we come down here in another example,  we have a products, for example, right?  We have a price, we have in stock, ID, name,  in this case, it's mutable.  And if we look down here, these are the operations  you can perform on these data classes  that are automatically implemented,  that you don't need to write yourself.  So I can create an instance of user,  and I didn't need to write a knit.  I can have the ID, I can have the name,  I can have the rules, I don't need to pass the rules.  Same thing with the product, I can pass the values,  I didn't need to write the a knit method.  Then I can print these out.  When I do that, it's automatically going to use  a wrapper method formula, which I'm going to show you  in one second, and then you can check  for the equivalence of these values, right?  And an equal method is automatically implemented for you.  Same thing with the immutability, which will be in force,  which I'll show you, and then this works really nicely  with the match statement.  So what I can actually do is I can now use these objects  with the match statement, and I can check  if a product has the price of zero, right?  I can check if the product has a price that's greater  than 1,000 or something, right?  Where I can check if it's a regular product.  So it's kind of a cool thing you can do with match.  If I run this code here, scroll down,  and notice that we get the user, right?  So this is automatically implemented for us.  We get product automatically implemented.  We get the equal method automatically implemented.  Same thing here, user cannot modify the field name  because it's immutable, and then it defines  that one of our products was expensive  because we made it $1200.  Okay, so the data class is super, super useful.  Again, I'll put that video on screen,  and just consider, right?  This versus this, which one would you rather write?  Of course, you would rather use the data class.  Now, the next feature that I have for you  is something called the positional or keyword only parameters.  Now, parameters in Python are notoriously a little bit confusing  because of all of the different combinations of ways  that you can call them.  So I want to quickly go into a bit of a primer  about parameters and then show you  this relatively new feature.  All right, so let's have a look at this function here, right?  We have some function.  We have some values, no, A, B, C, D, right?  These are our parameters.  Now, when I call the function, I can call it  using what's known as positional parameters.  So I can say, you know, my function,  and I can pass one, two, three, four, or something, right?  And when I do that, I'm now assigning the value A to one,  B to two, C to three, D to four.  So I can do that, that's totally fine.  But I also could do something like,  B equals two, A equals one, okay?  And then I can say, C equals three, D equals whatever.  And I can pass these in like kind of a random order,  whatever order that I want.  And I can kind of pick and choose  if I want to pass them positionally  or if I want to pass them using a keyword argument,  which is what I'm doing right here.  And there's all kinds of other combinations of ways  that I could call this function,  and it can be a little bit confusing.  Now, it's fine, right?  That's just by default how functions are written,  but in Python,  there's actually a way to enforce  the way in which your functions are called.  And that is by using this fancy operator right here,  which is the slash.  Now this slash forces arguments to be passed  positionally only.  I know it seems a bit weird why would you do this?  We'll talk about that a little bit later,  but by me implementing this slash now  inside of these function parameters,  which is something you may see in larger libraries,  it now doesn't allow me to pass name  using a keyword argument.  And again, we'll talk about why that's important  in a second.  So you can look here and you can see I can call it  in this way, right?  I can call it with Alice.  I can call it with Bob and Hi.  I can call it with Charlie and the greeting is equal to hey  because name is passed positionally.  Where I'm not manually defining, you know, name is equal  like this to Alice.  However, if I go down here and I try to call this,  where I say, you know, greet, name is equal to David,  you'll see that we actually get a type error  and it will tell us this is a positional only argument  or parameter and that I cannot call it  by specifying the name.  So let me just call this function  and show you what that looks like.  Okay, and you can see all three of these function calls  worked properly.  And then when I did try to call it here,  you can see result four.  It said this was a positional only argument, right?  So got some positional only arguments passed  as a keyword argument name.  So you are able to do this enforcement.  Okay, now let me quickly talk about why  that's actually important.  The reason why this is interesting actually applies more  to APIs and if you're creating libraries  that other people are going to be using,  and that's because this allows you to make significantly  more robust functions and just APIs in general  so that you can control the way in which they're used  and make sure they stay backwards compatible.  So for example, if callers can't use a name, right?  If I'm not able to use, you know, name is equal to whatever  and pass the parameter or, you know, values equal to whatever  or max is equal to two.  If I can't use that, right?  As a keyword argument, then it means  that I can rename this parameter later on  and I'm not going to break any user's code.  So this is especially important when you're writing something  that you know is going to change in the future.  If you make sure that something is only passed positionally,  then the name of the positional argument  doesn't actually matter and you can change it  to anything you want in the future  or implement it a new, for example,  keyword argument that has the same name.  So this just allows flexibility to you  as someone who's writing these functions.  Now again, imagine the code you're writing  is used by someone else and maybe millions of people  are using it and then all of a sudden  you change the name of one of your parameters.  If it could have been called by a keyword  and you now change it, you're going to break  a bunch of people's code, right?  So that's kind of one of the main reasons.  Now another one is semantics, right?  So some of the parameters don't have meaningful names.  For example, x, y, a, b, you know, one, two, whatever, right?  So when you force the use of positional arguments,  you signal to the user that this is more used internally  in the function and to pass it positionally  rather than trying to name the keywords.  Now same thing as I said before,  room for future keyword updates, right?  So you can keep the names available to use them later on.  And then it's also more consistent with built-in functions  where a lot of the built-in functions work like this already  where you can only pass values positionally, right?  You can't pass them with keyword arguments.  So hopefully that makes a little bit of sense.  Now to kind of continue this,  you also can force arguments to be only keyword  so not be pass positionally and be pass keyword only  and that's by using this asterisk.  So the way this works is anything  that I want to be positional only.  I put before this forward slash.  If I do that, anything before this,  so you don't pause only two, right?  All of these can only be passed by position.  Then anything after this can be passed freely as normally  so it can be passed by position or by keyword, okay?  So regular, I can pass this with a keyword argument  or I can pass it normally.  Then if I put in asterisk,  anything to the right of this can only be passed by a keyword.  So now I cannot pass this value positionally.  I can only pass it by a keyword and similar reasons  for doing that apply to as why you would only pass it positionally.  I know this is kind of advanced niche Python code,  but that's the point of this video is to show you guys  some new stuff that you probably never seen before.  I know I didn't see this until I started looking deeper into it.  Let's actually run the code here  and you can see now that this works right  and says mix parameters, position only one, regular two,  keyword only three.  I just quickly changed this example back  so it would work with the way that it was being called.  Anyways, that is pretty much gonna wrap this up.  If you've made it to this point in the video,  then I can tell you definitely valued learning.  You'll like more of those advanced topics  and I mean you're spending your time watching a video like this.  And if that's the case,  then I think you would definitely benefit  from the sponsor of today's video, which is brilliant.  Brilliant is where you learn by doing  with thousands of interactive lessons in math,  data analysis, programming and AI.  They adopt a first principles approach  ensuring you understand the why behind each concept.  Every lesson is interactive, engaging you  and hands on problem solving,  which is proven to be six times more effective  than simply watching lectures.  The content is developed by top notch educators,  researchers and professionals from renowned institutions  like MIT, Caltech and Google.  Brilliant emphasizes enhancing your critical thinking abilities through active problem-solving  rather than memorization.  As you learn specific subjects, you're simultaneously training your mind to think more effectively.  Consistent daily learning is crucial, and Brilliant makes it effortless with their bite-sized  lessons, allowing you to acquire meaningful knowledge in just a few minutes each day,  which is perfect for replacing idle screen time.  Additionally, Brilliant offers a comprehensive range of computer science and Python courses,  as well as extensive AI workshops guiding you from a complete beginner to an expert through  practical hands-on lessons.  To learn for free, on Brilliant, go to brilliant.org slash tech with Tim, scan the QR code on  screen, or click the link in the description.  Brilliant is also given our viewers 20% off an annual premium subscription, which gives  you unlimited daily access to everything on Brilliant.  Thanks to Brilliant for sponsoring this video, and I look forward to seeing you in the  next one."
YwrapdgMKqI,The first things you need to look at as a data scientist!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim",2025-10-27T19:18:07Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/YwrapdgMKqI/default.jpg,https://i.ytimg.com/vi/YwrapdgMKqI/hqdefault.jpg,PT53S,19591,475,2,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"Now the first thing that we need to look at  as a data scientist is some essential libraries.  So things like NumPy and Pandas for data manipulation  and things like Mapplotlib and Seaborn  for data visualization.  You also wanna learn about data cleaning  and preprocessing techniques.  If you as after all, a data scientist  works with a lot of data.  Next, you will wanna know some math and statistics.  So learn probability and statistics, linear algebra,  things like vectors, matrices, et cetera.  Next, you wanna start getting into some machine learning.  So learning about libraries like Scikit-Learn, for example,  for supervised and unsupervised learning  and learning about the core machine learning algorithms,  things like linear regression, clustering with K nearest  neighbors or K means, support vector machines,  all of these things that really make up  the foundation of machine learning.  Beyond that, you need to learn about feature engineering  and model evaluation and things like hyper parameter tuning."
qvpbO5Y9jN0,Starting our AI agent!,"DevLaunch is my mentorship program where I personally help developers go beyond tutorials, build real-world projects, and actually land jobs. No fluff. Just real accountability, proven strategies, and hands-on guidance. Learn more here - https://training.devlaunch.us/tim

üéû Video Resources üéû

‚è≥ Timestamps ‚è≥

Hashtags",2025-10-26T18:20:00Z,tech with tim,27,en,en-CA,https://i.ytimg.com/vi/qvpbO5Y9jN0/default.jpg,https://i.ytimg.com/vi/qvpbO5Y9jN0/hqdefault.jpg,PT53S,14861,371,5,public,UC4JX40jDee_tINbkjycV4Sg,Tech With Tim,"I'm Tim, a self-taught developer & entrepreneur who brings you educational tech content without the fluff and noise. I went from a broke dropout working at McDonalds to making $100k+/month as a developer, travelling the world and moving to Dubai all before the age of 22. I've since helped thousands of aspiring developers land their first software engineering role and assisted mid-level devs land jobs at companies like google.

Max landed his first developer job 3 weeks after going through my training.
Youssef was laid off and landed a new role in 2 months while working with me.
Jamario landing competing job offers before graduating college.

If you want to learn more you can click the first link and watch my free training on how we help developers who already know how to code get hired by top tech companies.
",CA,https://yt3.ggpht.com/ytc/AIdro_k15oXl74WcnpdL-uVBv6IHBgAfXEEnpUiS-IoEyV1auyY=s800-c-k-c0x00ffffff-no-rj,1910000,1739,UU4JX40jDee_tINbkjycV4Sg,"First things first, we're going to bring in our imports.  Now we're going to need to import a few things from the standard library for doing our  typing.  We're then going to bring chat, open AI.  We're going to bring in a bunch of different messages that we need.  We're going to import the tool and then we're going to import the Create React agent, which  comes from LandGraph.  Now, we're also going to do another import where we say from .env imports and this is going  to be load.env, we're then going to call the load.env function and what this is going  to do is load our environment variables from our environment variable file.  We're using a combination of LandGraph and LandChain here in order to initialize our  agent and to get it to be able to call tools.  The thing that makes an agent an agent is that it has access to something outside of  just a chat interface.  So in our case, we're going to provide to this agent a series of tools that allows it  to generate kind of mock user data and then save that data into JSON files."
